   1              		.file	"i2c.c"
   2              		.text
   3              	.Ltext0:
   4              		.file 0 "/home/asoreyh/Dropbox/projects/lago/acqua/nexys/src/makestuff/libs/libfx2loader" "i2c.c"
   5              		.globl	i2cInitialise
   7              	i2cInitialise:
   8              	.LFB4:
   9              		.file 1 "i2c.c"
   1:i2c.c         **** /*
   2:i2c.c         ****  * Copyright (C) 2009-2012 Chris McClelland
   3:i2c.c         ****  *
   4:i2c.c         ****  * This program is free software: you can redistribute it and/or modify
   5:i2c.c         ****  * it under the terms of the GNU Lesser General Public License as published by
   6:i2c.c         ****  * the Free Software Foundation, either version 3 of the License, or
   7:i2c.c         ****  * (at your option) any later version.
   8:i2c.c         ****  *
   9:i2c.c         ****  * This program is distributed in the hope that it will be useful,
  10:i2c.c         ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:i2c.c         ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:i2c.c         ****  * GNU Lesser General Public License for more details.
  13:i2c.c         ****  *
  14:i2c.c         ****  * You should have received a copy of the GNU Lesser General Public License
  15:i2c.c         ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:i2c.c         ****  */
  17:i2c.c         **** #include <stddef.h>
  18:i2c.c         **** #include <makestuff.h>
  19:i2c.c         **** #include <liberror.h>
  20:i2c.c         **** #include <libbuffer.h>
  21:i2c.c         **** #include "libfx2loader.h"
  22:i2c.c         **** 
  23:i2c.c         **** #define LSB(x) ((x) & 0xFF)
  24:i2c.c         **** #define MSB(x) ((x) >> 8)
  25:i2c.c         **** 
  26:i2c.c         **** // Initialise the buffer as a C2 loader, using supplied values. It seems like for C2 loaders the
  27:i2c.c         **** // values of vid & pid are never used though. The configByte has only two bits - bit zero selects
  28:i2c.c         **** // 400kHz I2C bus speed and bit six sets the USBCS.3 bit "DISCON" so the chip comes up disconnected
  29:i2c.c         **** //
  30:i2c.c         **** DLLEXPORT(void) i2cInitialise(
  31:i2c.c         **** 	struct Buffer *buf, uint16 vid, uint16 pid, uint16 did, uint8 configByte)
  32:i2c.c         **** {
  10              		.loc 1 32 1
  11              		.cfi_startproc
  12 0000 F30F1EFA 		endbr64
  13 0004 55       		pushq	%rbp
  14              		.cfi_def_cfa_offset 16
  15              		.cfi_offset 6, -16
  16 0005 4889E5   		movq	%rsp, %rbp
  17              		.cfi_def_cfa_register 6
  18 0008 48897DF8 		movq	%rdi, -8(%rbp)
  19 000c 89C8     		movl	%ecx, %eax
  20 000e 4489C7   		movl	%r8d, %edi
  21 0011 89F1     		movl	%esi, %ecx
  22 0013 66894DF4 		movw	%cx, -12(%rbp)
  23 0017 668955F0 		movw	%dx, -16(%rbp)
  24 001b 668945EC 		movw	%ax, -20(%rbp)
  25 001f 89F8     		movl	%edi, %eax
  26 0021 8845E8   		movb	%al, -24(%rbp)
  33:i2c.c         **** 	buf->length = 8;
  27              		.loc 1 33 14
  28 0024 488B45F8 		movq	-8(%rbp), %rax
  29 0028 C7400808 		movl	$8, 8(%rax)
  29      000000
  34:i2c.c         **** 	buf->data[0] = 0xC2;
  30              		.loc 1 34 5
  31 002f 488B45F8 		movq	-8(%rbp), %rax
  32 0033 488B00   		movq	(%rax), %rax
  33              		.loc 1 34 15
  34 0036 C600C2   		movb	$-62, (%rax)
  35:i2c.c         **** 	buf->data[1] = LSB(vid);
  35              		.loc 1 35 5
  36 0039 488B45F8 		movq	-8(%rbp), %rax
  37 003d 488B00   		movq	(%rax), %rax
  38              		.loc 1 35 11
  39 0040 4883C001 		addq	$1, %rax
  40              		.loc 1 35 15
  41 0044 0FB755F4 		movzwl	-12(%rbp), %edx
  42 0048 8810     		movb	%dl, (%rax)
  36:i2c.c         **** 	buf->data[2] = MSB(vid);
  43              		.loc 1 36 15
  44 004a 0FB745F4 		movzwl	-12(%rbp), %eax
  45 004e 66C1E808 		shrw	$8, %ax
  46 0052 89C2     		movl	%eax, %edx
  47              		.loc 1 36 5
  48 0054 488B45F8 		movq	-8(%rbp), %rax
  49 0058 488B00   		movq	(%rax), %rax
  50              		.loc 1 36 11
  51 005b 4883C002 		addq	$2, %rax
  52              		.loc 1 36 15
  53 005f 8810     		movb	%dl, (%rax)
  37:i2c.c         **** 	buf->data[3] = LSB(pid);
  54              		.loc 1 37 5
  55 0061 488B45F8 		movq	-8(%rbp), %rax
  56 0065 488B00   		movq	(%rax), %rax
  57              		.loc 1 37 11
  58 0068 4883C003 		addq	$3, %rax
  59              		.loc 1 37 15
  60 006c 0FB755F0 		movzwl	-16(%rbp), %edx
  61 0070 8810     		movb	%dl, (%rax)
  38:i2c.c         **** 	buf->data[4] = MSB(pid);
  62              		.loc 1 38 15
  63 0072 0FB745F0 		movzwl	-16(%rbp), %eax
  64 0076 66C1E808 		shrw	$8, %ax
  65 007a 89C2     		movl	%eax, %edx
  66              		.loc 1 38 5
  67 007c 488B45F8 		movq	-8(%rbp), %rax
  68 0080 488B00   		movq	(%rax), %rax
  69              		.loc 1 38 11
  70 0083 4883C004 		addq	$4, %rax
  71              		.loc 1 38 15
  72 0087 8810     		movb	%dl, (%rax)
  39:i2c.c         **** 	buf->data[5] = LSB(did);
  73              		.loc 1 39 5
  74 0089 488B45F8 		movq	-8(%rbp), %rax
  75 008d 488B00   		movq	(%rax), %rax
  76              		.loc 1 39 11
  77 0090 4883C005 		addq	$5, %rax
  78              		.loc 1 39 15
  79 0094 0FB755EC 		movzwl	-20(%rbp), %edx
  80 0098 8810     		movb	%dl, (%rax)
  40:i2c.c         **** 	buf->data[6] = MSB(did);
  81              		.loc 1 40 15
  82 009a 0FB745EC 		movzwl	-20(%rbp), %eax
  83 009e 66C1E808 		shrw	$8, %ax
  84 00a2 89C2     		movl	%eax, %edx
  85              		.loc 1 40 5
  86 00a4 488B45F8 		movq	-8(%rbp), %rax
  87 00a8 488B00   		movq	(%rax), %rax
  88              		.loc 1 40 11
  89 00ab 4883C006 		addq	$6, %rax
  90              		.loc 1 40 15
  91 00af 8810     		movb	%dl, (%rax)
  41:i2c.c         **** 	buf->data[7] = configByte;
  92              		.loc 1 41 5
  93 00b1 488B45F8 		movq	-8(%rbp), %rax
  94 00b5 488B00   		movq	(%rax), %rax
  95              		.loc 1 41 11
  96 00b8 488D5007 		leaq	7(%rax), %rdx
  97              		.loc 1 41 15
  98 00bc 0FB645E8 		movzbl	-24(%rbp), %eax
  99 00c0 8802     		movb	%al, (%rdx)
  42:i2c.c         **** }
 100              		.loc 1 42 1
 101 00c2 90       		nop
 102 00c3 5D       		popq	%rbp
 103              		.cfi_def_cfa 7, 8
 104 00c4 C3       		ret
 105              		.cfi_endproc
 106              	.LFE4:
 108              		.section	.rodata
 109              	.LC0:
 110 0000 64756D70 		.string	"dumpChunk()"
 110      4368756E 
 110      6B282900 
 111              		.text
 113              	dumpChunk:
 114              	.LFB5:
  43:i2c.c         **** 
  44:i2c.c         **** // Dump the selected range of the HexReader buffers as I2C records to the supplied buffer. This wil
  45:i2c.c         **** // split up large chunks into chunks 1023 bytes or smaller so chunk lengths fit in ten bits.
  46:i2c.c         **** // (see TRM 3.4.3)
  47:i2c.c         **** //
  48:i2c.c         **** static I2CStatus dumpChunk(
  49:i2c.c         **** 	struct Buffer *destination, const struct Buffer *sourceData, const struct Buffer *sourceMask,
  50:i2c.c         **** 	uint16 address, uint16 length, const char **error)
  51:i2c.c         **** {
 115              		.loc 1 51 1
 116              		.cfi_startproc
 117 00c5 F30F1EFA 		endbr64
 118 00c9 55       		pushq	%rbp
 119              		.cfi_def_cfa_offset 16
 120              		.cfi_offset 6, -16
 121 00ca 4889E5   		movq	%rsp, %rbp
 122              		.cfi_def_cfa_register 6
 123 00cd 4883EC50 		subq	$80, %rsp
 124 00d1 48897DD8 		movq	%rdi, -40(%rbp)
 125 00d5 488975D0 		movq	%rsi, -48(%rbp)
 126 00d9 488955C8 		movq	%rdx, -56(%rbp)
 127 00dd 89C8     		movl	%ecx, %eax
 128 00df 4489C2   		movl	%r8d, %edx
 129 00e2 4C894DB8 		movq	%r9, -72(%rbp)
 130 00e6 668945C4 		movw	%ax, -60(%rbp)
 131 00ea 89D0     		movl	%edx, %eax
 132 00ec 668945C0 		movw	%ax, -64(%rbp)
  52:i2c.c         **** 	I2CStatus iStatus, returnCode = I2C_SUCCESS;
 133              		.loc 1 52 21
 134 00f0 C745E400 		movl	$0, -28(%rbp)
 134      000000
  53:i2c.c         **** 	BufferStatus bStatus;
  54:i2c.c         **** 	size_t i, startBlock;
  55:i2c.c         **** 	if ( length == 0 ) {
 135              		.loc 1 55 5
 136 00f7 66837DC0 		cmpw	$0, -64(%rbp)
 136      00
 137 00fc 7565     		jne	.L5
  56:i2c.c         **** 		return I2C_SUCCESS;
 138              		.loc 1 56 10
 139 00fe B8000000 		movl	$0, %eax
 139      00
 140 0103 E98E0100 		jmp	.L4
 140      00
 141              	.L8:
  57:i2c.c         **** 	}
  58:i2c.c         **** 	while ( length > 1023 ) {
  59:i2c.c         **** 		iStatus = dumpChunk(destination, sourceData, sourceMask, address, 1023, error);
 142              		.loc 1 59 13
 143 0108 0FB74DC4 		movzwl	-60(%rbp), %ecx
 144 010c 488B7DB8 		movq	-72(%rbp), %rdi
 145 0110 488B55C8 		movq	-56(%rbp), %rdx
 146 0114 488B75D0 		movq	-48(%rbp), %rsi
 147 0118 488B45D8 		movq	-40(%rbp), %rax
 148 011c 4989F9   		movq	%rdi, %r9
 149 011f 41B8FF03 		movl	$1023, %r8d
 149      0000
 150 0125 4889C7   		movq	%rax, %rdi
 151 0128 E898FFFF 		call	dumpChunk
 151      FF
 152 012d 8945EC   		movl	%eax, -20(%rbp)
  60:i2c.c         **** 		CHECK_STATUS(iStatus, "dumpChunk()", iStatus);
 153              		.loc 1 60 3
 154 0130 837DEC00 		cmpl	$0, -20(%rbp)
 155 0134 7421     		je	.L6
 156              		.loc 1 60 3 is_stmt 0 discriminator 1
 157 0136 488B45B8 		movq	-72(%rbp), %rax
 158 013a 488D1500 		leaq	.LC0(%rip), %rdx
 158      000000
 159 0141 4889D6   		movq	%rdx, %rsi
 160 0144 4889C7   		movq	%rax, %rdi
 161 0147 E8000000 		call	errPrefix@PLT
 161      00
 162 014c 8B45EC   		movl	-20(%rbp), %eax
 163 014f 8945E4   		movl	%eax, -28(%rbp)
 164 0152 E93C0100 		jmp	.L7
 164      00
 165              	.L6:
  61:i2c.c         **** 		address += 1023;
 166              		.loc 1 61 11 is_stmt 1
 167 0157 668145C4 		addw	$1023, -60(%rbp)
 167      FF03
  62:i2c.c         **** 		length -= 1023;
 168              		.loc 1 62 10
 169 015d 66816DC0 		subw	$1023, -64(%rbp)
 169      FF03
 170              	.L5:
  58:i2c.c         **** 		iStatus = dumpChunk(destination, sourceData, sourceMask, address, 1023, error);
 171              		.loc 1 58 17
 172 0163 66817DC0 		cmpw	$1023, -64(%rbp)
 172      FF03
 173 0169 779D     		ja	.L8
  63:i2c.c         **** 	}
  64:i2c.c         **** 	bStatus = bufAppendWordBE(destination, length, error);
 174              		.loc 1 64 12
 175 016b 0FB74DC0 		movzwl	-64(%rbp), %ecx
 176 016f 488B55B8 		movq	-72(%rbp), %rdx
 177 0173 488B45D8 		movq	-40(%rbp), %rax
 178 0177 89CE     		movl	%ecx, %esi
 179 0179 4889C7   		movq	%rax, %rdi
 180 017c E8000000 		call	bufAppendWordBE@PLT
 180      00
 181 0181 8945E8   		movl	%eax, -24(%rbp)
  65:i2c.c         **** 	CHECK_STATUS(bStatus, "dumpChunk()", I2C_BUFFER_ERROR);
 182              		.loc 1 65 2
 183 0184 837DE800 		cmpl	$0, -24(%rbp)
 184 0188 7422     		je	.L9
 185              		.loc 1 65 2 is_stmt 0 discriminator 1
 186 018a 488B45B8 		movq	-72(%rbp), %rax
 187 018e 488D1500 		leaq	.LC0(%rip), %rdx
 187      000000
 188 0195 4889D6   		movq	%rdx, %rsi
 189 0198 4889C7   		movq	%rax, %rdi
 190 019b E8000000 		call	errPrefix@PLT
 190      00
 191 01a0 C745E401 		movl	$1, -28(%rbp)
 191      000000
 192 01a7 E9E70000 		jmp	.L7
 192      00
 193              	.L9:
  66:i2c.c         **** 	bStatus = bufAppendWordBE(destination, address, error);
 194              		.loc 1 66 12 is_stmt 1
 195 01ac 0FB74DC4 		movzwl	-60(%rbp), %ecx
 196 01b0 488B55B8 		movq	-72(%rbp), %rdx
 197 01b4 488B45D8 		movq	-40(%rbp), %rax
 198 01b8 89CE     		movl	%ecx, %esi
 199 01ba 4889C7   		movq	%rax, %rdi
 200 01bd E8000000 		call	bufAppendWordBE@PLT
 200      00
 201 01c2 8945E8   		movl	%eax, -24(%rbp)
  67:i2c.c         **** 	CHECK_STATUS(bStatus, "dumpChunk()", I2C_BUFFER_ERROR);
 202              		.loc 1 67 2
 203 01c5 837DE800 		cmpl	$0, -24(%rbp)
 204 01c9 7422     		je	.L10
 205              		.loc 1 67 2 is_stmt 0 discriminator 1
 206 01cb 488B45B8 		movq	-72(%rbp), %rax
 207 01cf 488D1500 		leaq	.LC0(%rip), %rdx
 207      000000
 208 01d6 4889D6   		movq	%rdx, %rsi
 209 01d9 4889C7   		movq	%rax, %rdi
 210 01dc E8000000 		call	errPrefix@PLT
 210      00
 211 01e1 C745E401 		movl	$1, -28(%rbp)
 211      000000
 212 01e8 E9A60000 		jmp	.L7
 212      00
 213              	.L10:
  68:i2c.c         **** 	startBlock = destination->length;
 214              		.loc 1 68 26 is_stmt 1
 215 01ed 488B45D8 		movq	-40(%rbp), %rax
 216 01f1 8B4008   		movl	8(%rax), %eax
 217              		.loc 1 68 13
 218 01f4 89C0     		movl	%eax, %eax
 219 01f6 488945F8 		movq	%rax, -8(%rbp)
  69:i2c.c         **** 	bStatus = bufAppendBlock(destination, sourceData->data + address, length, error);
 220              		.loc 1 69 12
 221 01fa 0FB755C0 		movzwl	-64(%rbp), %edx
 222              		.loc 1 69 50
 223 01fe 488B45D0 		movq	-48(%rbp), %rax
 224 0202 488B08   		movq	(%rax), %rcx
 225              		.loc 1 69 12
 226 0205 0FB745C4 		movzwl	-60(%rbp), %eax
 227 0209 488D3401 		leaq	(%rcx,%rax), %rsi
 228 020d 488B4DB8 		movq	-72(%rbp), %rcx
 229 0211 488B45D8 		movq	-40(%rbp), %rax
 230 0215 4889C7   		movq	%rax, %rdi
 231 0218 E8000000 		call	bufAppendBlock@PLT
 231      00
 232 021d 8945E8   		movl	%eax, -24(%rbp)
  70:i2c.c         **** 	CHECK_STATUS(bStatus, "dumpChunk()", I2C_BUFFER_ERROR);
 233              		.loc 1 70 2
 234 0220 837DE800 		cmpl	$0, -24(%rbp)
 235 0224 741F     		je	.L11
 236              		.loc 1 70 2 is_stmt 0 discriminator 1
 237 0226 488B45B8 		movq	-72(%rbp), %rax
 238 022a 488D1500 		leaq	.LC0(%rip), %rdx
 238      000000
 239 0231 4889D6   		movq	%rdx, %rsi
 240 0234 4889C7   		movq	%rax, %rdi
 241 0237 E8000000 		call	errPrefix@PLT
 241      00
 242 023c C745E401 		movl	$1, -28(%rbp)
 242      000000
 243 0243 EB4E     		jmp	.L7
 244              	.L11:
  71:i2c.c         **** 	for ( i = 0; i < length; i++ ) {
 245              		.loc 1 71 10 is_stmt 1
 246 0245 48C745F0 		movq	$0, -16(%rbp)
 246      00000000 
 247              		.loc 1 71 2
 248 024d EB39     		jmp	.L12
 249              	.L14:
  72:i2c.c         **** 		if ( sourceMask->data[address + i] == 0x00 ) {
 250              		.loc 1 72 18
 251 024f 488B45C8 		movq	-56(%rbp), %rax
 252 0253 488B00   		movq	(%rax), %rax
 253              		.loc 1 72 33
 254 0256 0FB74DC4 		movzwl	-60(%rbp), %ecx
 255 025a 488B55F0 		movq	-16(%rbp), %rdx
 256 025e 4801CA   		addq	%rcx, %rdx
 257              		.loc 1 72 24
 258 0261 4801D0   		addq	%rdx, %rax
 259 0264 0FB600   		movzbl	(%rax), %eax
 260              		.loc 1 72 6
 261 0267 84C0     		testb	%al, %al
 262 0269 7518     		jne	.L13
  73:i2c.c         **** 			destination->data[startBlock + i] = 0x00;
 263              		.loc 1 73 15
 264 026b 488B45D8 		movq	-40(%rbp), %rax
 265 026f 488B00   		movq	(%rax), %rax
 266              		.loc 1 73 33
 267 0272 488B4DF8 		movq	-8(%rbp), %rcx
 268 0276 488B55F0 		movq	-16(%rbp), %rdx
 269 027a 4801CA   		addq	%rcx, %rdx
 270              		.loc 1 73 21
 271 027d 4801D0   		addq	%rdx, %rax
 272              		.loc 1 73 38
 273 0280 C60000   		movb	$0, (%rax)
 274              	.L13:
  71:i2c.c         **** 	for ( i = 0; i < length; i++ ) {
 275              		.loc 1 71 28 discriminator 2
 276 0283 488345F0 		addq	$1, -16(%rbp)
 276      01
 277              	.L12:
  71:i2c.c         **** 	for ( i = 0; i < length; i++ ) {
 278              		.loc 1 71 17 discriminator 1
 279 0288 0FB745C0 		movzwl	-64(%rbp), %eax
 280 028c 483945F0 		cmpq	%rax, -16(%rbp)
 281 0290 72BD     		jb	.L14
  74:i2c.c         **** 		}
  75:i2c.c         **** 	}
  76:i2c.c         **** cleanup:
 282              		.loc 1 76 1
 283 0292 90       		nop
 284              	.L7:
  77:i2c.c         **** 	return returnCode;
 285              		.loc 1 77 9
 286 0293 8B45E4   		movl	-28(%rbp), %eax
 287              	.L4:
  78:i2c.c         **** }
 288              		.loc 1 78 1
 289 0296 C9       		leave
 290              		.cfi_def_cfa 7, 8
 291 0297 C3       		ret
 292              		.cfi_endproc
 293              	.LFE5:
 295              		.section	.rodata
 296 000c 00000000 		.align 8
 297              	.LC1:
 298 0010 69326357 		.string	"i2cWritePromRecords(): the buffer was not initialised"
 298      72697465 
 298      50726F6D 
 298      5265636F 
 298      72647328 
 299              		.text
 300              		.globl	i2cWritePromRecords
 302              	i2cWritePromRecords:
 303              	.LFB6:
  79:i2c.c         **** 
  80:i2c.c         **** // Build EEPROM records from the data/mask source buffers and write to the destination buffer.
  81:i2c.c         **** //
  82:i2c.c         **** DLLEXPORT(I2CStatus) i2cWritePromRecords(
  83:i2c.c         **** 	struct Buffer *destination, const struct Buffer *sourceData, const struct Buffer *sourceMask,
  84:i2c.c         **** 	const char **error)
  85:i2c.c         **** {
 304              		.loc 1 85 1
 305              		.cfi_startproc
 306 0298 F30F1EFA 		endbr64
 307 029c 55       		pushq	%rbp
 308              		.cfi_def_cfa_offset 16
 309              		.cfi_offset 6, -16
 310 029d 4889E5   		movq	%rsp, %rbp
 311              		.cfi_def_cfa_register 6
 312 02a0 4883EC30 		subq	$48, %rsp
 313 02a4 48897DE8 		movq	%rdi, -24(%rbp)
 314 02a8 488975E0 		movq	%rsi, -32(%rbp)
 315 02ac 488955D8 		movq	%rdx, -40(%rbp)
 316 02b0 48894DD0 		movq	%rcx, -48(%rbp)
  86:i2c.c         **** 	uint16 i, chunkStart;
  87:i2c.c         **** 	I2CStatus status;
  88:i2c.c         **** 	if ( destination->length != 8 || destination->data[0] != 0xC2 ) {
 317              		.loc 1 88 18
 318 02b4 488B45E8 		movq	-24(%rbp), %rax
 319 02b8 8B4008   		movl	8(%rax), %eax
 320              		.loc 1 88 5
 321 02bb 83F808   		cmpl	$8, %eax
 322 02be 750E     		jne	.L16
 323              		.loc 1 88 46 discriminator 1
 324 02c0 488B45E8 		movq	-24(%rbp), %rax
 325 02c4 488B00   		movq	(%rax), %rax
 326              		.loc 1 88 52 discriminator 1
 327 02c7 0FB600   		movzbl	(%rax), %eax
 328              		.loc 1 88 32 discriminator 1
 329 02ca 3CC2     		cmpb	$-62, %al
 330 02cc 7425     		je	.L17
 331              	.L16:
  89:i2c.c         **** 		errRender(error, "i2cWritePromRecords(): the buffer was not initialised");
 332              		.loc 1 89 3
 333 02ce 488B45D0 		movq	-48(%rbp), %rax
 334 02d2 488D1500 		leaq	.LC1(%rip), %rdx
 334      000000
 335 02d9 4889D6   		movq	%rdx, %rsi
 336 02dc 4889C7   		movq	%rax, %rdi
 337 02df B8000000 		movl	$0, %eax
 337      00
 338 02e4 E8000000 		call	errRender@PLT
 338      00
  90:i2c.c         **** 		return I2C_NOT_INITIALISED;
 339              		.loc 1 90 10
 340 02e9 B8020000 		movl	$2, %eax
 340      00
 341 02ee E95F0200 		jmp	.L18
 341      00
 342              	.L17:
  91:i2c.c         **** 	}
  92:i2c.c         **** 
  93:i2c.c         **** 	i = 0;
 343              		.loc 1 93 4
 344 02f3 66C745F8 		movw	$0, -8(%rbp)
 344      0000
  94:i2c.c         **** 	while ( !sourceMask->data[i] && i < sourceData->length ) {
 345              		.loc 1 94 8
 346 02f9 EB0B     		jmp	.L19
 347              	.L21:
  95:i2c.c         **** 		i++;
 348              		.loc 1 95 4
 349 02fb 0FB745F8 		movzwl	-8(%rbp), %eax
 350 02ff 83C001   		addl	$1, %eax
 351 0302 668945F8 		movw	%ax, -8(%rbp)
 352              	.L19:
  94:i2c.c         **** 	while ( !sourceMask->data[i] && i < sourceData->length ) {
 353              		.loc 1 94 21
 354 0306 488B45D8 		movq	-40(%rbp), %rax
 355 030a 488B10   		movq	(%rax), %rdx
  94:i2c.c         **** 	while ( !sourceMask->data[i] && i < sourceData->length ) {
 356              		.loc 1 94 27
 357 030d 0FB745F8 		movzwl	-8(%rbp), %eax
 358 0311 4801D0   		addq	%rdx, %rax
 359 0314 0FB600   		movzbl	(%rax), %eax
  94:i2c.c         **** 	while ( !sourceMask->data[i] && i < sourceData->length ) {
 360              		.loc 1 94 31
 361 0317 84C0     		testb	%al, %al
 362 0319 750F     		jne	.L20
  94:i2c.c         **** 	while ( !sourceMask->data[i] && i < sourceData->length ) {
 363              		.loc 1 94 36 discriminator 1
 364 031b 0FB755F8 		movzwl	-8(%rbp), %edx
  94:i2c.c         **** 	while ( !sourceMask->data[i] && i < sourceData->length ) {
 365              		.loc 1 94 48 discriminator 1
 366 031f 488B45E0 		movq	-32(%rbp), %rax
 367 0323 8B4008   		movl	8(%rax), %eax
  94:i2c.c         **** 	while ( !sourceMask->data[i] && i < sourceData->length ) {
 368              		.loc 1 94 31 discriminator 1
 369 0326 39C2     		cmpl	%eax, %edx
 370 0328 72D1     		jb	.L21
 371              	.L20:
  96:i2c.c         **** 	}
  97:i2c.c         **** 	if ( i == sourceData->length ) {
 372              		.loc 1 97 9
 373 032a 0FB755F8 		movzwl	-8(%rbp), %edx
 374              		.loc 1 97 22
 375 032e 488B45E0 		movq	-32(%rbp), %rax
 376 0332 8B4008   		movl	8(%rax), %eax
 377              		.loc 1 97 5
 378 0335 39C2     		cmpl	%eax, %edx
 379 0337 750A     		jne	.L22
  98:i2c.c         **** 		return I2C_SUCCESS;  // There are no data
 380              		.loc 1 98 10
 381 0339 B8000000 		movl	$0, %eax
 381      00
 382 033e E90F0200 		jmp	.L18
 382      00
 383              	.L22:
  99:i2c.c         **** 	}
 100:i2c.c         **** 
 101:i2c.c         **** 	// There is definitely some data to write
 102:i2c.c         **** 	//
 103:i2c.c         **** 	chunkStart = i;  // keep a record of where this block starts
 384              		.loc 1 103 13
 385 0343 0FB745F8 		movzwl	-8(%rbp), %eax
 386 0347 668945FA 		movw	%ax, -6(%rbp)
 104:i2c.c         **** 	do {
 105:i2c.c         **** 		// Find the end of this block of ones
 106:i2c.c         **** 		//
 107:i2c.c         **** 		while ( sourceMask->data[i] && i < sourceData->length ) {
 387              		.loc 1 107 9
 388 034b EB0B     		jmp	.L23
 389              	.L25:
 108:i2c.c         **** 			i++;
 390              		.loc 1 108 5
 391 034d 0FB745F8 		movzwl	-8(%rbp), %eax
 392 0351 83C001   		addl	$1, %eax
 393 0354 668945F8 		movw	%ax, -8(%rbp)
 394              	.L23:
 107:i2c.c         **** 			i++;
 395              		.loc 1 107 21
 396 0358 488B45D8 		movq	-40(%rbp), %rax
 397 035c 488B10   		movq	(%rax), %rdx
 107:i2c.c         **** 			i++;
 398              		.loc 1 107 27
 399 035f 0FB745F8 		movzwl	-8(%rbp), %eax
 400 0363 4801D0   		addq	%rdx, %rax
 401 0366 0FB600   		movzbl	(%rax), %eax
 107:i2c.c         **** 			i++;
 402              		.loc 1 107 31
 403 0369 84C0     		testb	%al, %al
 404 036b 740F     		je	.L24
 107:i2c.c         **** 			i++;
 405              		.loc 1 107 36 discriminator 1
 406 036d 0FB755F8 		movzwl	-8(%rbp), %edx
 107:i2c.c         **** 			i++;
 407              		.loc 1 107 48 discriminator 1
 408 0371 488B45E0 		movq	-32(%rbp), %rax
 409 0375 8B4008   		movl	8(%rax), %eax
 107:i2c.c         **** 			i++;
 410              		.loc 1 107 31 discriminator 1
 411 0378 39C2     		cmpl	%eax, %edx
 412 037a 72D1     		jb	.L25
 413              	.L24:
 109:i2c.c         **** 		}
 110:i2c.c         **** 		if ( i == sourceData->length ) {
 414              		.loc 1 110 10
 415 037c 0FB755F8 		movzwl	-8(%rbp), %edx
 416              		.loc 1 110 23
 417 0380 488B45E0 		movq	-32(%rbp), %rax
 418 0384 8B4008   		movl	8(%rax), %eax
 419              		.loc 1 110 6
 420 0387 39C2     		cmpl	%eax, %edx
 421 0389 7545     		jne	.L26
 111:i2c.c         **** 			status = dumpChunk(
 112:i2c.c         **** 				destination, sourceData, sourceMask, chunkStart,
 113:i2c.c         **** 				(uint16)sourceData->length - chunkStart, error);
 422              		.loc 1 113 23
 423 038b 488B45E0 		movq	-32(%rbp), %rax
 424 038f 8B4008   		movl	8(%rax), %eax
 425              		.loc 1 113 32
 426 0392 662B45FA 		subw	-6(%rbp), %ax
 111:i2c.c         **** 			status = dumpChunk(
 427              		.loc 1 111 13
 428 0396 0FB7F8   		movzwl	%ax, %edi
 429 0399 0FB74DFA 		movzwl	-6(%rbp), %ecx
 430 039d 4C8B45D0 		movq	-48(%rbp), %r8
 431 03a1 488B55D8 		movq	-40(%rbp), %rdx
 432 03a5 488B75E0 		movq	-32(%rbp), %rsi
 433 03a9 488B45E8 		movq	-24(%rbp), %rax
 434 03ad 4D89C1   		movq	%r8, %r9
 435 03b0 4189F8   		movl	%edi, %r8d
 436 03b3 4889C7   		movq	%rax, %rdi
 437 03b6 E80AFDFF 		call	dumpChunk
 437      FF
 438 03bb 8945FC   		movl	%eax, -4(%rbp)
 114:i2c.c         **** 			if ( status != I2C_SUCCESS ) {
 439              		.loc 1 114 7
 440 03be 837DFC00 		cmpl	$0, -4(%rbp)
 441 03c2 0F848101 		je	.L41
 441      0000
 115:i2c.c         **** 				return status;
 442              		.loc 1 115 12
 443 03c8 8B45FC   		movl	-4(%rbp), %eax
 444 03cb E9820100 		jmp	.L18
 444      00
 445              	.L26:
 116:i2c.c         **** 			}
 117:i2c.c         **** 			break;
 118:i2c.c         **** 		}
 119:i2c.c         **** 
 120:i2c.c         **** 		// Now check: is this run of zeroes worth splitting the block for?
 121:i2c.c         **** 		//
 122:i2c.c         **** 		// There are four bytes of overhead to opening a new record, so on balance it appears that
 123:i2c.c         **** 		// the smallest run of zeros worth breaking a block is FIVE. But since the maximum record
 124:i2c.c         **** 		// length is 1023 bytes, it's actually good to break on FOUR bytes - it costs nothing
 125:i2c.c         **** 		// extra, but it hopefully keeps the number of forced (1023-byte) breaks to a minimum.
 126:i2c.c         **** 		//
 127:i2c.c         **** 		if ( i < sourceData->length-4 ) {
 446              		.loc 1 127 10
 447 03d0 0FB755F8 		movzwl	-8(%rbp), %edx
 448              		.loc 1 127 22
 449 03d4 488B45E0 		movq	-32(%rbp), %rax
 450 03d8 8B4008   		movl	8(%rax), %eax
 451              		.loc 1 127 30
 452 03db 83E804   		subl	$4, %eax
 453              		.loc 1 127 6
 454 03de 39C2     		cmpl	%eax, %edx
 455 03e0 0F831001 		jnb	.L29
 455      0000
 128:i2c.c         **** 			// We are not within five bytes of the end
 129:i2c.c         **** 			//
 130:i2c.c         **** 			if ( !sourceMask->data[i] && !sourceMask->data[i+1] &&
 456              		.loc 1 130 20
 457 03e6 488B45D8 		movq	-40(%rbp), %rax
 458 03ea 488B10   		movq	(%rax), %rdx
 459              		.loc 1 130 26
 460 03ed 0FB745F8 		movzwl	-8(%rbp), %eax
 461 03f1 4801D0   		addq	%rdx, %rax
 462 03f4 0FB600   		movzbl	(%rax), %eax
 463              		.loc 1 130 7
 464 03f7 84C0     		testb	%al, %al
 465 03f9 0F85E000 		jne	.L36
 465      0000
 466              		.loc 1 130 44 discriminator 1
 467 03ff 488B45D8 		movq	-40(%rbp), %rax
 468 0403 488B00   		movq	(%rax), %rax
 469              		.loc 1 130 50 discriminator 1
 470 0406 0FB755F8 		movzwl	-8(%rbp), %edx
 471 040a 4883C201 		addq	$1, %rdx
 472 040e 4801D0   		addq	%rdx, %rax
 473 0411 0FB600   		movzbl	(%rax), %eax
 474              		.loc 1 130 30 discriminator 1
 475 0414 84C0     		testb	%al, %al
 476 0416 0F85C300 		jne	.L36
 476      0000
 131:i2c.c         **** 			     !sourceMask->data[i+2] && !sourceMask->data[i+3] )
 477              		.loc 1 131 20 discriminator 2
 478 041c 488B45D8 		movq	-40(%rbp), %rax
 479 0420 488B00   		movq	(%rax), %rax
 480              		.loc 1 131 26 discriminator 2
 481 0423 0FB755F8 		movzwl	-8(%rbp), %edx
 482 0427 4883C202 		addq	$2, %rdx
 483 042b 4801D0   		addq	%rdx, %rax
 484 042e 0FB600   		movzbl	(%rax), %eax
 130:i2c.c         **** 			     !sourceMask->data[i+2] && !sourceMask->data[i+3] )
 485              		.loc 1 130 56 discriminator 2
 486 0431 84C0     		testb	%al, %al
 487 0433 0F85A600 		jne	.L36
 487      0000
 488              		.loc 1 131 46
 489 0439 488B45D8 		movq	-40(%rbp), %rax
 490 043d 488B00   		movq	(%rax), %rax
 491              		.loc 1 131 52
 492 0440 0FB755F8 		movzwl	-8(%rbp), %edx
 493 0444 4883C203 		addq	$3, %rdx
 494 0448 4801D0   		addq	%rdx, %rax
 495 044b 0FB600   		movzbl	(%rax), %eax
 496              		.loc 1 131 32
 497 044e 84C0     		testb	%al, %al
 498 0450 0F858900 		jne	.L36
 498      0000
 132:i2c.c         **** 			{
 133:i2c.c         **** 				// Yes, let's split it - dump the current block and start a fresh one
 134:i2c.c         **** 				//
 135:i2c.c         **** 				status = dumpChunk(
 136:i2c.c         **** 					destination, sourceData, sourceMask, chunkStart, i - chunkStart, error);
 499              		.loc 1 136 57
 500 0456 0FB745F8 		movzwl	-8(%rbp), %eax
 501 045a 662B45FA 		subw	-6(%rbp), %ax
 135:i2c.c         **** 					destination, sourceData, sourceMask, chunkStart, i - chunkStart, error);
 502              		.loc 1 135 14
 503 045e 0FB7F8   		movzwl	%ax, %edi
 504 0461 0FB74DFA 		movzwl	-6(%rbp), %ecx
 505 0465 4C8B45D0 		movq	-48(%rbp), %r8
 506 0469 488B55D8 		movq	-40(%rbp), %rdx
 507 046d 488B75E0 		movq	-32(%rbp), %rsi
 508 0471 488B45E8 		movq	-24(%rbp), %rax
 509 0475 4D89C1   		movq	%r8, %r9
 510 0478 4189F8   		movl	%edi, %r8d
 511 047b 4889C7   		movq	%rax, %rdi
 512 047e E842FCFF 		call	dumpChunk
 512      FF
 513 0483 8945FC   		movl	%eax, -4(%rbp)
 137:i2c.c         **** 				if ( status != I2C_SUCCESS ) {
 514              		.loc 1 137 8
 515 0486 837DFC00 		cmpl	$0, -4(%rbp)
 516 048a 7408     		je	.L31
 138:i2c.c         **** 					return status;
 517              		.loc 1 138 13
 518 048c 8B45FC   		movl	-4(%rbp), %eax
 519 048f E9BE0000 		jmp	.L18
 519      00
 520              	.L31:
 139:i2c.c         **** 				}
 140:i2c.c         **** 				
 141:i2c.c         **** 				// Skip these four...we know they're zero
 142:i2c.c         **** 				//
 143:i2c.c         **** 				i += 4;
 521              		.loc 1 143 7
 522 0494 668345F8 		addw	$4, -8(%rbp)
 522      04
 144:i2c.c         **** 				
 145:i2c.c         **** 				// Find the next block of ones
 146:i2c.c         **** 				//
 147:i2c.c         **** 				while ( i < sourceMask->length && !sourceMask->data[i] ) {
 523              		.loc 1 147 11
 524 0499 EB0B     		jmp	.L32
 525              	.L34:
 148:i2c.c         **** 					i++;
 526              		.loc 1 148 7
 527 049b 0FB745F8 		movzwl	-8(%rbp), %eax
 528 049f 83C001   		addl	$1, %eax
 529 04a2 668945F8 		movw	%ax, -8(%rbp)
 530              	.L32:
 147:i2c.c         **** 					i++;
 531              		.loc 1 147 15
 532 04a6 0FB755F8 		movzwl	-8(%rbp), %edx
 147:i2c.c         **** 					i++;
 533              		.loc 1 147 27
 534 04aa 488B45D8 		movq	-40(%rbp), %rax
 535 04ae 8B4008   		movl	8(%rax), %eax
 147:i2c.c         **** 					i++;
 536              		.loc 1 147 36
 537 04b1 39C2     		cmpl	%eax, %edx
 538 04b3 7315     		jnb	.L33
 147:i2c.c         **** 					i++;
 539              		.loc 1 147 50 discriminator 1
 540 04b5 488B45D8 		movq	-40(%rbp), %rax
 541 04b9 488B10   		movq	(%rax), %rdx
 147:i2c.c         **** 					i++;
 542              		.loc 1 147 56 discriminator 1
 543 04bc 0FB745F8 		movzwl	-8(%rbp), %eax
 544 04c0 4801D0   		addq	%rdx, %rax
 545 04c3 0FB600   		movzbl	(%rax), %eax
 147:i2c.c         **** 					i++;
 546              		.loc 1 147 36 discriminator 1
 547 04c6 84C0     		testb	%al, %al
 548 04c8 74D1     		je	.L34
 549              	.L33:
 149:i2c.c         **** 				}
 150:i2c.c         **** 				chunkStart = i;
 550              		.loc 1 150 16
 551 04ca 0FB745F8 		movzwl	-8(%rbp), %eax
 552 04ce 668945FA 		movw	%ax, -6(%rbp)
 553 04d2 EB60     		jmp	.L38
 554              	.L37:
 151:i2c.c         **** 			} else {
 152:i2c.c         **** 				// This is four or fewer zeros - not worth splitting for so skip over them
 153:i2c.c         **** 				//
 154:i2c.c         **** 				while ( !sourceMask->data[i] ) {
 155:i2c.c         **** 					i++;
 555              		.loc 1 155 7
 556 04d4 0FB745F8 		movzwl	-8(%rbp), %eax
 557 04d8 83C001   		addl	$1, %eax
 558 04db 668945F8 		movw	%ax, -8(%rbp)
 559              	.L36:
 154:i2c.c         **** 					i++;
 560              		.loc 1 154 24
 561 04df 488B45D8 		movq	-40(%rbp), %rax
 562 04e3 488B10   		movq	(%rax), %rdx
 154:i2c.c         **** 					i++;
 563              		.loc 1 154 30
 564 04e6 0FB745F8 		movzwl	-8(%rbp), %eax
 565 04ea 4801D0   		addq	%rdx, %rax
 566 04ed 0FB600   		movzbl	(%rax), %eax
 154:i2c.c         **** 					i++;
 567              		.loc 1 154 13
 568 04f0 84C0     		testb	%al, %al
 569 04f2 74E0     		je	.L37
 570 04f4 EB3E     		jmp	.L38
 571              	.L29:
 156:i2c.c         **** 				}
 157:i2c.c         **** 			}
 158:i2c.c         **** 		} else {
 159:i2c.c         **** 			// We are within four bytes of the end - include the remainder, whatever it is
 160:i2c.c         **** 			//
 161:i2c.c         **** 			status = dumpChunk(
 162:i2c.c         **** 				destination, sourceData, sourceMask, chunkStart,
 163:i2c.c         **** 				(uint16)sourceMask->length - chunkStart, error);
 572              		.loc 1 163 23
 573 04f6 488B45D8 		movq	-40(%rbp), %rax
 574 04fa 8B4008   		movl	8(%rax), %eax
 575              		.loc 1 163 32
 576 04fd 662B45FA 		subw	-6(%rbp), %ax
 161:i2c.c         **** 				destination, sourceData, sourceMask, chunkStart,
 577              		.loc 1 161 13
 578 0501 0FB7F8   		movzwl	%ax, %edi
 579 0504 0FB74DFA 		movzwl	-6(%rbp), %ecx
 580 0508 4C8B45D0 		movq	-48(%rbp), %r8
 581 050c 488B55D8 		movq	-40(%rbp), %rdx
 582 0510 488B75E0 		movq	-32(%rbp), %rsi
 583 0514 488B45E8 		movq	-24(%rbp), %rax
 584 0518 4D89C1   		movq	%r8, %r9
 585 051b 4189F8   		movl	%edi, %r8d
 586 051e 4889C7   		movq	%rax, %rdi
 587 0521 E89FFBFF 		call	dumpChunk
 587      FF
 588 0526 8945FC   		movl	%eax, -4(%rbp)
 164:i2c.c         **** 			if ( status != I2C_SUCCESS ) {
 589              		.loc 1 164 7
 590 0529 837DFC00 		cmpl	$0, -4(%rbp)
 591 052d 741D     		je	.L42
 165:i2c.c         **** 				return status;
 592              		.loc 1 165 12
 593 052f 8B45FC   		movl	-4(%rbp), %eax
 594 0532 EB1E     		jmp	.L18
 595              	.L38:
 166:i2c.c         **** 			}
 167:i2c.c         **** 			break;
 168:i2c.c         **** 		}
 169:i2c.c         **** 	} while ( i < sourceData->length );
 596              		.loc 1 169 14
 597 0534 0FB755F8 		movzwl	-8(%rbp), %edx
 598              		.loc 1 169 26
 599 0538 488B45E0 		movq	-32(%rbp), %rax
 600 053c 8B4008   		movl	8(%rax), %eax
 601              		.loc 1 169 14
 602 053f 39C2     		cmpl	%eax, %edx
 603 0541 0F8211FE 		jb	.L23
 603      FFFF
 604 0547 EB04     		jmp	.L28
 605              	.L41:
 117:i2c.c         **** 		}
 606              		.loc 1 117 4
 607 0549 90       		nop
 608 054a EB01     		jmp	.L28
 609              	.L42:
 167:i2c.c         **** 		}
 610              		.loc 1 167 4
 611 054c 90       		nop
 612              	.L28:
 170:i2c.c         **** 	
 171:i2c.c         **** 	return I2C_SUCCESS;
 613              		.loc 1 171 9
 614 054d B8000000 		movl	$0, %eax
 614      00
 615              	.L18:
 172:i2c.c         **** }
 616              		.loc 1 172 1
 617 0552 C9       		leave
 618              		.cfi_def_cfa 7, 8
 619 0553 C3       		ret
 620              		.cfi_endproc
 621              	.LFE6:
 623              		.section	.rodata
 624 0046 0000     		.align 8
 625              	.LC2:
 626 0048 69326352 		.string	"i2cReadPromRecords(): the EEPROM records appear to be corrupt"
 626      65616450 
 626      726F6D52 
 626      65636F72 
 626      64732829 
 627 0086 0000     		.align 8
 628              	.LC3:
 629 0088 69326352 		.string	"i2cReadPromRecords(): the destination buffer is not empty"
 629      65616450 
 629      726F6D52 
 629      65636F72 
 629      64732829 
 630              	.LC4:
 631 00c2 69326352 		.string	"i2cReadPromRecords()"
 631      65616450 
 631      726F6D52 
 631      65636F72 
 631      64732829 
 632              		.text
 633              		.globl	i2cReadPromRecords
 635              	i2cReadPromRecords:
 636              	.LFB7:
 173:i2c.c         **** 
 174:i2c.c         **** // Read EEPROM records from the source buffer and write the decoded data to the data/mask
 175:i2c.c         **** // destination buffers.
 176:i2c.c         **** //
 177:i2c.c         **** DLLEXPORT(I2CStatus) i2cReadPromRecords(
 178:i2c.c         **** 	struct Buffer *destData, struct Buffer *destMask, const struct Buffer *source,
 179:i2c.c         **** 	const char **error)
 180:i2c.c         **** {
 637              		.loc 1 180 1
 638              		.cfi_startproc
 639 0554 F30F1EFA 		endbr64
 640 0558 55       		pushq	%rbp
 641              		.cfi_def_cfa_offset 16
 642              		.cfi_offset 6, -16
 643 0559 4889E5   		movq	%rsp, %rbp
 644              		.cfi_def_cfa_register 6
 645 055c 4883EC40 		subq	$64, %rsp
 646 0560 48897DD8 		movq	%rdi, -40(%rbp)
 647 0564 488975D0 		movq	%rsi, -48(%rbp)
 648 0568 488955C8 		movq	%rdx, -56(%rbp)
 649 056c 48894DC0 		movq	%rcx, -64(%rbp)
 181:i2c.c         **** 	I2CStatus returnCode = I2C_SUCCESS;
 650              		.loc 1 181 12
 651 0570 C745E800 		movl	$0, -24(%rbp)
 651      000000
 182:i2c.c         **** 	uint16 chunkAddress, chunkLength;
 183:i2c.c         **** 	const uint8 *ptr = source->data;
 652              		.loc 1 183 15
 653 0577 488B45C8 		movq	-56(%rbp), %rax
 654 057b 488B00   		movq	(%rax), %rax
 655 057e 488945F0 		movq	%rax, -16(%rbp)
 184:i2c.c         **** 	const uint8 *const ptrEnd = ptr + source->length;
 656              		.loc 1 184 42
 657 0582 488B45C8 		movq	-56(%rbp), %rax
 658 0586 8B4008   		movl	8(%rax), %eax
 659 0589 89C2     		movl	%eax, %edx
 660              		.loc 1 184 21
 661 058b 488B45F0 		movq	-16(%rbp), %rax
 662 058f 4801D0   		addq	%rdx, %rax
 663 0592 488945F8 		movq	%rax, -8(%rbp)
 185:i2c.c         **** 	BufferStatus bStatus;
 186:i2c.c         **** 	if ( source->length < 8+5 || ptr[0] != 0xC2 ) {
 664              		.loc 1 186 13
 665 0596 488B45C8 		movq	-56(%rbp), %rax
 666 059a 8B4008   		movl	8(%rax), %eax
 667              		.loc 1 186 5
 668 059d 83F80C   		cmpl	$12, %eax
 669 05a0 760B     		jbe	.L44
 670              		.loc 1 186 34 discriminator 1
 671 05a2 488B45F0 		movq	-16(%rbp), %rax
 672 05a6 0FB600   		movzbl	(%rax), %eax
 673              		.loc 1 186 28 discriminator 1
 674 05a9 3CC2     		cmpb	$-62, %al
 675 05ab 7427     		je	.L45
 676              	.L44:
 187:i2c.c         **** 		errRender(error, "i2cReadPromRecords(): the EEPROM records appear to be corrupt");
 677              		.loc 1 187 3
 678 05ad 488B45C0 		movq	-64(%rbp), %rax
 679 05b1 488D1500 		leaq	.LC2(%rip), %rdx
 679      000000
 680 05b8 4889D6   		movq	%rdx, %rsi
 681 05bb 4889C7   		movq	%rax, %rdi
 682 05be B8000000 		movl	$0, %eax
 682      00
 683 05c3 E8000000 		call	errRender@PLT
 683      00
 188:i2c.c         **** 		FAIL(I2C_NOT_INITIALISED);
 684              		.loc 1 188 3
 685 05c8 C745E802 		movl	$2, -24(%rbp)
 685      000000
 686 05cf E9530100 		jmp	.L46
 686      00
 687              	.L45:
 189:i2c.c         **** 	}
 190:i2c.c         **** 	if ( destData->length != 0 || destMask->length != 0 ) {
 688              		.loc 1 190 15
 689 05d4 488B45D8 		movq	-40(%rbp), %rax
 690 05d8 8B4008   		movl	8(%rax), %eax
 691              		.loc 1 190 5
 692 05db 85C0     		testl	%eax, %eax
 693 05dd 750B     		jne	.L47
 694              		.loc 1 190 40 discriminator 1
 695 05df 488B45D0 		movq	-48(%rbp), %rax
 696 05e3 8B4008   		movl	8(%rax), %eax
 697              		.loc 1 190 29 discriminator 1
 698 05e6 85C0     		testl	%eax, %eax
 699 05e8 7427     		je	.L48
 700              	.L47:
 191:i2c.c         **** 		errRender(error, "i2cReadPromRecords(): the destination buffer is not empty");
 701              		.loc 1 191 3
 702 05ea 488B45C0 		movq	-64(%rbp), %rax
 703 05ee 488D1500 		leaq	.LC3(%rip), %rdx
 703      000000
 704 05f5 4889D6   		movq	%rdx, %rsi
 705 05f8 4889C7   		movq	%rax, %rdi
 706 05fb B8000000 		movl	$0, %eax
 706      00
 707 0600 E8000000 		call	errRender@PLT
 707      00
 192:i2c.c         **** 		FAIL(I2C_DEST_BUFFER_NOT_EMPTY);
 708              		.loc 1 192 3
 709 0605 C745E803 		movl	$3, -24(%rbp)
 709      000000
 710 060c E9160100 		jmp	.L46
 710      00
 711              	.L48:
 193:i2c.c         **** 	}
 194:i2c.c         **** 	ptr += 8;  // skip over the header
 712              		.loc 1 194 6
 713 0611 488345F0 		addq	$8, -16(%rbp)
 713      08
 195:i2c.c         **** 	while ( ptr < ptrEnd ) {
 714              		.loc 1 195 8
 715 0616 E9FB0000 		jmp	.L49
 715      00
 716              	.L53:
 196:i2c.c         **** 		chunkLength = ((ptr[0] << 8) + ptr[1]);
 717              		.loc 1 196 22
 718 061b 488B45F0 		movq	-16(%rbp), %rax
 719 061f 0FB600   		movzbl	(%rax), %eax
 720 0622 0FB6C0   		movzbl	%al, %eax
 721              		.loc 1 196 26
 722 0625 C1E008   		sall	$8, %eax
 723 0628 89C2     		movl	%eax, %edx
 724              		.loc 1 196 37
 725 062a 488B45F0 		movq	-16(%rbp), %rax
 726 062e 4883C001 		addq	$1, %rax
 727 0632 0FB600   		movzbl	(%rax), %eax
 728 0635 0FB6C0   		movzbl	%al, %eax
 729              		.loc 1 196 15
 730 0638 01D0     		addl	%edx, %eax
 731 063a 668945E4 		movw	%ax, -28(%rbp)
 197:i2c.c         **** 		chunkAddress = (ptr[2] << 8) + ptr[3];
 732              		.loc 1 197 22
 733 063e 488B45F0 		movq	-16(%rbp), %rax
 734 0642 4883C002 		addq	$2, %rax
 735 0646 0FB600   		movzbl	(%rax), %eax
 736 0649 0FB6C0   		movzbl	%al, %eax
 737              		.loc 1 197 26
 738 064c C1E008   		sall	$8, %eax
 739 064f 89C2     		movl	%eax, %edx
 740              		.loc 1 197 37
 741 0651 488B45F0 		movq	-16(%rbp), %rax
 742 0655 4883C003 		addq	$3, %rax
 743 0659 0FB600   		movzbl	(%rax), %eax
 744 065c 0FB6C0   		movzbl	%al, %eax
 745              		.loc 1 197 16
 746 065f 01D0     		addl	%edx, %eax
 747 0661 668945E6 		movw	%ax, -26(%rbp)
 198:i2c.c         **** 		if ( chunkLength & 0x8000 ) {
 748              		.loc 1 198 8
 749 0665 0FB745E4 		movzwl	-28(%rbp), %eax
 750              		.loc 1 198 6
 751 0669 6685C0   		testw	%ax, %ax
 752 066c 0F88B400 		js	.L55
 752      0000
 199:i2c.c         **** 			break;
 200:i2c.c         **** 		}
 201:i2c.c         **** 		chunkLength &= 0x03FF;
 753              		.loc 1 201 15
 754 0672 668165E4 		andw	$1023, -28(%rbp)
 754      FF03
 202:i2c.c         **** 		ptr += 4;
 755              		.loc 1 202 7
 756 0678 488345F0 		addq	$4, -16(%rbp)
 756      04
 203:i2c.c         **** 		bStatus = bufWriteBlock(destData, chunkAddress, ptr, chunkLength, error);
 757              		.loc 1 203 13
 758 067d 0FB74DE4 		movzwl	-28(%rbp), %ecx
 759 0681 0FB775E6 		movzwl	-26(%rbp), %esi
 760 0685 488B7DC0 		movq	-64(%rbp), %rdi
 761 0689 488B55F0 		movq	-16(%rbp), %rdx
 762 068d 488B45D8 		movq	-40(%rbp), %rax
 763 0691 4989F8   		movq	%rdi, %r8
 764 0694 4889C7   		movq	%rax, %rdi
 765 0697 E8000000 		call	bufWriteBlock@PLT
 765      00
 766 069c 8945EC   		movl	%eax, -20(%rbp)
 204:i2c.c         **** 		CHECK_STATUS(bStatus, "i2cReadPromRecords()", I2C_BUFFER_ERROR);
 767              		.loc 1 204 3
 768 069f 837DEC00 		cmpl	$0, -20(%rbp)
 769 06a3 741F     		je	.L51
 770              		.loc 1 204 3 is_stmt 0 discriminator 1
 771 06a5 488B45C0 		movq	-64(%rbp), %rax
 772 06a9 488D1500 		leaq	.LC4(%rip), %rdx
 772      000000
 773 06b0 4889D6   		movq	%rdx, %rsi
 774 06b3 4889C7   		movq	%rax, %rdi
 775 06b6 E8000000 		call	errPrefix@PLT
 775      00
 776 06bb C745E801 		movl	$1, -24(%rbp)
 776      000000
 777 06c2 EB63     		jmp	.L46
 778              	.L51:
 205:i2c.c         **** 		bStatus = bufWriteConst(destMask, chunkAddress, 0x01, chunkLength, error);
 779              		.loc 1 205 13 is_stmt 1
 780 06c4 0FB755E4 		movzwl	-28(%rbp), %edx
 781 06c8 0FB775E6 		movzwl	-26(%rbp), %esi
 782 06cc 488B4DC0 		movq	-64(%rbp), %rcx
 783 06d0 488B45D0 		movq	-48(%rbp), %rax
 784 06d4 4989C8   		movq	%rcx, %r8
 785 06d7 89D1     		movl	%edx, %ecx
 786 06d9 BA010000 		movl	$1, %edx
 786      00
 787 06de 4889C7   		movq	%rax, %rdi
 788 06e1 E8000000 		call	bufWriteConst@PLT
 788      00
 789 06e6 8945EC   		movl	%eax, -20(%rbp)
 206:i2c.c         **** 		CHECK_STATUS(bStatus, "i2cReadPromRecords()", I2C_BUFFER_ERROR);
 790              		.loc 1 206 3
 791 06e9 837DEC00 		cmpl	$0, -20(%rbp)
 792 06ed 741F     		je	.L52
 793              		.loc 1 206 3 is_stmt 0 discriminator 1
 794 06ef 488B45C0 		movq	-64(%rbp), %rax
 795 06f3 488D1500 		leaq	.LC4(%rip), %rdx
 795      000000
 796 06fa 4889D6   		movq	%rdx, %rsi
 797 06fd 4889C7   		movq	%rax, %rdi
 798 0700 E8000000 		call	errPrefix@PLT
 798      00
 799 0705 C745E801 		movl	$1, -24(%rbp)
 799      000000
 800 070c EB19     		jmp	.L46
 801              	.L52:
 207:i2c.c         **** 		ptr += chunkLength;
 802              		.loc 1 207 7 is_stmt 1
 803 070e 0FB745E4 		movzwl	-28(%rbp), %eax
 804 0712 480145F0 		addq	%rax, -16(%rbp)
 805              	.L49:
 195:i2c.c         **** 		chunkLength = ((ptr[0] << 8) + ptr[1]);
 806              		.loc 1 195 14
 807 0716 488B45F0 		movq	-16(%rbp), %rax
 808 071a 483B45F8 		cmpq	-8(%rbp), %rax
 809 071e 0F82F7FE 		jb	.L53
 809      FFFF
 208:i2c.c         **** 	}
 209:i2c.c         **** cleanup:
 810              		.loc 1 209 1
 811 0724 EB01     		jmp	.L46
 812              	.L55:
 199:i2c.c         **** 		}
 813              		.loc 1 199 4
 814 0726 90       		nop
 815              	.L46:
 210:i2c.c         **** 	return returnCode;
 816              		.loc 1 210 9
 817 0727 8B45E8   		movl	-24(%rbp), %eax
 211:i2c.c         **** }
 818              		.loc 1 211 1
 819 072a C9       		leave
 820              		.cfi_def_cfa 7, 8
 821 072b C3       		ret
 822              		.cfi_endproc
 823              	.LFE7:
 825              		.section	.rodata
 826 00d7 00       		.align 8
 827              	.LC5:
 828 00d8 69326346 		.string	"i2cFinalise(): the buffer was not initialised"
 828      696E616C 
 828      69736528 
 828      293A2074 
 828      68652062 
 829              	.LC6:
 830 0106 69326346 		.string	"i2cFinalise()"
 830      696E616C 
 830      69736528 
 830      2900
 831              		.text
 832              		.globl	i2cFinalise
 834              	i2cFinalise:
 835              	.LFB8:
 212:i2c.c         **** 
 213:i2c.c         **** // Finalise the I2C buffers. This involves writing the final record which resets the chip.
 214:i2c.c         **** //
 215:i2c.c         **** DLLEXPORT(I2CStatus) i2cFinalise(struct Buffer *buf, const char **error) {
 836              		.loc 1 215 74
 837              		.cfi_startproc
 838 072c F30F1EFA 		endbr64
 839 0730 55       		pushq	%rbp
 840              		.cfi_def_cfa_offset 16
 841              		.cfi_offset 6, -16
 842 0731 4889E5   		movq	%rsp, %rbp
 843              		.cfi_def_cfa_register 6
 844 0734 4883EC30 		subq	$48, %rsp
 845 0738 48897DD8 		movq	%rdi, -40(%rbp)
 846 073c 488975D0 		movq	%rsi, -48(%rbp)
 847              		.loc 1 215 74
 848 0740 64488B04 		movq	%fs:40, %rax
 848      25280000 
 848      00
 849 0749 488945F8 		movq	%rax, -8(%rbp)
 850 074d 31C0     		xorl	%eax, %eax
 216:i2c.c         **** 	I2CStatus returnCode = I2C_SUCCESS;
 851              		.loc 1 216 12
 852 074f C745E800 		movl	$0, -24(%rbp)
 852      000000
 217:i2c.c         **** 	BufferStatus bStatus;
 218:i2c.c         **** 	const uint8 lastRecord[] = {0x80, 0x01, 0xe6, 0x00, 0x00};
 853              		.loc 1 218 14
 854 0756 C745F380 		movl	$15073664, -13(%rbp)
 854      01E600
 855 075d C645F700 		movb	$0, -9(%rbp)
 219:i2c.c         **** 	if ( buf->length < 8 || buf->data[0] != 0xC2 ) {
 856              		.loc 1 219 10
 857 0761 488B45D8 		movq	-40(%rbp), %rax
 858 0765 8B4008   		movl	8(%rax), %eax
 859              		.loc 1 219 5
 860 0768 83F807   		cmpl	$7, %eax
 861 076b 760E     		jbe	.L57
 862              		.loc 1 219 29 discriminator 1
 863 076d 488B45D8 		movq	-40(%rbp), %rax
 864 0771 488B00   		movq	(%rax), %rax
 865              		.loc 1 219 35 discriminator 1
 866 0774 0FB600   		movzbl	(%rax), %eax
 867              		.loc 1 219 23 discriminator 1
 868 0777 3CC2     		cmpb	$-62, %al
 869 0779 7424     		je	.L58
 870              	.L57:
 220:i2c.c         **** 		errRender(error, "i2cFinalise(): the buffer was not initialised");
 871              		.loc 1 220 3
 872 077b 488B45D0 		movq	-48(%rbp), %rax
 873 077f 488D1500 		leaq	.LC5(%rip), %rdx
 873      000000
 874 0786 4889D6   		movq	%rdx, %rsi
 875 0789 4889C7   		movq	%rax, %rdi
 876 078c B8000000 		movl	$0, %eax
 876      00
 877 0791 E8000000 		call	errRender@PLT
 877      00
 221:i2c.c         **** 		FAIL(I2C_NOT_INITIALISED);
 878              		.loc 1 221 3
 879 0796 C745E802 		movl	$2, -24(%rbp)
 879      000000
 880 079d EB45     		jmp	.L59
 881              	.L58:
 222:i2c.c         **** 	}
 223:i2c.c         **** 	bStatus = bufAppendBlock(buf, lastRecord, 5, error);
 882              		.loc 1 223 12
 883 079f 488B55D0 		movq	-48(%rbp), %rdx
 884 07a3 488D75F3 		leaq	-13(%rbp), %rsi
 885 07a7 488B45D8 		movq	-40(%rbp), %rax
 886 07ab 4889D1   		movq	%rdx, %rcx
 887 07ae BA050000 		movl	$5, %edx
 887      00
 888 07b3 4889C7   		movq	%rax, %rdi
 889 07b6 E8000000 		call	bufAppendBlock@PLT
 889      00
 890 07bb 8945EC   		movl	%eax, -20(%rbp)
 224:i2c.c         **** 	CHECK_STATUS(bStatus, "i2cFinalise()", I2C_BUFFER_ERROR);
 891              		.loc 1 224 2
 892 07be 837DEC00 		cmpl	$0, -20(%rbp)
 893 07c2 741F     		je	.L62
 894              		.loc 1 224 2 is_stmt 0 discriminator 1
 895 07c4 488B45D0 		movq	-48(%rbp), %rax
 896 07c8 488D1500 		leaq	.LC6(%rip), %rdx
 896      000000
 897 07cf 4889D6   		movq	%rdx, %rsi
 898 07d2 4889C7   		movq	%rax, %rdi
 899 07d5 E8000000 		call	errPrefix@PLT
 899      00
 900 07da C745E801 		movl	$1, -24(%rbp)
 900      000000
 901 07e1 EB01     		jmp	.L59
 902              	.L62:
 225:i2c.c         **** cleanup:
 903              		.loc 1 225 1 is_stmt 1
 904 07e3 90       		nop
 905              	.L59:
 226:i2c.c         **** 	return returnCode;
 906              		.loc 1 226 9
 907 07e4 8B45E8   		movl	-24(%rbp), %eax
 227:i2c.c         **** }
 908              		.loc 1 227 1
 909 07e7 488B55F8 		movq	-8(%rbp), %rdx
 910 07eb 64482B14 		subq	%fs:40, %rdx
 910      25280000 
 910      00
 911 07f4 7405     		je	.L61
 912 07f6 E8000000 		call	__stack_chk_fail@PLT
 912      00
 913              	.L61:
 914 07fb C9       		leave
 915              		.cfi_def_cfa 7, 8
 916 07fc C3       		ret
 917              		.cfi_endproc
 918              	.LFE8:
 920              	.Letext0:
 921              		.file 2 "/usr/lib/gcc/x86_64-linux-gnu/12/include/stddef.h"
 922              		.file 3 "/home/asoreyh/Dropbox/projects/lago/acqua/nexys/src/makestuff/common/makestuff.h"
 923              		.file 4 "/home/asoreyh/Dropbox/projects/lago/acqua/nexys/src/makestuff/libs/libbuffer/libbuffer.h"
 924              		.file 5 "libfx2loader.h"
 925              		.file 6 "/home/asoreyh/Dropbox/projects/lago/acqua/nexys/src/makestuff/libs/liberror/liberror.h"
 2198              		.section	.note.gnu.property,"a"
 2199              		.align 8
 2200 0000 04000000 		.long	1f - 0f
 2201 0004 10000000 		.long	4f - 1f
 2202 0008 05000000 		.long	5
 2203              	0:
 2204 000c 474E5500 		.string	"GNU"
 2205              	1:
 2206              		.align 8
 2207 0010 020000C0 		.long	0xc0000002
 2208 0014 04000000 		.long	3f - 2f
 2209              	2:
 2210 0018 03000000 		.long	0x3
 2211              	3:
 2212 001c 00000000 		.align 8
 2213              	4:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 i2c.c
     /tmp/ccxP6nrY.s:7      .text:0000000000000000 i2cInitialise
     /tmp/ccxP6nrY.s:113    .text:00000000000000c5 dumpChunk
     /tmp/ccxP6nrY.s:302    .text:0000000000000298 i2cWritePromRecords
     /tmp/ccxP6nrY.s:635    .text:0000000000000554 i2cReadPromRecords
     /tmp/ccxP6nrY.s:834    .text:000000000000072c i2cFinalise

UNDEFINED SYMBOLS
errPrefix
bufAppendWordBE
bufAppendBlock
errRender
bufWriteBlock
bufWriteConst
__stack_chk_fail
