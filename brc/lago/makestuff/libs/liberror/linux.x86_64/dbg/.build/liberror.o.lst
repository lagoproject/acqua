   1              		.file	"liberror.c"
   2              		.text
   3              	.Ltext0:
   4              		.globl	errRender
   6              	errRender:
   7              	.LFB4:
   8              		.file 1 "liberror.c"
   1:liberror.c    **** /*
   2:liberror.c    ****  * Copyright (C) 2009-2012 Chris McClelland
   3:liberror.c    ****  *
   4:liberror.c    ****  * This program is free software: you can redistribute it and/or modify
   5:liberror.c    ****  * it under the terms of the GNU Lesser General Public License as published by
   6:liberror.c    ****  * the Free Software Foundation, either version 3 of the License, or
   7:liberror.c    ****  * (at your option) any later version.
   8:liberror.c    ****  *
   9:liberror.c    ****  * This program is distributed in the hope that it will be useful,
  10:liberror.c    ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:liberror.c    ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:liberror.c    ****  * GNU Lesser General Public License for more details.
  13:liberror.c    ****  *
  14:liberror.c    ****  * You should have received a copy of the GNU Lesser General Public License
  15:liberror.c    ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:liberror.c    ****  */
  17:liberror.c    **** #ifdef WIN32
  18:liberror.c    **** 	#define strerror_r(err, buf, size) strerror_s(buf, size, err)
  19:liberror.c    **** #else
  20:liberror.c    **** 	#undef _GNU_SOURCE
  21:liberror.c    **** 	#define _XOPEN_SOURCE 600
  22:liberror.c    **** #endif
  23:liberror.c    **** #include <stdio.h>
  24:liberror.c    **** #include <stdlib.h>
  25:liberror.c    **** #include <stdarg.h>
  26:liberror.c    **** #include <string.h>
  27:liberror.c    **** #include <errno.h>
  28:liberror.c    **** #include "liberror.h"
  29:liberror.c    **** 
  30:liberror.c    **** // Code inspired by http://linux.die.net/man/3/snprintf
  31:liberror.c    **** //
  32:liberror.c    **** DLLEXPORT(void) errRender(const char **error, const char *format, ...) {
   9              		.loc 1 32 0
  10              		.cfi_startproc
  11 0000 55       		pushq	%rbp
  12              		.cfi_def_cfa_offset 16
  13              		.cfi_offset 6, -16
  14 0001 4889E5   		movq	%rsp, %rbp
  15              		.cfi_def_cfa_register 6
  16 0004 4881EC00 		subq	$256, %rsp
  16      010000
  17 000b 4889BD08 		movq	%rdi, -248(%rbp)
  17      FFFFFF
  18 0012 48899560 		movq	%rdx, -160(%rbp)
  18      FFFFFF
  19 0019 48898D68 		movq	%rcx, -152(%rbp)
  19      FFFFFF
  20 0020 4C898570 		movq	%r8, -144(%rbp)
  20      FFFFFF
  21 0027 4C898D78 		movq	%r9, -136(%rbp)
  21      FFFFFF
  22 002e 84C0     		testb	%al, %al
  23 0030 7420     		je	.L2
  24 0032 0F294580 		movaps	%xmm0, -128(%rbp)
  25 0036 0F294D90 		movaps	%xmm1, -112(%rbp)
  26 003a 0F2955A0 		movaps	%xmm2, -96(%rbp)
  27 003e 0F295DB0 		movaps	%xmm3, -80(%rbp)
  28 0042 0F2965C0 		movaps	%xmm4, -64(%rbp)
  29 0046 0F296DD0 		movaps	%xmm5, -48(%rbp)
  30 004a 0F2975E0 		movaps	%xmm6, -32(%rbp)
  31 004e 0F297DF0 		movaps	%xmm7, -16(%rbp)
  32              	.L2:
  33 0052 4889B500 		movq	%rsi, -256(%rbp)
  33      FFFFFF
  34              		.loc 1 32 0
  35 0059 64488B04 		movq	%fs:40, %rax
  35      25280000 
  35      00
  36 0062 48898548 		movq	%rax, -184(%rbp)
  36      FFFFFF
  37 0069 31C0     		xorl	%eax, %eax
  33:liberror.c    **** 	if ( error ) {
  38              		.loc 1 33 0
  39 006b 4883BD08 		cmpq	$0, -248(%rbp)
  39      FFFFFF00 
  40 0073 0F843F01 		je	.L1
  40      0000
  41              	.LBB2:
  34:liberror.c    **** 		// Guess we need no more than 512 bytes
  35:liberror.c    **** 		int returnCode, size = 512;
  42              		.loc 1 35 0
  43 0079 C78518FF 		movl	$512, -232(%rbp)
  43      FFFF0002 
  43      0000
  36:liberror.c    **** 		char *bufPtr, *newBufPtr;
  37:liberror.c    **** 		va_list argList;
  38:liberror.c    **** 		bufPtr = (char*)malloc(size);
  44              		.loc 1 38 0
  45 0083 8B8518FF 		movl	-232(%rbp), %eax
  45      FFFF
  46 0089 4898     		cltq
  47 008b 4889C7   		movq	%rax, %rdi
  48 008e E8000000 		call	malloc@PLT
  48      00
  49 0093 48898520 		movq	%rax, -224(%rbp)
  49      FFFFFF
  39:liberror.c    **** 		if ( bufPtr == NULL ) {
  50              		.loc 1 39 0
  51 009a 4883BD20 		cmpq	$0, -224(%rbp)
  51      FFFFFF00 
  52 00a2 7513     		jne	.L4
  40:liberror.c    **** 			// Insufficient memory
  41:liberror.c    **** 			*error = NULL;
  53              		.loc 1 41 0
  54 00a4 488B8508 		movq	-248(%rbp), %rax
  54      FFFFFF
  55 00ab 48C70000 		movq	$0, (%rax)
  55      000000
  42:liberror.c    **** 			return;
  56              		.loc 1 42 0
  57 00b2 E9010100 		jmp	.L1
  57      00
  58              	.L4:
  43:liberror.c    **** 		}
  44:liberror.c    **** 		for ( ; ; ) {
  45:liberror.c    **** 			// Try to print in the allocated space
  46:liberror.c    **** 			va_start(argList, format);
  59              		.loc 1 46 0
  60 00b7 C78530FF 		movl	$16, -208(%rbp)
  60      FFFF1000 
  60      0000
  61 00c1 C78534FF 		movl	$48, -204(%rbp)
  61      FFFF3000 
  61      0000
  62 00cb 488D4510 		leaq	16(%rbp), %rax
  63 00cf 48898538 		movq	%rax, -200(%rbp)
  63      FFFFFF
  64 00d6 488D8550 		leaq	-176(%rbp), %rax
  64      FFFFFF
  65 00dd 48898540 		movq	%rax, -192(%rbp)
  65      FFFFFF
  47:liberror.c    **** 			returnCode = vsnprintf(bufPtr, size, format, argList);
  66              		.loc 1 47 0
  67 00e4 8B8518FF 		movl	-232(%rbp), %eax
  67      FFFF
  68 00ea 4863F0   		movslq	%eax, %rsi
  69 00ed 488D8D30 		leaq	-208(%rbp), %rcx
  69      FFFFFF
  70 00f4 488B9500 		movq	-256(%rbp), %rdx
  70      FFFFFF
  71 00fb 488B8520 		movq	-224(%rbp), %rax
  71      FFFFFF
  72 0102 4889C7   		movq	%rax, %rdi
  73 0105 E8000000 		call	vsnprintf@PLT
  73      00
  74 010a 89851CFF 		movl	%eax, -228(%rbp)
  74      FFFF
  48:liberror.c    **** 			va_end(argList);
  49:liberror.c    **** 			
  50:liberror.c    **** 			// If that worked, return the string
  51:liberror.c    **** 			if ( returnCode != -1 && returnCode < size ) {
  75              		.loc 1 51 0
  76 0110 83BD1CFF 		cmpl	$-1, -228(%rbp)
  76      FFFFFF
  77 0117 7421     		je	.L6
  78              		.loc 1 51 0 is_stmt 0 discriminator 1
  79 0119 8B851CFF 		movl	-228(%rbp), %eax
  79      FFFF
  80 011f 3B8518FF 		cmpl	-232(%rbp), %eax
  80      FFFF
  81 0125 7D13     		jge	.L6
  52:liberror.c    **** 				*error = bufPtr;
  82              		.loc 1 52 0 is_stmt 1
  83 0127 488B8508 		movq	-248(%rbp), %rax
  83      FFFFFF
  84 012e 488B9520 		movq	-224(%rbp), %rdx
  84      FFFFFF
  85 0135 488910   		movq	%rdx, (%rax)
  53:liberror.c    **** 				return;
  86              		.loc 1 53 0
  87 0138 EB7E     		jmp	.L1
  88              	.L6:
  54:liberror.c    **** 			}
  55:liberror.c    **** 			
  56:liberror.c    **** 			// Else try again with more space
  57:liberror.c    **** 			if ( returnCode == -1 ) {
  89              		.loc 1 57 0
  90 013a 83BD1CFF 		cmpl	$-1, -228(%rbp)
  90      FFFFFF
  91 0141 7508     		jne	.L7
  58:liberror.c    **** 				// vsnprintf() in glibc 2.0 and MSVC not C99-compliant: returns -1 if buf too small
  59:liberror.c    **** 				size *= 2;
  92              		.loc 1 59 0
  93 0143 D1A518FF 		sall	-232(%rbp)
  93      FFFF
  94 0149 EB0F     		jmp	.L8
  95              	.L7:
  60:liberror.c    **** 			} else {
  61:liberror.c    **** 				// vsnprintf() in glibc 2.1 is C99-compliant: returns the exact no. of bytes needed
  62:liberror.c    **** 				size = returnCode + 1;
  96              		.loc 1 62 0
  97 014b 8B851CFF 		movl	-228(%rbp), %eax
  97      FFFF
  98 0151 83C001   		addl	$1, %eax
  99 0154 898518FF 		movl	%eax, -232(%rbp)
  99      FFFF
 100              	.L8:
  63:liberror.c    **** 			}
  64:liberror.c    **** 			newBufPtr = (char*)realloc(bufPtr, size);
 101              		.loc 1 64 0
 102 015a 8B8518FF 		movl	-232(%rbp), %eax
 102      FFFF
 103 0160 4863D0   		movslq	%eax, %rdx
 104 0163 488B8520 		movq	-224(%rbp), %rax
 104      FFFFFF
 105 016a 4889D6   		movq	%rdx, %rsi
 106 016d 4889C7   		movq	%rax, %rdi
 107 0170 E8000000 		call	realloc@PLT
 107      00
 108 0175 48898528 		movq	%rax, -216(%rbp)
 108      FFFFFF
  65:liberror.c    **** 			if ( newBufPtr == NULL ) {
 109              		.loc 1 65 0
 110 017c 4883BD28 		cmpq	$0, -216(%rbp)
 110      FFFFFF00 
 111 0184 751F     		jne	.L9
  66:liberror.c    **** 				free(bufPtr);
 112              		.loc 1 66 0
 113 0186 488B8520 		movq	-224(%rbp), %rax
 113      FFFFFF
 114 018d 4889C7   		movq	%rax, %rdi
 115 0190 E8000000 		call	free@PLT
 115      00
  67:liberror.c    **** 				*error = NULL;
 116              		.loc 1 67 0
 117 0195 488B8508 		movq	-248(%rbp), %rax
 117      FFFFFF
 118 019c 48C70000 		movq	$0, (%rax)
 118      000000
  68:liberror.c    **** 				return;
 119              		.loc 1 68 0
 120 01a3 EB13     		jmp	.L1
 121              	.L9:
  69:liberror.c    **** 			} else {
  70:liberror.c    **** 				bufPtr = newBufPtr;
 122              		.loc 1 70 0
 123 01a5 488B8528 		movq	-216(%rbp), %rax
 123      FFFFFF
 124 01ac 48898520 		movq	%rax, -224(%rbp)
 124      FFFFFF
  71:liberror.c    **** 			}
  72:liberror.c    **** 		}
 125              		.loc 1 72 0
 126 01b3 E9FFFEFF 		jmp	.L4
 126      FF
 127              	.L1:
 128              	.LBE2:
  73:liberror.c    **** 	}
  74:liberror.c    **** }
 129              		.loc 1 74 0
 130 01b8 488B8548 		movq	-184(%rbp), %rax
 130      FFFFFF
 131 01bf 64483304 		xorq	%fs:40, %rax
 131      25280000 
 131      00
 132 01c8 7405     		je	.L10
 133 01ca E8000000 		call	__stack_chk_fail@PLT
 133      00
 134              	.L10:
 135 01cf C9       		leave
 136              		.cfi_def_cfa 7, 8
 137 01d0 C3       		ret
 138              		.cfi_endproc
 139              	.LFE4:
 141              		.globl	errPrefix
 143              	errPrefix:
 144              	.LFB5:
  75:liberror.c    **** 
  76:liberror.c    **** // Add a prefix to the front of the error by reallocating & copying
  77:liberror.c    **** //
  78:liberror.c    **** DLLEXPORT(void) errPrefix(const char **error, const char *prefix) {
 145              		.loc 1 78 0
 146              		.cfi_startproc
 147 01d1 55       		pushq	%rbp
 148              		.cfi_def_cfa_offset 16
 149              		.cfi_offset 6, -16
 150 01d2 4889E5   		movq	%rsp, %rbp
 151              		.cfi_def_cfa_register 6
 152 01d5 4883EC30 		subq	$48, %rsp
 153 01d9 48897DD8 		movq	%rdi, -40(%rbp)
 154 01dd 488975D0 		movq	%rsi, -48(%rbp)
  79:liberror.c    **** 	if ( error && prefix ) {
 155              		.loc 1 79 0
 156 01e1 48837DD8 		cmpq	$0, -40(%rbp)
 156      00
 157 01e6 0F84DC00 		je	.L11
 157      0000
 158              		.loc 1 79 0 is_stmt 0 discriminator 1
 159 01ec 48837DD0 		cmpq	$0, -48(%rbp)
 159      00
 160 01f1 0F84D100 		je	.L11
 160      0000
 161              	.LBB3:
  80:liberror.c    **** 		char *newError, *p;
  81:liberror.c    **** 		const int pLen = strlen(prefix); // ": " and null terminator
 162              		.loc 1 81 0 is_stmt 1
 163 01f7 488B45D0 		movq	-48(%rbp), %rax
 164 01fb 4889C7   		movq	%rax, %rdi
 165 01fe E8000000 		call	strlen@PLT
 165      00
 166 0203 8945E8   		movl	%eax, -24(%rbp)
  82:liberror.c    **** 		const int len = pLen + strlen(*error) + 3; // ": " and null terminator
 167              		.loc 1 82 0
 168 0206 488B45D8 		movq	-40(%rbp), %rax
 169 020a 488B00   		movq	(%rax), %rax
 170 020d 4889C7   		movq	%rax, %rdi
 171 0210 E8000000 		call	strlen@PLT
 171      00
 172 0215 89C2     		movl	%eax, %edx
 173 0217 8B45E8   		movl	-24(%rbp), %eax
 174 021a 01D0     		addl	%edx, %eax
 175 021c 83C003   		addl	$3, %eax
 176 021f 8945EC   		movl	%eax, -20(%rbp)
  83:liberror.c    **** 		p = newError = (char*)malloc(len);
 177              		.loc 1 83 0
 178 0222 8B45EC   		movl	-20(%rbp), %eax
 179 0225 4898     		cltq
 180 0227 4889C7   		movq	%rax, %rdi
 181 022a E8000000 		call	malloc@PLT
 181      00
 182 022f 488945F0 		movq	%rax, -16(%rbp)
 183 0233 488B45F0 		movq	-16(%rbp), %rax
 184 0237 488945F8 		movq	%rax, -8(%rbp)
  84:liberror.c    **** 		if ( newError == NULL ) {
 185              		.loc 1 84 0
 186 023b 48837DF0 		cmpq	$0, -16(%rbp)
 186      00
 187 0240 751C     		jne	.L13
  85:liberror.c    **** 			errFree(*error);
 188              		.loc 1 85 0
 189 0242 488B45D8 		movq	-40(%rbp), %rax
 190 0246 488B00   		movq	(%rax), %rax
 191 0249 4889C7   		movq	%rax, %rdi
 192 024c E8000000 		call	errFree@PLT
 192      00
  86:liberror.c    **** 			*error = NULL;
 193              		.loc 1 86 0
 194 0251 488B45D8 		movq	-40(%rbp), %rax
 195 0255 48C70000 		movq	$0, (%rax)
 195      000000
  87:liberror.c    **** 			return;
 196              		.loc 1 87 0
 197 025c EB6A     		jmp	.L11
 198              	.L13:
  88:liberror.c    **** 		}
  89:liberror.c    **** 		strcpy(p, prefix);
 199              		.loc 1 89 0
 200 025e 488B55D0 		movq	-48(%rbp), %rdx
 201 0262 488B45F8 		movq	-8(%rbp), %rax
 202 0266 4889D6   		movq	%rdx, %rsi
 203 0269 4889C7   		movq	%rax, %rdi
 204 026c E8000000 		call	strcpy@PLT
 204      00
  90:liberror.c    **** 		p += pLen;
 205              		.loc 1 90 0
 206 0271 8B45E8   		movl	-24(%rbp), %eax
 207 0274 4898     		cltq
 208 0276 480145F8 		addq	%rax, -8(%rbp)
  91:liberror.c    **** 		*p++ = ':';
 209              		.loc 1 91 0
 210 027a 488B45F8 		movq	-8(%rbp), %rax
 211 027e 488D5001 		leaq	1(%rax), %rdx
 212 0282 488955F8 		movq	%rdx, -8(%rbp)
 213 0286 C6003A   		movb	$58, (%rax)
  92:liberror.c    **** 		*p++ = ' ';
 214              		.loc 1 92 0
 215 0289 488B45F8 		movq	-8(%rbp), %rax
 216 028d 488D5001 		leaq	1(%rax), %rdx
 217 0291 488955F8 		movq	%rdx, -8(%rbp)
 218 0295 C60020   		movb	$32, (%rax)
  93:liberror.c    **** 		strcpy(p, *error);
 219              		.loc 1 93 0
 220 0298 488B45D8 		movq	-40(%rbp), %rax
 221 029c 488B10   		movq	(%rax), %rdx
 222 029f 488B45F8 		movq	-8(%rbp), %rax
 223 02a3 4889D6   		movq	%rdx, %rsi
 224 02a6 4889C7   		movq	%rax, %rdi
 225 02a9 E8000000 		call	strcpy@PLT
 225      00
  94:liberror.c    **** 		errFree(*error);
 226              		.loc 1 94 0
 227 02ae 488B45D8 		movq	-40(%rbp), %rax
 228 02b2 488B00   		movq	(%rax), %rax
 229 02b5 4889C7   		movq	%rax, %rdi
 230 02b8 E8000000 		call	errFree@PLT
 230      00
  95:liberror.c    **** 		*error = newError;
 231              		.loc 1 95 0
 232 02bd 488B45D8 		movq	-40(%rbp), %rax
 233 02c1 488B55F0 		movq	-16(%rbp), %rdx
 234 02c5 488910   		movq	%rdx, (%rax)
 235              	.L11:
 236              	.LBE3:
  96:liberror.c    **** 	}
  97:liberror.c    **** }
 237              		.loc 1 97 0
 238 02c8 C9       		leave
 239              		.cfi_def_cfa 7, 8
 240 02c9 C3       		ret
 241              		.cfi_endproc
 242              	.LFE5:
 244              		.globl	errRenderStd
 246              	errRenderStd:
 247              	.LFB6:
  98:liberror.c    **** 
  99:liberror.c    **** // Render the last libC error in the same way that errRender() does
 100:liberror.c    **** //
 101:liberror.c    **** DLLEXPORT(void) errRenderStd(const char **error) {
 248              		.loc 1 101 0
 249              		.cfi_startproc
 250 02ca 55       		pushq	%rbp
 251              		.cfi_def_cfa_offset 16
 252              		.cfi_offset 6, -16
 253 02cb 4889E5   		movq	%rsp, %rbp
 254              		.cfi_def_cfa_register 6
 255 02ce 4883EC30 		subq	$48, %rsp
 256 02d2 48897DD8 		movq	%rdi, -40(%rbp)
 102:liberror.c    **** 	if ( error ) {
 257              		.loc 1 102 0
 258 02d6 48837DD8 		cmpq	$0, -40(%rbp)
 258      00
 259 02db 0F84D000 		je	.L14
 259      0000
 260              	.LBB4:
 103:liberror.c    **** 		// Guess we need no more than 512 bytes
 104:liberror.c    **** 		int returnCode, size = 512;
 261              		.loc 1 104 0
 262 02e1 C745E400 		movl	$512, -28(%rbp)
 262      020000
 105:liberror.c    **** 		char *bufPtr, *newBufPtr;
 106:liberror.c    **** 		const int errSave = errno;
 263              		.loc 1 106 0
 264 02e8 E8000000 		call	__errno_location@PLT
 264      00
 265 02ed 8B00     		movl	(%rax), %eax
 266 02ef 8945E8   		movl	%eax, -24(%rbp)
 107:liberror.c    **** 		bufPtr = (char*)malloc(size);
 267              		.loc 1 107 0
 268 02f2 8B45E4   		movl	-28(%rbp), %eax
 269 02f5 4898     		cltq
 270 02f7 4889C7   		movq	%rax, %rdi
 271 02fa E8000000 		call	malloc@PLT
 271      00
 272 02ff 488945F0 		movq	%rax, -16(%rbp)
 108:liberror.c    **** 		if ( bufPtr == NULL ) {
 273              		.loc 1 108 0
 274 0303 48837DF0 		cmpq	$0, -16(%rbp)
 274      00
 275 0308 7510     		jne	.L16
 109:liberror.c    **** 			// Insufficient memory
 110:liberror.c    **** 			*error = NULL;
 276              		.loc 1 110 0
 277 030a 488B45D8 		movq	-40(%rbp), %rax
 278 030e 48C70000 		movq	$0, (%rax)
 278      000000
 111:liberror.c    **** 			return;
 279              		.loc 1 111 0
 280 0315 E9970000 		jmp	.L14
 280      00
 281              	.L16:
 112:liberror.c    **** 		}
 113:liberror.c    **** 		for ( ; ; ) {
 114:liberror.c    **** 			// Try to print in the allocated space
 115:liberror.c    **** 			returnCode = strerror_r(errSave, bufPtr, size);
 282              		.loc 1 115 0
 283 031a 8B45E4   		movl	-28(%rbp), %eax
 284 031d 4863D0   		movslq	%eax, %rdx
 285 0320 488B4DF0 		movq	-16(%rbp), %rcx
 286 0324 8B45E8   		movl	-24(%rbp), %eax
 287 0327 4889CE   		movq	%rcx, %rsi
 288 032a 89C7     		movl	%eax, %edi
 289 032c E8000000 		call	__xpg_strerror_r@PLT
 289      00
 290 0331 8945EC   		movl	%eax, -20(%rbp)
 116:liberror.c    **** 			if ( returnCode == 0 ) {
 291              		.loc 1 116 0
 292 0334 837DEC00 		cmpl	$0, -20(%rbp)
 293 0338 750D     		jne	.L17
 117:liberror.c    **** 				// Yay, it fits! (WIN32 comes through here even if the message was truncated...doh)
 118:liberror.c    **** 				*error = bufPtr;
 294              		.loc 1 118 0
 295 033a 488B45D8 		movq	-40(%rbp), %rax
 296 033e 488B55F0 		movq	-16(%rbp), %rdx
 297 0342 488910   		movq	%rdx, (%rax)
 119:liberror.c    **** 				return;
 298              		.loc 1 119 0
 299 0345 EB6A     		jmp	.L14
 300              	.L17:
 120:liberror.c    **** 			} else if ( returnCode == -1 && errno == ERANGE ) {
 301              		.loc 1 120 0
 302 0347 837DECFF 		cmpl	$-1, -20(%rbp)
 303 034b 7531     		jne	.L18
 304              		.loc 1 120 0 is_stmt 0 discriminator 1
 305 034d E8000000 		call	__errno_location@PLT
 305      00
 306 0352 8B00     		movl	(%rax), %eax
 307 0354 83F822   		cmpl	$34, %eax
 308 0357 7525     		jne	.L18
 121:liberror.c    **** 				// It doesn't fit...resize buffer and try again
 122:liberror.c    **** 				size *= 2;
 309              		.loc 1 122 0 is_stmt 1
 310 0359 D165E4   		sall	-28(%rbp)
 123:liberror.c    **** 			} else {
 124:liberror.c    **** 				// Some other problem...invalid errno perhaps?
 125:liberror.c    **** 				*error = NULL;
 126:liberror.c    **** 				return;
 127:liberror.c    **** 			}
 128:liberror.c    **** 			newBufPtr = (char*)realloc(bufPtr, size);
 311              		.loc 1 128 0
 312 035c 8B45E4   		movl	-28(%rbp), %eax
 313 035f 4863D0   		movslq	%eax, %rdx
 314 0362 488B45F0 		movq	-16(%rbp), %rax
 315 0366 4889D6   		movq	%rdx, %rsi
 316 0369 4889C7   		movq	%rax, %rdi
 317 036c E8000000 		call	realloc@PLT
 317      00
 318 0371 488945F8 		movq	%rax, -8(%rbp)
 129:liberror.c    **** 			if ( newBufPtr == NULL ) {
 319              		.loc 1 129 0
 320 0375 48837DF8 		cmpq	$0, -8(%rbp)
 320      00
 321 037a 740F     		je	.L19
 322 037c EB26     		jmp	.L21
 323              	.L18:
 125:liberror.c    **** 				return;
 324              		.loc 1 125 0
 325 037e 488B45D8 		movq	-40(%rbp), %rax
 326 0382 48C70000 		movq	$0, (%rax)
 326      000000
 126:liberror.c    **** 			}
 327              		.loc 1 126 0
 328 0389 EB26     		jmp	.L14
 329              	.L19:
 130:liberror.c    **** 				free(bufPtr);
 330              		.loc 1 130 0
 331 038b 488B45F0 		movq	-16(%rbp), %rax
 332 038f 4889C7   		movq	%rax, %rdi
 333 0392 E8000000 		call	free@PLT
 333      00
 131:liberror.c    **** 				*error = NULL;
 334              		.loc 1 131 0
 335 0397 488B45D8 		movq	-40(%rbp), %rax
 336 039b 48C70000 		movq	$0, (%rax)
 336      000000
 132:liberror.c    **** 				return;
 337              		.loc 1 132 0
 338 03a2 EB0D     		jmp	.L14
 339              	.L21:
 133:liberror.c    **** 			} else {
 134:liberror.c    **** 				bufPtr = newBufPtr;
 340              		.loc 1 134 0
 341 03a4 488B45F8 		movq	-8(%rbp), %rax
 342 03a8 488945F0 		movq	%rax, -16(%rbp)
 135:liberror.c    **** 			}
 136:liberror.c    **** 		}
 343              		.loc 1 136 0
 344 03ac E969FFFF 		jmp	.L16
 344      FF
 345              	.L14:
 346              	.LBE4:
 137:liberror.c    **** 	}
 138:liberror.c    **** }
 347              		.loc 1 138 0
 348 03b1 C9       		leave
 349              		.cfi_def_cfa 7, 8
 350 03b2 C3       		ret
 351              		.cfi_endproc
 352              	.LFE6:
 354              		.globl	errFree
 356              	errFree:
 357              	.LFB7:
 139:liberror.c    **** 
 140:liberror.c    **** DLLEXPORT(void) errFree(const char *error) {
 358              		.loc 1 140 0
 359              		.cfi_startproc
 360 03b3 55       		pushq	%rbp
 361              		.cfi_def_cfa_offset 16
 362              		.cfi_offset 6, -16
 363 03b4 4889E5   		movq	%rsp, %rbp
 364              		.cfi_def_cfa_register 6
 365 03b7 4883EC10 		subq	$16, %rsp
 366 03bb 48897DF8 		movq	%rdi, -8(%rbp)
 141:liberror.c    **** 	free((void*)error);
 367              		.loc 1 141 0
 368 03bf 488B45F8 		movq	-8(%rbp), %rax
 369 03c3 4889C7   		movq	%rax, %rdi
 370 03c6 E8000000 		call	free@PLT
 370      00
 142:liberror.c    **** }
 371              		.loc 1 142 0
 372 03cb C9       		leave
 373              		.cfi_def_cfa 7, 8
 374 03cc C3       		ret
 375              		.cfi_endproc
 376              	.LFE7:
 378              	.Letext0:
 379              		.file 2 "<built-in>"
 380              		.file 3 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
 381              		.file 4 "/usr/include/stdio.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 liberror.c
     /tmp/ccxReoki.s:6      .text:0000000000000000 errRender
     /tmp/ccxReoki.s:143    .text:00000000000001d1 errPrefix
     /tmp/ccxReoki.s:356    .text:00000000000003b3 errFree
     /tmp/ccxReoki.s:246    .text:00000000000002ca errRenderStd

UNDEFINED SYMBOLS
_GLOBAL_OFFSET_TABLE_
malloc
vsnprintf
realloc
free
__stack_chk_fail
strlen
strcpy
__errno_location
__xpg_strerror_r
