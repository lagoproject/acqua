   1              		.file	"conv.c"
   2              		.text
   3              	.Ltext0:
   4              		.globl	getHexNibble
   6              	getHexNibble:
   7              	.LFB4:
   8              		.file 1 "conv.c"
   1:conv.c        **** /*
   2:conv.c        ****  * Copyright (C) 2009-2012 Chris McClelland
   3:conv.c        ****  *
   4:conv.c        ****  * This program is free software: you can redistribute it and/or modify
   5:conv.c        ****  * it under the terms of the GNU Lesser General Public License as published by
   6:conv.c        ****  * the Free Software Foundation, either version 3 of the License, or
   7:conv.c        ****  * (at your option) any later version.
   8:conv.c        ****  *
   9:conv.c        ****  * This program is distributed in the hope that it will be useful,
  10:conv.c        ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:conv.c        ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:conv.c        ****  * GNU Lesser General Public License for more details.
  13:conv.c        ****  *
  14:conv.c        ****  * You should have received a copy of the GNU Lesser General Public License
  15:conv.c        ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:conv.c        ****  */
  17:conv.c        **** #include "conv.h"
  18:conv.c        **** 
  19:conv.c        **** // Updates *outputNibble with the nibble represented by the supplied ascii hex digit.
  20:conv.c        **** // Return false on success or true for illegal char.
  21:conv.c        **** //
  22:conv.c        **** bool getHexNibble(char hexDigit, uint8 *outputNibble) {
   9              		.loc 1 22 0
  10              		.cfi_startproc
  11 0000 55       		pushq	%rbp
  12              		.cfi_def_cfa_offset 16
  13              		.cfi_offset 6, -16
  14 0001 4889E5   		movq	%rsp, %rbp
  15              		.cfi_def_cfa_register 6
  16 0004 89F8     		movl	%edi, %eax
  17 0006 488975F0 		movq	%rsi, -16(%rbp)
  18 000a 8845FC   		movb	%al, -4(%rbp)
  23:conv.c        **** 	if ( hexDigit >= '0' && hexDigit <= '9' ) {
  19              		.loc 1 23 0
  20 000d 807DFC2F 		cmpb	$47, -4(%rbp)
  21 0011 7E1A     		jle	.L2
  22              		.loc 1 23 0 is_stmt 0 discriminator 1
  23 0013 807DFC39 		cmpb	$57, -4(%rbp)
  24 0017 7F14     		jg	.L2
  24:conv.c        **** 		*outputNibble = hexDigit - '0';
  25              		.loc 1 24 0 is_stmt 1
  26 0019 0FB645FC 		movzbl	-4(%rbp), %eax
  27 001d 8D50D0   		leal	-48(%rax), %edx
  28 0020 488B45F0 		movq	-16(%rbp), %rax
  29 0024 8810     		movb	%dl, (%rax)
  25:conv.c        **** 		return false;
  30              		.loc 1 25 0
  31 0026 B8000000 		movl	$0, %eax
  31      00
  32 002b EB45     		jmp	.L3
  33              	.L2:
  26:conv.c        **** 	} else if ( hexDigit >= 'a' && hexDigit <= 'f' ) {
  34              		.loc 1 26 0
  35 002d 807DFC60 		cmpb	$96, -4(%rbp)
  36 0031 7E1A     		jle	.L4
  37              		.loc 1 26 0 is_stmt 0 discriminator 1
  38 0033 807DFC66 		cmpb	$102, -4(%rbp)
  39 0037 7F14     		jg	.L4
  27:conv.c        **** 		*outputNibble = hexDigit - 'a' + 10;
  40              		.loc 1 27 0 is_stmt 1
  41 0039 0FB645FC 		movzbl	-4(%rbp), %eax
  42 003d 8D50A9   		leal	-87(%rax), %edx
  43 0040 488B45F0 		movq	-16(%rbp), %rax
  44 0044 8810     		movb	%dl, (%rax)
  28:conv.c        **** 		return false;
  45              		.loc 1 28 0
  46 0046 B8000000 		movl	$0, %eax
  46      00
  47 004b EB25     		jmp	.L3
  48              	.L4:
  29:conv.c        **** 	} else if ( hexDigit >= 'A' && hexDigit <= 'F' ) {
  49              		.loc 1 29 0
  50 004d 807DFC40 		cmpb	$64, -4(%rbp)
  51 0051 7E1A     		jle	.L5
  52              		.loc 1 29 0 is_stmt 0 discriminator 1
  53 0053 807DFC46 		cmpb	$70, -4(%rbp)
  54 0057 7F14     		jg	.L5
  30:conv.c        **** 		*outputNibble = hexDigit - 'A' + 10;
  55              		.loc 1 30 0 is_stmt 1
  56 0059 0FB645FC 		movzbl	-4(%rbp), %eax
  57 005d 8D50C9   		leal	-55(%rax), %edx
  58 0060 488B45F0 		movq	-16(%rbp), %rax
  59 0064 8810     		movb	%dl, (%rax)
  31:conv.c        **** 		return false;
  60              		.loc 1 31 0
  61 0066 B8000000 		movl	$0, %eax
  61      00
  62 006b EB05     		jmp	.L3
  63              	.L5:
  32:conv.c        **** 	} else {
  33:conv.c        **** 		return true;
  64              		.loc 1 33 0
  65 006d B8010000 		movl	$1, %eax
  65      00
  66              	.L3:
  34:conv.c        **** 	}
  35:conv.c        **** }
  67              		.loc 1 35 0
  68 0072 5D       		popq	%rbp
  69              		.cfi_def_cfa 7, 8
  70 0073 C3       		ret
  71              		.cfi_endproc
  72              	.LFE4:
  74              		.globl	getHexByte
  76              	getHexByte:
  77              	.LFB5:
  36:conv.c        **** 
  37:conv.c        **** // Updates *outputByte with the byte represented by the two ascii hex digits pointed to by hexDigit
  38:conv.c        **** // Return false on success or true for illegal char.
  39:conv.c        **** //
  40:conv.c        **** bool getHexByte(const char *hexDigitPair, uint8 *outputByte) {
  78              		.loc 1 40 0
  79              		.cfi_startproc
  80 0074 55       		pushq	%rbp
  81              		.cfi_def_cfa_offset 16
  82              		.cfi_offset 6, -16
  83 0075 4889E5   		movq	%rsp, %rbp
  84              		.cfi_def_cfa_register 6
  85 0078 4883EC20 		subq	$32, %rsp
  86 007c 48897DE8 		movq	%rdi, -24(%rbp)
  87 0080 488975E0 		movq	%rsi, -32(%rbp)
  88              		.loc 1 40 0
  89 0084 64488B04 		movq	%fs:40, %rax
  89      25280000 
  89      00
  90 008d 488945F8 		movq	%rax, -8(%rbp)
  91 0091 31C0     		xorl	%eax, %eax
  41:conv.c        **** 	uint8 upperNibble;
  42:conv.c        **** 	uint8 lowerNibble;
  43:conv.c        **** 	if ( !getHexNibble(hexDigitPair[0], &upperNibble) && !getHexNibble(hexDigitPair[1], &lowerNibble) 
  92              		.loc 1 43 0
  93 0093 488B45E8 		movq	-24(%rbp), %rax
  94 0097 0FB600   		movzbl	(%rax), %eax
  95 009a 0FBEC0   		movsbl	%al, %eax
  96 009d 488D55F6 		leaq	-10(%rbp), %rdx
  97 00a1 4889D6   		movq	%rdx, %rsi
  98 00a4 89C7     		movl	%eax, %edi
  99 00a6 E8000000 		call	getHexNibble@PLT
  99      00
 100 00ab 83F001   		xorl	$1, %eax
 101 00ae 84C0     		testb	%al, %al
 102 00b0 7444     		je	.L7
 103              		.loc 1 43 0 is_stmt 0 discriminator 1
 104 00b2 488B45E8 		movq	-24(%rbp), %rax
 105 00b6 4883C001 		addq	$1, %rax
 106 00ba 0FB600   		movzbl	(%rax), %eax
 107 00bd 0FBEC0   		movsbl	%al, %eax
 108 00c0 488D55F7 		leaq	-9(%rbp), %rdx
 109 00c4 4889D6   		movq	%rdx, %rsi
 110 00c7 89C7     		movl	%eax, %edi
 111 00c9 E8000000 		call	getHexNibble@PLT
 111      00
 112 00ce 83F001   		xorl	$1, %eax
 113 00d1 84C0     		testb	%al, %al
 114 00d3 7421     		je	.L7
  44:conv.c        **** 		*outputByte = (upperNibble << 4) | lowerNibble;
 115              		.loc 1 44 0 is_stmt 1
 116 00d5 0FB645F6 		movzbl	-10(%rbp), %eax
 117 00d9 0FB6C0   		movzbl	%al, %eax
 118 00dc C1E004   		sall	$4, %eax
 119 00df 89C2     		movl	%eax, %edx
 120 00e1 0FB645F7 		movzbl	-9(%rbp), %eax
 121 00e5 09D0     		orl	%edx, %eax
 122 00e7 89C2     		movl	%eax, %edx
 123 00e9 488B45E0 		movq	-32(%rbp), %rax
 124 00ed 8810     		movb	%dl, (%rax)
  45:conv.c        **** 		return false;
 125              		.loc 1 45 0
 126 00ef B8000000 		movl	$0, %eax
 126      00
 127 00f4 EB05     		jmp	.L9
 128              	.L7:
  46:conv.c        **** 	} else {
  47:conv.c        **** 		return true;
 129              		.loc 1 47 0
 130 00f6 B8010000 		movl	$1, %eax
 130      00
 131              	.L9:
  48:conv.c        **** 	}
  49:conv.c        **** }
 132              		.loc 1 49 0 discriminator 1
 133 00fb 488B4DF8 		movq	-8(%rbp), %rcx
 134 00ff 6448330C 		xorq	%fs:40, %rcx
 134      25280000 
 134      00
 135 0108 7405     		je	.L10
 136              		.loc 1 49 0 is_stmt 0
 137 010a E8000000 		call	__stack_chk_fail@PLT
 137      00
 138              	.L10:
 139 010f C9       		leave
 140              		.cfi_def_cfa 7, 8
 141 0110 C3       		ret
 142              		.cfi_endproc
 143              	.LFE5:
 145              		.globl	getHexUpperNibble
 147              	getHexUpperNibble:
 148              	.LFB6:
  50:conv.c        **** 
  51:conv.c        **** // Return the ascii hex digit representing the most significant nibble of the supplied byte.
  52:conv.c        **** //
  53:conv.c        **** char getHexUpperNibble(uint8 byte) {
 149              		.loc 1 53 0 is_stmt 1
 150              		.cfi_startproc
 151 0111 55       		pushq	%rbp
 152              		.cfi_def_cfa_offset 16
 153              		.cfi_offset 6, -16
 154 0112 4889E5   		movq	%rsp, %rbp
 155              		.cfi_def_cfa_register 6
 156 0115 89F8     		movl	%edi, %eax
 157 0117 8845EC   		movb	%al, -20(%rbp)
  54:conv.c        **** 	uint8 tmp = byte >> 4;
 158              		.loc 1 54 0
 159 011a 0FB645EC 		movzbl	-20(%rbp), %eax
 160 011e C0E804   		shrb	$4, %al
 161 0121 8845FF   		movb	%al, -1(%rbp)
  55:conv.c        **** 	tmp += (tmp < 10) ? '0' : 'A' - 10;
 162              		.loc 1 55 0
 163 0124 807DFF09 		cmpb	$9, -1(%rbp)
 164 0128 7707     		ja	.L12
 165              		.loc 1 55 0 is_stmt 0 discriminator 1
 166 012a B8300000 		movl	$48, %eax
 166      00
 167 012f EB05     		jmp	.L13
 168              	.L12:
 169              		.loc 1 55 0 discriminator 2
 170 0131 B8370000 		movl	$55, %eax
 170      00
 171              	.L13:
 172              		.loc 1 55 0 discriminator 4
 173 0136 0045FF   		addb	%al, -1(%rbp)
  56:conv.c        **** 	return tmp;
 174              		.loc 1 56 0 is_stmt 1 discriminator 4
 175 0139 0FB645FF 		movzbl	-1(%rbp), %eax
  57:conv.c        **** }
 176              		.loc 1 57 0 discriminator 4
 177 013d 5D       		popq	%rbp
 178              		.cfi_def_cfa 7, 8
 179 013e C3       		ret
 180              		.cfi_endproc
 181              	.LFE6:
 183              		.globl	getHexLowerNibble
 185              	getHexLowerNibble:
 186              	.LFB7:
  58:conv.c        **** 
  59:conv.c        **** // Return the ascii hex digit representing the least significant nibble of the supplied byte.
  60:conv.c        **** //
  61:conv.c        **** char getHexLowerNibble(uint8 byte) {
 187              		.loc 1 61 0
 188              		.cfi_startproc
 189 013f 55       		pushq	%rbp
 190              		.cfi_def_cfa_offset 16
 191              		.cfi_offset 6, -16
 192 0140 4889E5   		movq	%rsp, %rbp
 193              		.cfi_def_cfa_register 6
 194 0143 89F8     		movl	%edi, %eax
 195 0145 8845EC   		movb	%al, -20(%rbp)
  62:conv.c        **** 	uint8 tmp = byte & 0x0F;
 196              		.loc 1 62 0
 197 0148 0FB645EC 		movzbl	-20(%rbp), %eax
 198 014c 83E00F   		andl	$15, %eax
 199 014f 8845FF   		movb	%al, -1(%rbp)
  63:conv.c        **** 	tmp += (tmp < 10) ? '0' : 'A' - 10;
 200              		.loc 1 63 0
 201 0152 807DFF09 		cmpb	$9, -1(%rbp)
 202 0156 7707     		ja	.L16
 203              		.loc 1 63 0 is_stmt 0 discriminator 1
 204 0158 B8300000 		movl	$48, %eax
 204      00
 205 015d EB05     		jmp	.L17
 206              	.L16:
 207              		.loc 1 63 0 discriminator 2
 208 015f B8370000 		movl	$55, %eax
 208      00
 209              	.L17:
 210              		.loc 1 63 0 discriminator 4
 211 0164 0045FF   		addb	%al, -1(%rbp)
  64:conv.c        **** 	return tmp;
 212              		.loc 1 64 0 is_stmt 1 discriminator 4
 213 0167 0FB645FF 		movzbl	-1(%rbp), %eax
  65:conv.c        **** }
 214              		.loc 1 65 0 discriminator 4
 215 016b 5D       		popq	%rbp
 216              		.cfi_def_cfa 7, 8
 217 016c C3       		ret
 218              		.cfi_endproc
 219              	.LFE7:
 221              	.Letext0:
 222              		.file 2 "/home/asoreyh/Dropbox/projects/lago/lago-software/acqua/brc/lago/makestuff/common/makestu
DEFINED SYMBOLS
                            *ABS*:0000000000000000 conv.c
     /tmp/cc9L4lqW.s:6      .text:0000000000000000 getHexNibble
     /tmp/cc9L4lqW.s:76     .text:0000000000000074 getHexByte
     /tmp/cc9L4lqW.s:147    .text:0000000000000111 getHexUpperNibble
     /tmp/cc9L4lqW.s:185    .text:000000000000013f getHexLowerNibble

UNDEFINED SYMBOLS
_GLOBAL_OFFSET_TABLE_
__stack_chk_fail
