   1              		.file	"core.c"
   2              		.text
   3              	.Ltext0:
   4              		.section	.rodata
   5              		.align 8
   6              	.LC0:
   7 0000 43616E6E 		.string	"Cannot allocate memory for buffer"
   7      6F742061 
   7      6C6C6F63 
   7      61746520 
   7      6D656D6F 
   8              		.text
   9              		.globl	bufInitialise
  11              	bufInitialise:
  12              	.LFB4:
  13              		.file 1 "core.c"
   1:core.c        **** /*
   2:core.c        ****  * Copyright (C) 2009-2012 Chris McClelland
   3:core.c        ****  *
   4:core.c        ****  * This program is free software: you can redistribute it and/or modify
   5:core.c        ****  * it under the terms of the GNU Lesser General Public License as published by
   6:core.c        ****  * the Free Software Foundation, either version 3 of the License, or
   7:core.c        ****  * (at your option) any later version.
   8:core.c        ****  *
   9:core.c        ****  * This program is distributed in the hope that it will be useful,
  10:core.c        ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:core.c        ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:core.c        ****  * GNU Lesser General Public License for more details.
  13:core.c        ****  *
  14:core.c        ****  * You should have received a copy of the GNU Lesser General Public License
  15:core.c        ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:core.c        ****  */
  17:core.c        **** #include <stdio.h>
  18:core.c        **** #include <stdlib.h>
  19:core.c        **** #include <string.h>
  20:core.c        **** #include <liberror.h>
  21:core.c        **** #include "libbuffer.h"
  22:core.c        **** 
  23:core.c        **** // Initialise the promRecords structure.
  24:core.c        **** // Returns BUF_SUCCESS or BUF_NO_MEM.
  25:core.c        **** //
  26:core.c        **** DLLEXPORT(BufferStatus) bufInitialise(
  27:core.c        **** 	struct Buffer *self, uint32 initialSize, uint8 fill, const char **error)
  28:core.c        **** {
  14              		.loc 1 28 0
  15              		.cfi_startproc
  16 0000 55       		pushq	%rbp
  17              		.cfi_def_cfa_offset 16
  18              		.cfi_offset 6, -16
  19 0001 4889E5   		movq	%rsp, %rbp
  20              		.cfi_def_cfa_register 6
  21 0004 4883EC30 		subq	$48, %rsp
  22 0008 48897DE8 		movq	%rdi, -24(%rbp)
  23 000c 8975E4   		movl	%esi, -28(%rbp)
  24 000f 89D0     		movl	%edx, %eax
  25 0011 48894DD8 		movq	%rcx, -40(%rbp)
  26 0015 8845E0   		movb	%al, -32(%rbp)
  29:core.c        **** 	uint8 *ptr;
  30:core.c        **** 	const uint8 *endPtr;
  31:core.c        **** 	self->fill = fill;
  27              		.loc 1 31 0
  28 0018 488B45E8 		movq	-24(%rbp), %rax
  29 001c 0FB655E0 		movzbl	-32(%rbp), %edx
  30 0020 885010   		movb	%dl, 16(%rax)
  32:core.c        **** 	self->data = (uint8 *)malloc(initialSize);
  31              		.loc 1 32 0
  32 0023 8B45E4   		movl	-28(%rbp), %eax
  33 0026 4889C7   		movq	%rax, %rdi
  34 0029 E8000000 		call	malloc@PLT
  34      00
  35 002e 4889C2   		movq	%rax, %rdx
  36 0031 488B45E8 		movq	-24(%rbp), %rax
  37 0035 488910   		movq	%rdx, (%rax)
  33:core.c        **** 	if ( !self->data ) {
  38              		.loc 1 33 0
  39 0038 488B45E8 		movq	-24(%rbp), %rax
  40 003c 488B00   		movq	(%rax), %rax
  41 003f 4885C0   		testq	%rax, %rax
  42 0042 751F     		jne	.L2
  34:core.c        **** 		errRender(error, "Cannot allocate memory for buffer");
  43              		.loc 1 34 0
  44 0044 488B45D8 		movq	-40(%rbp), %rax
  45 0048 488D3500 		leaq	.LC0(%rip), %rsi
  45      000000
  46 004f 4889C7   		movq	%rax, %rdi
  47 0052 B8000000 		movl	$0, %eax
  47      00
  48 0057 E8000000 		call	errRender@PLT
  48      00
  35:core.c        **** 		return BUF_NO_MEM;
  49              		.loc 1 35 0
  50 005c B8010000 		movl	$1, %eax
  50      00
  51 0061 EB55     		jmp	.L3
  52              	.L2:
  36:core.c        **** 	}
  37:core.c        **** 	ptr = self->data;
  53              		.loc 1 37 0
  54 0063 488B45E8 		movq	-24(%rbp), %rax
  55 0067 488B00   		movq	(%rax), %rax
  56 006a 488945F0 		movq	%rax, -16(%rbp)
  38:core.c        **** 	endPtr = ptr + initialSize;
  57              		.loc 1 38 0
  58 006e 8B55E4   		movl	-28(%rbp), %edx
  59 0071 488B45F0 		movq	-16(%rbp), %rax
  60 0075 4801D0   		addq	%rdx, %rax
  61 0078 488945F8 		movq	%rax, -8(%rbp)
  39:core.c        **** 	while ( ptr < endPtr ) {
  62              		.loc 1 39 0
  63 007c EB16     		jmp	.L4
  64              	.L5:
  40:core.c        **** 		*ptr++ = self->fill;
  65              		.loc 1 40 0
  66 007e 488B45F0 		movq	-16(%rbp), %rax
  67 0082 488D5001 		leaq	1(%rax), %rdx
  68 0086 488955F0 		movq	%rdx, -16(%rbp)
  69 008a 488B55E8 		movq	-24(%rbp), %rdx
  70 008e 0FB65210 		movzbl	16(%rdx), %edx
  71 0092 8810     		movb	%dl, (%rax)
  72              	.L4:
  39:core.c        **** 	while ( ptr < endPtr ) {
  73              		.loc 1 39 0
  74 0094 488B45F0 		movq	-16(%rbp), %rax
  75 0098 483B45F8 		cmpq	-8(%rbp), %rax
  76 009c 72E0     		jb	.L5
  41:core.c        **** 	}
  42:core.c        **** 	self->capacity = initialSize;
  77              		.loc 1 42 0
  78 009e 488B45E8 		movq	-24(%rbp), %rax
  79 00a2 8B55E4   		movl	-28(%rbp), %edx
  80 00a5 89500C   		movl	%edx, 12(%rax)
  43:core.c        **** 	self->length = 0;
  81              		.loc 1 43 0
  82 00a8 488B45E8 		movq	-24(%rbp), %rax
  83 00ac C7400800 		movl	$0, 8(%rax)
  83      000000
  44:core.c        **** 	return BUF_SUCCESS;
  84              		.loc 1 44 0
  85 00b3 B8000000 		movl	$0, %eax
  85      00
  86              	.L3:
  45:core.c        **** }
  87              		.loc 1 45 0
  88 00b8 C9       		leave
  89              		.cfi_def_cfa 7, 8
  90 00b9 C3       		ret
  91              		.cfi_endproc
  92              	.LFE4:
  94              		.globl	bufDestroy
  96              	bufDestroy:
  97              	.LFB5:
  46:core.c        **** 
  47:core.c        **** // Free up any memory associated with the buffer structure.
  48:core.c        **** //
  49:core.c        **** DLLEXPORT(void) bufDestroy(struct Buffer *self) {
  98              		.loc 1 49 0
  99              		.cfi_startproc
 100 00ba 55       		pushq	%rbp
 101              		.cfi_def_cfa_offset 16
 102              		.cfi_offset 6, -16
 103 00bb 4889E5   		movq	%rsp, %rbp
 104              		.cfi_def_cfa_register 6
 105 00be 4883EC10 		subq	$16, %rsp
 106 00c2 48897DF8 		movq	%rdi, -8(%rbp)
  50:core.c        **** 	free(self->data);
 107              		.loc 1 50 0
 108 00c6 488B45F8 		movq	-8(%rbp), %rax
 109 00ca 488B00   		movq	(%rax), %rax
 110 00cd 4889C7   		movq	%rax, %rdi
 111 00d0 E8000000 		call	free@PLT
 111      00
  51:core.c        **** 	self->data = NULL;
 112              		.loc 1 51 0
 113 00d5 488B45F8 		movq	-8(%rbp), %rax
 114 00d9 48C70000 		movq	$0, (%rax)
 114      000000
  52:core.c        **** 	self->capacity = 0;
 115              		.loc 1 52 0
 116 00e0 488B45F8 		movq	-8(%rbp), %rax
 117 00e4 C7400C00 		movl	$0, 12(%rax)
 117      000000
  53:core.c        **** 	self->length = 0;
 118              		.loc 1 53 0
 119 00eb 488B45F8 		movq	-8(%rbp), %rax
 120 00ef C7400800 		movl	$0, 8(%rax)
 120      000000
  54:core.c        **** 	self->fill = 0;
 121              		.loc 1 54 0
 122 00f6 488B45F8 		movq	-8(%rbp), %rax
 123 00fa C6401000 		movb	$0, 16(%rax)
  55:core.c        **** }
 124              		.loc 1 55 0
 125 00fe C9       		leave
 126              		.cfi_def_cfa 7, 8
 127 00ff C3       		ret
 128              		.cfi_endproc
 129              	.LFE5:
 131              		.globl	bufDeepCopy
 133              	bufDeepCopy:
 134              	.LFB6:
  56:core.c        **** 
  57:core.c        **** // Either deep copy into an already-constructed buffer, or copy-construct into an uninitialised
  58:core.c        **** // buffer.
  59:core.c        **** //
  60:core.c        **** DLLEXPORT(BufferStatus) bufDeepCopy(
  61:core.c        **** 	struct Buffer *dst, const struct Buffer *src, const char **error)
  62:core.c        **** {
 135              		.loc 1 62 0
 136              		.cfi_startproc
 137 0100 55       		pushq	%rbp
 138              		.cfi_def_cfa_offset 16
 139              		.cfi_offset 6, -16
 140 0101 4889E5   		movq	%rsp, %rbp
 141              		.cfi_def_cfa_register 6
 142 0104 4883EC30 		subq	$48, %rsp
 143 0108 48897DE8 		movq	%rdi, -24(%rbp)
 144 010c 488975E0 		movq	%rsi, -32(%rbp)
 145 0110 488955D8 		movq	%rdx, -40(%rbp)
  63:core.c        **** 	uint8 *ptr;
  64:core.c        **** 	const uint8 *endPtr;
  65:core.c        **** 	if ( dst->data && dst->capacity < src->capacity ) {
 146              		.loc 1 65 0
 147 0114 488B45E8 		movq	-24(%rbp), %rax
 148 0118 488B00   		movq	(%rax), %rax
 149 011b 4885C0   		testq	%rax, %rax
 150 011e 741E     		je	.L8
 151              		.loc 1 65 0 is_stmt 0 discriminator 1
 152 0120 488B45E8 		movq	-24(%rbp), %rax
 153 0124 8B500C   		movl	12(%rax), %edx
 154 0127 488B45E0 		movq	-32(%rbp), %rax
 155 012b 8B400C   		movl	12(%rax), %eax
 156 012e 39C2     		cmpl	%eax, %edx
 157 0130 730C     		jnb	.L8
  66:core.c        **** 		// The dst has been initialised, but there is not enough room for the copy.
  67:core.c        **** 		bufDestroy(dst);
 158              		.loc 1 67 0 is_stmt 1
 159 0132 488B45E8 		movq	-24(%rbp), %rax
 160 0136 4889C7   		movq	%rax, %rdi
 161 0139 E8000000 		call	bufDestroy@PLT
 161      00
 162              	.L8:
  68:core.c        **** 	}
  69:core.c        **** 	if ( !dst->data ) {
 163              		.loc 1 69 0
 164 013e 488B45E8 		movq	-24(%rbp), %rax
 165 0142 488B00   		movq	(%rax), %rax
 166 0145 4885C0   		testq	%rax, %rax
 167 0148 7557     		jne	.L9
  70:core.c        **** 		// The dst needs to be allocated.
  71:core.c        **** 		dst->capacity = src->capacity;
 168              		.loc 1 71 0
 169 014a 488B45E0 		movq	-32(%rbp), %rax
 170 014e 8B500C   		movl	12(%rax), %edx
 171 0151 488B45E8 		movq	-24(%rbp), %rax
 172 0155 89500C   		movl	%edx, 12(%rax)
  72:core.c        **** 		dst->data = (uint8 *)malloc(dst->capacity);
 173              		.loc 1 72 0
 174 0158 488B45E8 		movq	-24(%rbp), %rax
 175 015c 8B400C   		movl	12(%rax), %eax
 176 015f 89C0     		movl	%eax, %eax
 177 0161 4889C7   		movq	%rax, %rdi
 178 0164 E8000000 		call	malloc@PLT
 178      00
 179 0169 4889C2   		movq	%rax, %rdx
 180 016c 488B45E8 		movq	-24(%rbp), %rax
 181 0170 488910   		movq	%rdx, (%rax)
  73:core.c        **** 		if ( !dst->data ) {
 182              		.loc 1 73 0
 183 0173 488B45E8 		movq	-24(%rbp), %rax
 184 0177 488B00   		movq	(%rax), %rax
 185 017a 4885C0   		testq	%rax, %rax
 186 017d 7522     		jne	.L9
  74:core.c        **** 			errRender(error, "Cannot allocate memory for buffer");
 187              		.loc 1 74 0
 188 017f 488B45D8 		movq	-40(%rbp), %rax
 189 0183 488D3500 		leaq	.LC0(%rip), %rsi
 189      000000
 190 018a 4889C7   		movq	%rax, %rdi
 191 018d B8000000 		movl	$0, %eax
 191      00
 192 0192 E8000000 		call	errRender@PLT
 192      00
  75:core.c        **** 			return BUF_NO_MEM;
 193              		.loc 1 75 0
 194 0197 B8010000 		movl	$1, %eax
 194      00
 195 019c E9940000 		jmp	.L10
 195      00
 196              	.L9:
  76:core.c        **** 		}
  77:core.c        **** 	}
  78:core.c        **** 	dst->length = src->length;
 197              		.loc 1 78 0
 198 01a1 488B45E0 		movq	-32(%rbp), %rax
 199 01a5 8B5008   		movl	8(%rax), %edx
 200 01a8 488B45E8 		movq	-24(%rbp), %rax
 201 01ac 895008   		movl	%edx, 8(%rax)
  79:core.c        **** 	dst->fill = src->fill;
 202              		.loc 1 79 0
 203 01af 488B45E0 		movq	-32(%rbp), %rax
 204 01b3 0FB65010 		movzbl	16(%rax), %edx
 205 01b7 488B45E8 		movq	-24(%rbp), %rax
 206 01bb 885010   		movb	%dl, 16(%rax)
  80:core.c        **** 	memcpy(dst->data, src->data, dst->length);
 207              		.loc 1 80 0
 208 01be 488B45E8 		movq	-24(%rbp), %rax
 209 01c2 8B4008   		movl	8(%rax), %eax
 210 01c5 89C2     		movl	%eax, %edx
 211 01c7 488B45E0 		movq	-32(%rbp), %rax
 212 01cb 488B08   		movq	(%rax), %rcx
 213 01ce 488B45E8 		movq	-24(%rbp), %rax
 214 01d2 488B00   		movq	(%rax), %rax
 215 01d5 4889CE   		movq	%rcx, %rsi
 216 01d8 4889C7   		movq	%rax, %rdi
 217 01db E8000000 		call	memcpy@PLT
 217      00
  81:core.c        **** 	ptr = dst->data + dst->length;
 218              		.loc 1 81 0
 219 01e0 488B45E8 		movq	-24(%rbp), %rax
 220 01e4 488B10   		movq	(%rax), %rdx
 221 01e7 488B45E8 		movq	-24(%rbp), %rax
 222 01eb 8B4008   		movl	8(%rax), %eax
 223 01ee 89C0     		movl	%eax, %eax
 224 01f0 4801D0   		addq	%rdx, %rax
 225 01f3 488945F0 		movq	%rax, -16(%rbp)
  82:core.c        **** 	endPtr = dst->data + dst->capacity;
 226              		.loc 1 82 0
 227 01f7 488B45E8 		movq	-24(%rbp), %rax
 228 01fb 488B10   		movq	(%rax), %rdx
 229 01fe 488B45E8 		movq	-24(%rbp), %rax
 230 0202 8B400C   		movl	12(%rax), %eax
 231 0205 89C0     		movl	%eax, %eax
 232 0207 4801D0   		addq	%rdx, %rax
 233 020a 488945F8 		movq	%rax, -8(%rbp)
  83:core.c        **** 	while ( ptr < endPtr ) {
 234              		.loc 1 83 0
 235 020e EB16     		jmp	.L11
 236              	.L12:
  84:core.c        **** 		*ptr++ = dst->fill;
 237              		.loc 1 84 0
 238 0210 488B45F0 		movq	-16(%rbp), %rax
 239 0214 488D5001 		leaq	1(%rax), %rdx
 240 0218 488955F0 		movq	%rdx, -16(%rbp)
 241 021c 488B55E8 		movq	-24(%rbp), %rdx
 242 0220 0FB65210 		movzbl	16(%rdx), %edx
 243 0224 8810     		movb	%dl, (%rax)
 244              	.L11:
  83:core.c        **** 	while ( ptr < endPtr ) {
 245              		.loc 1 83 0
 246 0226 488B45F0 		movq	-16(%rbp), %rax
 247 022a 483B45F8 		cmpq	-8(%rbp), %rax
 248 022e 72E0     		jb	.L12
  85:core.c        **** 	}
  86:core.c        **** 	return BUF_SUCCESS;
 249              		.loc 1 86 0
 250 0230 B8000000 		movl	$0, %eax
 250      00
 251              	.L10:
  87:core.c        **** }
 252              		.loc 1 87 0
 253 0235 C9       		leave
 254              		.cfi_def_cfa 7, 8
 255 0236 C3       		ret
 256              		.cfi_endproc
 257              	.LFE6:
 259              		.globl	bufSwap
 261              	bufSwap:
 262              	.LFB7:
  88:core.c        **** 
  89:core.c        **** DLLEXPORT(void) bufSwap(
  90:core.c        **** 	struct Buffer *x, struct Buffer *y)
  91:core.c        **** {
 263              		.loc 1 91 0
 264              		.cfi_startproc
 265 0237 55       		pushq	%rbp
 266              		.cfi_def_cfa_offset 16
 267              		.cfi_offset 6, -16
 268 0238 4889E5   		movq	%rsp, %rbp
 269              		.cfi_def_cfa_register 6
 270 023b 48897DD8 		movq	%rdi, -40(%rbp)
 271 023f 488975D0 		movq	%rsi, -48(%rbp)
  92:core.c        **** 	uint8 *const tmpData = x->data;
 272              		.loc 1 92 0
 273 0243 488B45D8 		movq	-40(%rbp), %rax
 274 0247 488B00   		movq	(%rax), %rax
 275 024a 488945F8 		movq	%rax, -8(%rbp)
  93:core.c        **** 	const uint32 tmpLength = x->length;
 276              		.loc 1 93 0
 277 024e 488B45D8 		movq	-40(%rbp), %rax
 278 0252 8B4008   		movl	8(%rax), %eax
 279 0255 8945F0   		movl	%eax, -16(%rbp)
  94:core.c        **** 	const uint32 tmpCapacity = x->capacity;
 280              		.loc 1 94 0
 281 0258 488B45D8 		movq	-40(%rbp), %rax
 282 025c 8B400C   		movl	12(%rax), %eax
 283 025f 8945F4   		movl	%eax, -12(%rbp)
  95:core.c        **** 	const uint8 tmpFill = x->fill;
 284              		.loc 1 95 0
 285 0262 488B45D8 		movq	-40(%rbp), %rax
 286 0266 0FB64010 		movzbl	16(%rax), %eax
 287 026a 8845EF   		movb	%al, -17(%rbp)
  96:core.c        **** 
  97:core.c        **** 	x->data = y->data;
 288              		.loc 1 97 0
 289 026d 488B45D0 		movq	-48(%rbp), %rax
 290 0271 488B10   		movq	(%rax), %rdx
 291 0274 488B45D8 		movq	-40(%rbp), %rax
 292 0278 488910   		movq	%rdx, (%rax)
  98:core.c        **** 	x->length = y->length;
 293              		.loc 1 98 0
 294 027b 488B45D0 		movq	-48(%rbp), %rax
 295 027f 8B5008   		movl	8(%rax), %edx
 296 0282 488B45D8 		movq	-40(%rbp), %rax
 297 0286 895008   		movl	%edx, 8(%rax)
  99:core.c        **** 	x->capacity = y->capacity;
 298              		.loc 1 99 0
 299 0289 488B45D0 		movq	-48(%rbp), %rax
 300 028d 8B500C   		movl	12(%rax), %edx
 301 0290 488B45D8 		movq	-40(%rbp), %rax
 302 0294 89500C   		movl	%edx, 12(%rax)
 100:core.c        **** 	x->fill = y->fill;
 303              		.loc 1 100 0
 304 0297 488B45D0 		movq	-48(%rbp), %rax
 305 029b 0FB65010 		movzbl	16(%rax), %edx
 306 029f 488B45D8 		movq	-40(%rbp), %rax
 307 02a3 885010   		movb	%dl, 16(%rax)
 101:core.c        **** 
 102:core.c        **** 	y->data = tmpData;
 308              		.loc 1 102 0
 309 02a6 488B45D0 		movq	-48(%rbp), %rax
 310 02aa 488B55F8 		movq	-8(%rbp), %rdx
 311 02ae 488910   		movq	%rdx, (%rax)
 103:core.c        **** 	y->length = tmpLength;
 312              		.loc 1 103 0
 313 02b1 488B45D0 		movq	-48(%rbp), %rax
 314 02b5 8B55F0   		movl	-16(%rbp), %edx
 315 02b8 895008   		movl	%edx, 8(%rax)
 104:core.c        **** 	y->capacity = tmpCapacity;
 316              		.loc 1 104 0
 317 02bb 488B45D0 		movq	-48(%rbp), %rax
 318 02bf 8B55F4   		movl	-12(%rbp), %edx
 319 02c2 89500C   		movl	%edx, 12(%rax)
 105:core.c        **** 	y->fill = tmpFill;
 320              		.loc 1 105 0
 321 02c5 488B45D0 		movq	-48(%rbp), %rax
 322 02c9 0FB655EF 		movzbl	-17(%rbp), %edx
 323 02cd 885010   		movb	%dl, 16(%rax)
 106:core.c        **** }
 324              		.loc 1 106 0
 325 02d0 5D       		popq	%rbp
 326              		.cfi_def_cfa 7, 8
 327 02d1 C3       		ret
 328              		.cfi_endproc
 329              	.LFE7:
 331              		.globl	bufZeroLength
 333              	bufZeroLength:
 334              	.LFB8:
 107:core.c        **** 
 108:core.c        **** // Clean the buffer structure so it can be reused.
 109:core.c        **** //
 110:core.c        **** DLLEXPORT(void) bufZeroLength(struct Buffer *self) {
 335              		.loc 1 110 0
 336              		.cfi_startproc
 337 02d2 55       		pushq	%rbp
 338              		.cfi_def_cfa_offset 16
 339              		.cfi_offset 6, -16
 340 02d3 4889E5   		movq	%rsp, %rbp
 341              		.cfi_def_cfa_register 6
 342 02d6 48897DE8 		movq	%rdi, -24(%rbp)
 111:core.c        **** 	uint32 i;
 112:core.c        **** 	self->length = 0;
 343              		.loc 1 112 0
 344 02da 488B45E8 		movq	-24(%rbp), %rax
 345 02de C7400800 		movl	$0, 8(%rax)
 345      000000
 113:core.c        **** 	for ( i = 0; i < self->capacity; i++ ) {
 346              		.loc 1 113 0
 347 02e5 C745FC00 		movl	$0, -4(%rbp)
 347      000000
 348 02ec EB1B     		jmp	.L15
 349              	.L16:
 114:core.c        **** 		self->data[i] = self->fill;
 350              		.loc 1 114 0 discriminator 3
 351 02ee 488B45E8 		movq	-24(%rbp), %rax
 352 02f2 488B10   		movq	(%rax), %rdx
 353 02f5 8B45FC   		movl	-4(%rbp), %eax
 354 02f8 4801C2   		addq	%rax, %rdx
 355 02fb 488B45E8 		movq	-24(%rbp), %rax
 356 02ff 0FB64010 		movzbl	16(%rax), %eax
 357 0303 8802     		movb	%al, (%rdx)
 113:core.c        **** 	for ( i = 0; i < self->capacity; i++ ) {
 358              		.loc 1 113 0 discriminator 3
 359 0305 8345FC01 		addl	$1, -4(%rbp)
 360              	.L15:
 113:core.c        **** 	for ( i = 0; i < self->capacity; i++ ) {
 361              		.loc 1 113 0 is_stmt 0 discriminator 1
 362 0309 488B45E8 		movq	-24(%rbp), %rax
 363 030d 8B400C   		movl	12(%rax), %eax
 364 0310 3B45FC   		cmpl	-4(%rbp), %eax
 365 0313 77D9     		ja	.L16
 115:core.c        **** 	}
 116:core.c        **** }
 366              		.loc 1 116 0 is_stmt 1
 367 0315 5D       		popq	%rbp
 368              		.cfi_def_cfa 7, 8
 369 0316 C3       		ret
 370              		.cfi_endproc
 371              	.LFE8:
 373              		.section	.rodata
 374 0022 00000000 		.align 8
 374      0000
 375              	.LC1:
 376 0028 43616E6E 		.string	"Cannot reallocate memory for buffer"
 376      6F742072 
 376      65616C6C 
 376      6F636174 
 376      65206D65 
 377              		.text
 379              	reallocate:
 380              	.LFB9:
 117:core.c        **** 
 118:core.c        **** // Reallocate the memory for the buffer by doubling the capacity and zeroing the extra storage.
 119:core.c        **** //
 120:core.c        **** static BufferStatus reallocate(
 121:core.c        **** 	struct Buffer *self, uint32 newCapacity, uint32 blockEnd, const char **error)
 122:core.c        **** {
 381              		.loc 1 122 0
 382              		.cfi_startproc
 383 0317 55       		pushq	%rbp
 384              		.cfi_def_cfa_offset 16
 385              		.cfi_offset 6, -16
 386 0318 4889E5   		movq	%rsp, %rbp
 387              		.cfi_def_cfa_register 6
 388 031b 4883EC30 		subq	$48, %rsp
 389 031f 48897DE8 		movq	%rdi, -24(%rbp)
 390 0323 8975E4   		movl	%esi, -28(%rbp)
 391 0326 8955E0   		movl	%edx, -32(%rbp)
 392 0329 48894DD8 		movq	%rcx, -40(%rbp)
 393              	.L18:
 123:core.c        **** 	// The data will not fit in the buffer - we need to make the buffer bigger
 124:core.c        **** 	//
 125:core.c        **** 	uint8 *ptr;
 126:core.c        **** 	const uint8 *endPtr;
 127:core.c        **** 	do {
 128:core.c        **** 		newCapacity *= 2;
 394              		.loc 1 128 0 discriminator 1
 395 032d D165E4   		sall	-28(%rbp)
 129:core.c        **** 	} while ( blockEnd > newCapacity );
 396              		.loc 1 129 0 discriminator 1
 397 0330 8B45E0   		movl	-32(%rbp), %eax
 398 0333 3B45E4   		cmpl	-28(%rbp), %eax
 399 0336 77F5     		ja	.L18
 130:core.c        **** 	self->data = (uint8 *)realloc(self->data, newCapacity);
 400              		.loc 1 130 0
 401 0338 8B55E4   		movl	-28(%rbp), %edx
 402 033b 488B45E8 		movq	-24(%rbp), %rax
 403 033f 488B00   		movq	(%rax), %rax
 404 0342 4889D6   		movq	%rdx, %rsi
 405 0345 4889C7   		movq	%rax, %rdi
 406 0348 E8000000 		call	realloc@PLT
 406      00
 407 034d 4889C2   		movq	%rax, %rdx
 408 0350 488B45E8 		movq	-24(%rbp), %rax
 409 0354 488910   		movq	%rdx, (%rax)
 131:core.c        **** 	if ( !self->data ) {
 410              		.loc 1 131 0
 411 0357 488B45E8 		movq	-24(%rbp), %rax
 412 035b 488B00   		movq	(%rax), %rax
 413 035e 4885C0   		testq	%rax, %rax
 414 0361 751F     		jne	.L19
 132:core.c        **** 		errRender(error, "Cannot reallocate memory for buffer");
 415              		.loc 1 132 0
 416 0363 488B45D8 		movq	-40(%rbp), %rax
 417 0367 488D3500 		leaq	.LC1(%rip), %rsi
 417      000000
 418 036e 4889C7   		movq	%rax, %rdi
 419 0371 B8000000 		movl	$0, %eax
 419      00
 420 0376 E8000000 		call	errRender@PLT
 420      00
 133:core.c        **** 		return BUF_NO_MEM;
 421              		.loc 1 133 0
 422 037b B8010000 		movl	$1, %eax
 422      00
 423 0380 EB53     		jmp	.L20
 424              	.L19:
 134:core.c        **** 	}
 135:core.c        **** 	self->capacity = newCapacity;
 425              		.loc 1 135 0
 426 0382 488B45E8 		movq	-24(%rbp), %rax
 427 0386 8B55E4   		movl	-28(%rbp), %edx
 428 0389 89500C   		movl	%edx, 12(%rax)
 136:core.c        **** 	
 137:core.c        **** 	// Now zero from the end of the block to the end of the new capacity
 138:core.c        **** 	//
 139:core.c        **** 	ptr = self->data + blockEnd;
 429              		.loc 1 139 0
 430 038c 488B45E8 		movq	-24(%rbp), %rax
 431 0390 488B10   		movq	(%rax), %rdx
 432 0393 8B45E0   		movl	-32(%rbp), %eax
 433 0396 4801D0   		addq	%rdx, %rax
 434 0399 488945F0 		movq	%rax, -16(%rbp)
 140:core.c        **** 	endPtr = self->data + newCapacity;
 435              		.loc 1 140 0
 436 039d 488B45E8 		movq	-24(%rbp), %rax
 437 03a1 488B10   		movq	(%rax), %rdx
 438 03a4 8B45E4   		movl	-28(%rbp), %eax
 439 03a7 4801D0   		addq	%rdx, %rax
 440 03aa 488945F8 		movq	%rax, -8(%rbp)
 141:core.c        **** 	while ( ptr < endPtr ) {
 441              		.loc 1 141 0
 442 03ae EB16     		jmp	.L21
 443              	.L22:
 142:core.c        **** 		*ptr++ = self->fill;
 444              		.loc 1 142 0
 445 03b0 488B45F0 		movq	-16(%rbp), %rax
 446 03b4 488D5001 		leaq	1(%rax), %rdx
 447 03b8 488955F0 		movq	%rdx, -16(%rbp)
 448 03bc 488B55E8 		movq	-24(%rbp), %rdx
 449 03c0 0FB65210 		movzbl	16(%rdx), %edx
 450 03c4 8810     		movb	%dl, (%rax)
 451              	.L21:
 141:core.c        **** 	while ( ptr < endPtr ) {
 452              		.loc 1 141 0
 453 03c6 488B45F0 		movq	-16(%rbp), %rax
 454 03ca 483B45F8 		cmpq	-8(%rbp), %rax
 455 03ce 72E0     		jb	.L22
 143:core.c        **** 	}
 144:core.c        **** 	return BUF_SUCCESS;
 456              		.loc 1 144 0
 457 03d0 B8000000 		movl	$0, %eax
 457      00
 458              	.L20:
 145:core.c        **** }
 459              		.loc 1 145 0
 460 03d5 C9       		leave
 461              		.cfi_def_cfa 7, 8
 462 03d6 C3       		ret
 463              		.cfi_endproc
 464              	.LFE9:
 466              		.globl	bufAppendByte
 468              	bufAppendByte:
 469              	.LFB10:
 146:core.c        **** 
 147:core.c        **** // If the data will not fit in the buffer, make the buffer bigger
 148:core.c        **** //
 149:core.c        **** #define ENSURE_CAPACITY() \
 150:core.c        **** 	if ( blockEnd > self->capacity ) { \
 151:core.c        **** 		BufferStatus status = reallocate(self, self->capacity, blockEnd, error); \
 152:core.c        **** 		if ( status != BUF_SUCCESS ) { \
 153:core.c        **** 			return status; \
 154:core.c        **** 		} \
 155:core.c        **** 	}
 156:core.c        **** 
 157:core.c        **** DLLEXPORT(BufferStatus) bufAppendByte(struct Buffer *self, uint8 byte, const char **error) {
 470              		.loc 1 157 0
 471              		.cfi_startproc
 472 03d7 55       		pushq	%rbp
 473              		.cfi_def_cfa_offset 16
 474              		.cfi_offset 6, -16
 475 03d8 4889E5   		movq	%rsp, %rbp
 476              		.cfi_def_cfa_register 6
 477 03db 4883EC30 		subq	$48, %rsp
 478 03df 48897DE8 		movq	%rdi, -24(%rbp)
 479 03e3 89F0     		movl	%esi, %eax
 480 03e5 488955D8 		movq	%rdx, -40(%rbp)
 481 03e9 8845E4   		movb	%al, -28(%rbp)
 158:core.c        **** 	const uint32 blockEnd = self->length + 1;
 482              		.loc 1 158 0
 483 03ec 488B45E8 		movq	-24(%rbp), %rax
 484 03f0 8B4008   		movl	8(%rax), %eax
 485 03f3 83C001   		addl	$1, %eax
 486 03f6 8945F8   		movl	%eax, -8(%rbp)
 159:core.c        **** 	ENSURE_CAPACITY();
 487              		.loc 1 159 0
 488 03f9 488B45E8 		movq	-24(%rbp), %rax
 489 03fd 8B400C   		movl	12(%rax), %eax
 490 0400 3B45F8   		cmpl	-8(%rbp), %eax
 491 0403 7328     		jnb	.L24
 492              	.LBB2:
 493              		.loc 1 159 0 is_stmt 0 discriminator 1
 494 0405 488B45E8 		movq	-24(%rbp), %rax
 495 0409 8B700C   		movl	12(%rax), %esi
 496 040c 488B4DD8 		movq	-40(%rbp), %rcx
 497 0410 8B55F8   		movl	-8(%rbp), %edx
 498 0413 488B45E8 		movq	-24(%rbp), %rax
 499 0417 4889C7   		movq	%rax, %rdi
 500 041a E8F8FEFF 		call	reallocate
 500      FF
 501 041f 8945FC   		movl	%eax, -4(%rbp)
 502 0422 837DFC00 		cmpl	$0, -4(%rbp)
 503 0426 7405     		je	.L24
 504              		.loc 1 159 0 discriminator 2
 505 0428 8B45FC   		movl	-4(%rbp), %eax
 506 042b EB2F     		jmp	.L25
 507              	.L24:
 508              	.LBE2:
 160:core.c        **** 	*(self->data + self->length) = byte;
 509              		.loc 1 160 0 is_stmt 1
 510 042d 488B45E8 		movq	-24(%rbp), %rax
 511 0431 488B10   		movq	(%rax), %rdx
 512 0434 488B45E8 		movq	-24(%rbp), %rax
 513 0438 8B4008   		movl	8(%rax), %eax
 514 043b 89C0     		movl	%eax, %eax
 515 043d 4801C2   		addq	%rax, %rdx
 516 0440 0FB645E4 		movzbl	-28(%rbp), %eax
 517 0444 8802     		movb	%al, (%rdx)
 161:core.c        **** 	self->length++;
 518              		.loc 1 161 0
 519 0446 488B45E8 		movq	-24(%rbp), %rax
 520 044a 8B4008   		movl	8(%rax), %eax
 521 044d 8D5001   		leal	1(%rax), %edx
 522 0450 488B45E8 		movq	-24(%rbp), %rax
 523 0454 895008   		movl	%edx, 8(%rax)
 162:core.c        **** 	return BUF_SUCCESS;
 524              		.loc 1 162 0
 525 0457 B8000000 		movl	$0, %eax
 525      00
 526              	.L25:
 163:core.c        **** }
 527              		.loc 1 163 0
 528 045c C9       		leave
 529              		.cfi_def_cfa 7, 8
 530 045d C3       		ret
 531              		.cfi_endproc
 532              	.LFE10:
 534              		.globl	bufAppendWordLE
 536              	bufAppendWordLE:
 537              	.LFB11:
 164:core.c        **** 
 165:core.c        **** DLLEXPORT(BufferStatus) bufAppendWordLE(struct Buffer *self, uint16 word, const char **error) {
 538              		.loc 1 165 0
 539              		.cfi_startproc
 540 045e 55       		pushq	%rbp
 541              		.cfi_def_cfa_offset 16
 542              		.cfi_offset 6, -16
 543 045f 4889E5   		movq	%rsp, %rbp
 544              		.cfi_def_cfa_register 6
 545 0462 4883EC40 		subq	$64, %rsp
 546 0466 48897DD8 		movq	%rdi, -40(%rbp)
 547 046a 89F0     		movl	%esi, %eax
 548 046c 488955C8 		movq	%rdx, -56(%rbp)
 549 0470 668945D4 		movw	%ax, -44(%rbp)
 550              		.loc 1 165 0
 551 0474 64488B04 		movq	%fs:40, %rax
 551      25280000 
 551      00
 552 047d 488945F8 		movq	%rax, -8(%rbp)
 553 0481 31C0     		xorl	%eax, %eax
 166:core.c        **** 	const uint32 blockEnd = self->length + 2;
 554              		.loc 1 166 0
 555 0483 488B45D8 		movq	-40(%rbp), %rax
 556 0487 8B4008   		movl	8(%rax), %eax
 557 048a 83C002   		addl	$2, %eax
 558 048d 8945F0   		movl	%eax, -16(%rbp)
 167:core.c        **** 	union {
 168:core.c        **** 		uint16 word;
 169:core.c        **** 		uint8 byte[2];
 170:core.c        **** 	} u;
 171:core.c        **** 	u.word = word;
 559              		.loc 1 171 0
 560 0490 0FB745D4 		movzwl	-44(%rbp), %eax
 561 0494 668945E0 		movw	%ax, -32(%rbp)
 172:core.c        **** 	ENSURE_CAPACITY();
 562              		.loc 1 172 0
 563 0498 488B45D8 		movq	-40(%rbp), %rax
 564 049c 8B400C   		movl	12(%rax), %eax
 565 049f 3B45F0   		cmpl	-16(%rbp), %eax
 566 04a2 7328     		jnb	.L27
 567              	.LBB3:
 568              		.loc 1 172 0 is_stmt 0 discriminator 1
 569 04a4 488B45D8 		movq	-40(%rbp), %rax
 570 04a8 8B700C   		movl	12(%rax), %esi
 571 04ab 488B4DC8 		movq	-56(%rbp), %rcx
 572 04af 8B55F0   		movl	-16(%rbp), %edx
 573 04b2 488B45D8 		movq	-40(%rbp), %rax
 574 04b6 4889C7   		movq	%rax, %rdi
 575 04b9 E859FEFF 		call	reallocate
 575      FF
 576 04be 8945F4   		movl	%eax, -12(%rbp)
 577 04c1 837DF400 		cmpl	$0, -12(%rbp)
 578 04c5 7405     		je	.L27
 579              		.loc 1 172 0 discriminator 2
 580 04c7 8B45F4   		movl	-12(%rbp), %eax
 581 04ca EB4C     		jmp	.L29
 582              	.L27:
 583              	.LBE3:
 173:core.c        **** 	#if BYTE_ORDER == 1234
 174:core.c        **** 		*(self->data + self->length) = u.byte[0];
 584              		.loc 1 174 0 is_stmt 1
 585 04cc 488B45D8 		movq	-40(%rbp), %rax
 586 04d0 488B10   		movq	(%rax), %rdx
 587 04d3 488B45D8 		movq	-40(%rbp), %rax
 588 04d7 8B4008   		movl	8(%rax), %eax
 589 04da 89C0     		movl	%eax, %eax
 590 04dc 4801C2   		addq	%rax, %rdx
 591 04df 0FB645E0 		movzbl	-32(%rbp), %eax
 592 04e3 8802     		movb	%al, (%rdx)
 175:core.c        **** 		*(self->data + self->length + 1) = u.byte[1];
 593              		.loc 1 175 0
 594 04e5 488B45D8 		movq	-40(%rbp), %rax
 595 04e9 488B10   		movq	(%rax), %rdx
 596 04ec 488B45D8 		movq	-40(%rbp), %rax
 597 04f0 8B4008   		movl	8(%rax), %eax
 598 04f3 89C0     		movl	%eax, %eax
 599 04f5 4883C001 		addq	$1, %rax
 600 04f9 4801C2   		addq	%rax, %rdx
 601 04fc 0FB645E1 		movzbl	-31(%rbp), %eax
 602 0500 8802     		movb	%al, (%rdx)
 176:core.c        **** 	#else
 177:core.c        **** 		*(self->data + self->length) = u.byte[1];
 178:core.c        **** 		*(self->data + self->length + 1) = u.byte[0];
 179:core.c        **** 	#endif
 180:core.c        **** 	self->length += 2;
 603              		.loc 1 180 0
 604 0502 488B45D8 		movq	-40(%rbp), %rax
 605 0506 8B4008   		movl	8(%rax), %eax
 606 0509 8D5002   		leal	2(%rax), %edx
 607 050c 488B45D8 		movq	-40(%rbp), %rax
 608 0510 895008   		movl	%edx, 8(%rax)
 181:core.c        **** 	return BUF_SUCCESS;
 609              		.loc 1 181 0
 610 0513 B8000000 		movl	$0, %eax
 610      00
 611              	.L29:
 182:core.c        **** }
 612              		.loc 1 182 0 discriminator 1
 613 0518 488B7DF8 		movq	-8(%rbp), %rdi
 614 051c 6448333C 		xorq	%fs:40, %rdi
 614      25280000 
 614      00
 615 0525 7405     		je	.L30
 616              		.loc 1 182 0 is_stmt 0
 617 0527 E8000000 		call	__stack_chk_fail@PLT
 617      00
 618              	.L30:
 619 052c C9       		leave
 620              		.cfi_def_cfa 7, 8
 621 052d C3       		ret
 622              		.cfi_endproc
 623              	.LFE11:
 625              		.globl	bufAppendWordBE
 627              	bufAppendWordBE:
 628              	.LFB12:
 183:core.c        **** 
 184:core.c        **** DLLEXPORT(BufferStatus) bufAppendWordBE(struct Buffer *self, uint16 word, const char **error) {
 629              		.loc 1 184 0 is_stmt 1
 630              		.cfi_startproc
 631 052e 55       		pushq	%rbp
 632              		.cfi_def_cfa_offset 16
 633              		.cfi_offset 6, -16
 634 052f 4889E5   		movq	%rsp, %rbp
 635              		.cfi_def_cfa_register 6
 636 0532 4883EC40 		subq	$64, %rsp
 637 0536 48897DD8 		movq	%rdi, -40(%rbp)
 638 053a 89F0     		movl	%esi, %eax
 639 053c 488955C8 		movq	%rdx, -56(%rbp)
 640 0540 668945D4 		movw	%ax, -44(%rbp)
 641              		.loc 1 184 0
 642 0544 64488B04 		movq	%fs:40, %rax
 642      25280000 
 642      00
 643 054d 488945F8 		movq	%rax, -8(%rbp)
 644 0551 31C0     		xorl	%eax, %eax
 185:core.c        **** 	const uint32 blockEnd = self->length + 2;
 645              		.loc 1 185 0
 646 0553 488B45D8 		movq	-40(%rbp), %rax
 647 0557 8B4008   		movl	8(%rax), %eax
 648 055a 83C002   		addl	$2, %eax
 649 055d 8945F0   		movl	%eax, -16(%rbp)
 186:core.c        **** 	union {
 187:core.c        **** 		uint16 word;
 188:core.c        **** 		uint8 byte[2];
 189:core.c        **** 	} u;
 190:core.c        **** 	u.word = word;
 650              		.loc 1 190 0
 651 0560 0FB745D4 		movzwl	-44(%rbp), %eax
 652 0564 668945E0 		movw	%ax, -32(%rbp)
 191:core.c        **** 	ENSURE_CAPACITY();
 653              		.loc 1 191 0
 654 0568 488B45D8 		movq	-40(%rbp), %rax
 655 056c 8B400C   		movl	12(%rax), %eax
 656 056f 3B45F0   		cmpl	-16(%rbp), %eax
 657 0572 7328     		jnb	.L32
 658              	.LBB4:
 659              		.loc 1 191 0 is_stmt 0 discriminator 1
 660 0574 488B45D8 		movq	-40(%rbp), %rax
 661 0578 8B700C   		movl	12(%rax), %esi
 662 057b 488B4DC8 		movq	-56(%rbp), %rcx
 663 057f 8B55F0   		movl	-16(%rbp), %edx
 664 0582 488B45D8 		movq	-40(%rbp), %rax
 665 0586 4889C7   		movq	%rax, %rdi
 666 0589 E889FDFF 		call	reallocate
 666      FF
 667 058e 8945F4   		movl	%eax, -12(%rbp)
 668 0591 837DF400 		cmpl	$0, -12(%rbp)
 669 0595 7405     		je	.L32
 670              		.loc 1 191 0 discriminator 2
 671 0597 8B45F4   		movl	-12(%rbp), %eax
 672 059a EB4C     		jmp	.L34
 673              	.L32:
 674              	.LBE4:
 192:core.c        **** 	#if BYTE_ORDER == 1234
 193:core.c        **** 		*(self->data + self->length) = u.byte[1];
 675              		.loc 1 193 0 is_stmt 1
 676 059c 488B45D8 		movq	-40(%rbp), %rax
 677 05a0 488B10   		movq	(%rax), %rdx
 678 05a3 488B45D8 		movq	-40(%rbp), %rax
 679 05a7 8B4008   		movl	8(%rax), %eax
 680 05aa 89C0     		movl	%eax, %eax
 681 05ac 4801C2   		addq	%rax, %rdx
 682 05af 0FB645E1 		movzbl	-31(%rbp), %eax
 683 05b3 8802     		movb	%al, (%rdx)
 194:core.c        **** 		*(self->data + self->length + 1) = u.byte[0];
 684              		.loc 1 194 0
 685 05b5 488B45D8 		movq	-40(%rbp), %rax
 686 05b9 488B10   		movq	(%rax), %rdx
 687 05bc 488B45D8 		movq	-40(%rbp), %rax
 688 05c0 8B4008   		movl	8(%rax), %eax
 689 05c3 89C0     		movl	%eax, %eax
 690 05c5 4883C001 		addq	$1, %rax
 691 05c9 4801C2   		addq	%rax, %rdx
 692 05cc 0FB645E0 		movzbl	-32(%rbp), %eax
 693 05d0 8802     		movb	%al, (%rdx)
 195:core.c        **** 	#else
 196:core.c        **** 		*(self->data + self->length) = u.byte[0];
 197:core.c        **** 		*(self->data + self->length + 1) = u.byte[1];
 198:core.c        **** 	#endif
 199:core.c        **** 	self->length += 2;
 694              		.loc 1 199 0
 695 05d2 488B45D8 		movq	-40(%rbp), %rax
 696 05d6 8B4008   		movl	8(%rax), %eax
 697 05d9 8D5002   		leal	2(%rax), %edx
 698 05dc 488B45D8 		movq	-40(%rbp), %rax
 699 05e0 895008   		movl	%edx, 8(%rax)
 200:core.c        **** 	return BUF_SUCCESS;
 700              		.loc 1 200 0
 701 05e3 B8000000 		movl	$0, %eax
 701      00
 702              	.L34:
 201:core.c        **** }
 703              		.loc 1 201 0 discriminator 1
 704 05e8 488B7DF8 		movq	-8(%rbp), %rdi
 705 05ec 6448333C 		xorq	%fs:40, %rdi
 705      25280000 
 705      00
 706 05f5 7405     		je	.L35
 707              		.loc 1 201 0 is_stmt 0
 708 05f7 E8000000 		call	__stack_chk_fail@PLT
 708      00
 709              	.L35:
 710 05fc C9       		leave
 711              		.cfi_def_cfa 7, 8
 712 05fd C3       		ret
 713              		.cfi_endproc
 714              	.LFE12:
 716              		.globl	bufAppendLongLE
 718              	bufAppendLongLE:
 719              	.LFB13:
 202:core.c        **** 
 203:core.c        **** DLLEXPORT(BufferStatus) bufAppendLongLE(struct Buffer *self, uint32 lword, const char **error) {
 720              		.loc 1 203 0 is_stmt 1
 721              		.cfi_startproc
 722 05fe 55       		pushq	%rbp
 723              		.cfi_def_cfa_offset 16
 724              		.cfi_offset 6, -16
 725 05ff 4889E5   		movq	%rsp, %rbp
 726              		.cfi_def_cfa_register 6
 727 0602 4883EC40 		subq	$64, %rsp
 728 0606 48897DD8 		movq	%rdi, -40(%rbp)
 729 060a 8975D4   		movl	%esi, -44(%rbp)
 730 060d 488955C8 		movq	%rdx, -56(%rbp)
 731              		.loc 1 203 0
 732 0611 64488B04 		movq	%fs:40, %rax
 732      25280000 
 732      00
 733 061a 488945F8 		movq	%rax, -8(%rbp)
 734 061e 31C0     		xorl	%eax, %eax
 204:core.c        **** 	const uint32 blockEnd = self->length + 4;
 735              		.loc 1 204 0
 736 0620 488B45D8 		movq	-40(%rbp), %rax
 737 0624 8B4008   		movl	8(%rax), %eax
 738 0627 83C004   		addl	$4, %eax
 739 062a 8945F0   		movl	%eax, -16(%rbp)
 205:core.c        **** 	union {
 206:core.c        **** 		uint32 lword;
 207:core.c        **** 		uint8 byte[4];
 208:core.c        **** 	} u;
 209:core.c        **** 	u.lword = lword;
 740              		.loc 1 209 0
 741 062d 8B45D4   		movl	-44(%rbp), %eax
 742 0630 8945E0   		movl	%eax, -32(%rbp)
 210:core.c        **** 	ENSURE_CAPACITY();
 743              		.loc 1 210 0
 744 0633 488B45D8 		movq	-40(%rbp), %rax
 745 0637 8B400C   		movl	12(%rax), %eax
 746 063a 3B45F0   		cmpl	-16(%rbp), %eax
 747 063d 732B     		jnb	.L37
 748              	.LBB5:
 749              		.loc 1 210 0 is_stmt 0 discriminator 1
 750 063f 488B45D8 		movq	-40(%rbp), %rax
 751 0643 8B700C   		movl	12(%rax), %esi
 752 0646 488B4DC8 		movq	-56(%rbp), %rcx
 753 064a 8B55F0   		movl	-16(%rbp), %edx
 754 064d 488B45D8 		movq	-40(%rbp), %rax
 755 0651 4889C7   		movq	%rax, %rdi
 756 0654 E8BEFCFF 		call	reallocate
 756      FF
 757 0659 8945F4   		movl	%eax, -12(%rbp)
 758 065c 837DF400 		cmpl	$0, -12(%rbp)
 759 0660 7408     		je	.L37
 760              		.loc 1 210 0 discriminator 2
 761 0662 8B45F4   		movl	-12(%rbp), %eax
 762 0665 E9860000 		jmp	.L39
 762      00
 763              	.L37:
 764              	.LBE5:
 211:core.c        **** 	#if BYTE_ORDER == 1234
 212:core.c        **** 		*(self->data + self->length) = u.byte[0];
 765              		.loc 1 212 0 is_stmt 1
 766 066a 488B45D8 		movq	-40(%rbp), %rax
 767 066e 488B10   		movq	(%rax), %rdx
 768 0671 488B45D8 		movq	-40(%rbp), %rax
 769 0675 8B4008   		movl	8(%rax), %eax
 770 0678 89C0     		movl	%eax, %eax
 771 067a 4801C2   		addq	%rax, %rdx
 772 067d 0FB645E0 		movzbl	-32(%rbp), %eax
 773 0681 8802     		movb	%al, (%rdx)
 213:core.c        **** 		*(self->data + self->length + 1) = u.byte[1];
 774              		.loc 1 213 0
 775 0683 488B45D8 		movq	-40(%rbp), %rax
 776 0687 488B10   		movq	(%rax), %rdx
 777 068a 488B45D8 		movq	-40(%rbp), %rax
 778 068e 8B4008   		movl	8(%rax), %eax
 779 0691 89C0     		movl	%eax, %eax
 780 0693 4883C001 		addq	$1, %rax
 781 0697 4801C2   		addq	%rax, %rdx
 782 069a 0FB645E1 		movzbl	-31(%rbp), %eax
 783 069e 8802     		movb	%al, (%rdx)
 214:core.c        **** 		*(self->data + self->length + 2) = u.byte[2];
 784              		.loc 1 214 0
 785 06a0 488B45D8 		movq	-40(%rbp), %rax
 786 06a4 488B10   		movq	(%rax), %rdx
 787 06a7 488B45D8 		movq	-40(%rbp), %rax
 788 06ab 8B4008   		movl	8(%rax), %eax
 789 06ae 89C0     		movl	%eax, %eax
 790 06b0 4883C002 		addq	$2, %rax
 791 06b4 4801C2   		addq	%rax, %rdx
 792 06b7 0FB645E2 		movzbl	-30(%rbp), %eax
 793 06bb 8802     		movb	%al, (%rdx)
 215:core.c        **** 		*(self->data + self->length + 3) = u.byte[3];
 794              		.loc 1 215 0
 795 06bd 488B45D8 		movq	-40(%rbp), %rax
 796 06c1 488B10   		movq	(%rax), %rdx
 797 06c4 488B45D8 		movq	-40(%rbp), %rax
 798 06c8 8B4008   		movl	8(%rax), %eax
 799 06cb 89C0     		movl	%eax, %eax
 800 06cd 4883C003 		addq	$3, %rax
 801 06d1 4801C2   		addq	%rax, %rdx
 802 06d4 0FB645E3 		movzbl	-29(%rbp), %eax
 803 06d8 8802     		movb	%al, (%rdx)
 216:core.c        **** 	#else
 217:core.c        **** 		*(self->data + self->length) = u.byte[3];
 218:core.c        **** 		*(self->data + self->length + 1) = u.byte[2];
 219:core.c        **** 		*(self->data + self->length + 2) = u.byte[1];
 220:core.c        **** 		*(self->data + self->length + 3) = u.byte[0];
 221:core.c        **** 	#endif
 222:core.c        **** 	self->length += 4;
 804              		.loc 1 222 0
 805 06da 488B45D8 		movq	-40(%rbp), %rax
 806 06de 8B4008   		movl	8(%rax), %eax
 807 06e1 8D5004   		leal	4(%rax), %edx
 808 06e4 488B45D8 		movq	-40(%rbp), %rax
 809 06e8 895008   		movl	%edx, 8(%rax)
 223:core.c        **** 	return BUF_SUCCESS;
 810              		.loc 1 223 0
 811 06eb B8000000 		movl	$0, %eax
 811      00
 812              	.L39:
 224:core.c        **** }
 813              		.loc 1 224 0 discriminator 1
 814 06f0 488B7DF8 		movq	-8(%rbp), %rdi
 815 06f4 6448333C 		xorq	%fs:40, %rdi
 815      25280000 
 815      00
 816 06fd 7405     		je	.L40
 817              		.loc 1 224 0 is_stmt 0
 818 06ff E8000000 		call	__stack_chk_fail@PLT
 818      00
 819              	.L40:
 820 0704 C9       		leave
 821              		.cfi_def_cfa 7, 8
 822 0705 C3       		ret
 823              		.cfi_endproc
 824              	.LFE13:
 826              		.globl	bufAppendLongBE
 828              	bufAppendLongBE:
 829              	.LFB14:
 225:core.c        **** 
 226:core.c        **** DLLEXPORT(BufferStatus) bufAppendLongBE(struct Buffer *self, uint32 lword, const char **error) {
 830              		.loc 1 226 0 is_stmt 1
 831              		.cfi_startproc
 832 0706 55       		pushq	%rbp
 833              		.cfi_def_cfa_offset 16
 834              		.cfi_offset 6, -16
 835 0707 4889E5   		movq	%rsp, %rbp
 836              		.cfi_def_cfa_register 6
 837 070a 4883EC40 		subq	$64, %rsp
 838 070e 48897DD8 		movq	%rdi, -40(%rbp)
 839 0712 8975D4   		movl	%esi, -44(%rbp)
 840 0715 488955C8 		movq	%rdx, -56(%rbp)
 841              		.loc 1 226 0
 842 0719 64488B04 		movq	%fs:40, %rax
 842      25280000 
 842      00
 843 0722 488945F8 		movq	%rax, -8(%rbp)
 844 0726 31C0     		xorl	%eax, %eax
 227:core.c        **** 	const uint32 blockEnd = self->length + 4;
 845              		.loc 1 227 0
 846 0728 488B45D8 		movq	-40(%rbp), %rax
 847 072c 8B4008   		movl	8(%rax), %eax
 848 072f 83C004   		addl	$4, %eax
 849 0732 8945F0   		movl	%eax, -16(%rbp)
 228:core.c        **** 	union {
 229:core.c        **** 		uint32 lword;
 230:core.c        **** 		uint8 byte[4];
 231:core.c        **** 	} u;
 232:core.c        **** 	u.lword = lword;
 850              		.loc 1 232 0
 851 0735 8B45D4   		movl	-44(%rbp), %eax
 852 0738 8945E0   		movl	%eax, -32(%rbp)
 233:core.c        **** 	ENSURE_CAPACITY();
 853              		.loc 1 233 0
 854 073b 488B45D8 		movq	-40(%rbp), %rax
 855 073f 8B400C   		movl	12(%rax), %eax
 856 0742 3B45F0   		cmpl	-16(%rbp), %eax
 857 0745 732B     		jnb	.L42
 858              	.LBB6:
 859              		.loc 1 233 0 is_stmt 0 discriminator 1
 860 0747 488B45D8 		movq	-40(%rbp), %rax
 861 074b 8B700C   		movl	12(%rax), %esi
 862 074e 488B4DC8 		movq	-56(%rbp), %rcx
 863 0752 8B55F0   		movl	-16(%rbp), %edx
 864 0755 488B45D8 		movq	-40(%rbp), %rax
 865 0759 4889C7   		movq	%rax, %rdi
 866 075c E8B6FBFF 		call	reallocate
 866      FF
 867 0761 8945F4   		movl	%eax, -12(%rbp)
 868 0764 837DF400 		cmpl	$0, -12(%rbp)
 869 0768 7408     		je	.L42
 870              		.loc 1 233 0 discriminator 2
 871 076a 8B45F4   		movl	-12(%rbp), %eax
 872 076d E9860000 		jmp	.L44
 872      00
 873              	.L42:
 874              	.LBE6:
 234:core.c        **** 	#if BYTE_ORDER == 1234
 235:core.c        **** 		*(self->data + self->length) = u.byte[3];
 875              		.loc 1 235 0 is_stmt 1
 876 0772 488B45D8 		movq	-40(%rbp), %rax
 877 0776 488B10   		movq	(%rax), %rdx
 878 0779 488B45D8 		movq	-40(%rbp), %rax
 879 077d 8B4008   		movl	8(%rax), %eax
 880 0780 89C0     		movl	%eax, %eax
 881 0782 4801C2   		addq	%rax, %rdx
 882 0785 0FB645E3 		movzbl	-29(%rbp), %eax
 883 0789 8802     		movb	%al, (%rdx)
 236:core.c        **** 		*(self->data + self->length + 1) = u.byte[2];
 884              		.loc 1 236 0
 885 078b 488B45D8 		movq	-40(%rbp), %rax
 886 078f 488B10   		movq	(%rax), %rdx
 887 0792 488B45D8 		movq	-40(%rbp), %rax
 888 0796 8B4008   		movl	8(%rax), %eax
 889 0799 89C0     		movl	%eax, %eax
 890 079b 4883C001 		addq	$1, %rax
 891 079f 4801C2   		addq	%rax, %rdx
 892 07a2 0FB645E2 		movzbl	-30(%rbp), %eax
 893 07a6 8802     		movb	%al, (%rdx)
 237:core.c        **** 		*(self->data + self->length + 2) = u.byte[1];
 894              		.loc 1 237 0
 895 07a8 488B45D8 		movq	-40(%rbp), %rax
 896 07ac 488B10   		movq	(%rax), %rdx
 897 07af 488B45D8 		movq	-40(%rbp), %rax
 898 07b3 8B4008   		movl	8(%rax), %eax
 899 07b6 89C0     		movl	%eax, %eax
 900 07b8 4883C002 		addq	$2, %rax
 901 07bc 4801C2   		addq	%rax, %rdx
 902 07bf 0FB645E1 		movzbl	-31(%rbp), %eax
 903 07c3 8802     		movb	%al, (%rdx)
 238:core.c        **** 		*(self->data + self->length + 3) = u.byte[0];
 904              		.loc 1 238 0
 905 07c5 488B45D8 		movq	-40(%rbp), %rax
 906 07c9 488B10   		movq	(%rax), %rdx
 907 07cc 488B45D8 		movq	-40(%rbp), %rax
 908 07d0 8B4008   		movl	8(%rax), %eax
 909 07d3 89C0     		movl	%eax, %eax
 910 07d5 4883C003 		addq	$3, %rax
 911 07d9 4801C2   		addq	%rax, %rdx
 912 07dc 0FB645E0 		movzbl	-32(%rbp), %eax
 913 07e0 8802     		movb	%al, (%rdx)
 239:core.c        **** 	#else
 240:core.c        **** 		*(self->data + self->length) = u.byte[0];
 241:core.c        **** 		*(self->data + self->length + 1) = u.byte[1];
 242:core.c        **** 		*(self->data + self->length + 2) = u.byte[2];
 243:core.c        **** 		*(self->data + self->length + 3) = u.byte[3];
 244:core.c        **** 	#endif
 245:core.c        **** 	self->length += 4;
 914              		.loc 1 245 0
 915 07e2 488B45D8 		movq	-40(%rbp), %rax
 916 07e6 8B4008   		movl	8(%rax), %eax
 917 07e9 8D5004   		leal	4(%rax), %edx
 918 07ec 488B45D8 		movq	-40(%rbp), %rax
 919 07f0 895008   		movl	%edx, 8(%rax)
 246:core.c        **** 	return BUF_SUCCESS;
 920              		.loc 1 246 0
 921 07f3 B8000000 		movl	$0, %eax
 921      00
 922              	.L44:
 247:core.c        **** }
 923              		.loc 1 247 0 discriminator 1
 924 07f8 488B7DF8 		movq	-8(%rbp), %rdi
 925 07fc 6448333C 		xorq	%fs:40, %rdi
 925      25280000 
 925      00
 926 0805 7405     		je	.L45
 927              		.loc 1 247 0 is_stmt 0
 928 0807 E8000000 		call	__stack_chk_fail@PLT
 928      00
 929              	.L45:
 930 080c C9       		leave
 931              		.cfi_def_cfa 7, 8
 932 080d C3       		ret
 933              		.cfi_endproc
 934              	.LFE14:
 936              		.globl	bufAppendConst
 938              	bufAppendConst:
 939              	.LFB15:
 248:core.c        **** 
 249:core.c        **** // Append a block of a given constant to the end of the buffer, and return a ptr to the next free
 250:core.c        **** // byte after the end.
 251:core.c        **** //
 252:core.c        **** DLLEXPORT(BufferStatus) bufAppendConst(
 253:core.c        **** 	struct Buffer *self, uint8 value, uint32 count, const char **error)
 254:core.c        **** {
 940              		.loc 1 254 0 is_stmt 1
 941              		.cfi_startproc
 942 080e 55       		pushq	%rbp
 943              		.cfi_def_cfa_offset 16
 944              		.cfi_offset 6, -16
 945 080f 4889E5   		movq	%rsp, %rbp
 946              		.cfi_def_cfa_register 6
 947 0812 4883EC30 		subq	$48, %rsp
 948 0816 48897DE8 		movq	%rdi, -24(%rbp)
 949 081a 89F0     		movl	%esi, %eax
 950 081c 8955E0   		movl	%edx, -32(%rbp)
 951 081f 48894DD8 		movq	%rcx, -40(%rbp)
 952 0823 8845E4   		movb	%al, -28(%rbp)
 255:core.c        **** 	const uint32 blockEnd = self->length + count;
 953              		.loc 1 255 0
 954 0826 488B45E8 		movq	-24(%rbp), %rax
 955 082a 8B5008   		movl	8(%rax), %edx
 956 082d 8B45E0   		movl	-32(%rbp), %eax
 957 0830 01D0     		addl	%edx, %eax
 958 0832 8945F8   		movl	%eax, -8(%rbp)
 256:core.c        **** 	ENSURE_CAPACITY();
 959              		.loc 1 256 0
 960 0835 488B45E8 		movq	-24(%rbp), %rax
 961 0839 8B400C   		movl	12(%rax), %eax
 962 083c 3B45F8   		cmpl	-8(%rbp), %eax
 963 083f 7328     		jnb	.L47
 964              	.LBB7:
 965              		.loc 1 256 0 is_stmt 0 discriminator 1
 966 0841 488B45E8 		movq	-24(%rbp), %rax
 967 0845 8B700C   		movl	12(%rax), %esi
 968 0848 488B4DD8 		movq	-40(%rbp), %rcx
 969 084c 8B55F8   		movl	-8(%rbp), %edx
 970 084f 488B45E8 		movq	-24(%rbp), %rax
 971 0853 4889C7   		movq	%rax, %rdi
 972 0856 E8BCFAFF 		call	reallocate
 972      FF
 973 085b 8945FC   		movl	%eax, -4(%rbp)
 974 085e 837DFC00 		cmpl	$0, -4(%rbp)
 975 0862 7405     		je	.L47
 976              		.loc 1 256 0 discriminator 2
 977 0864 8B45FC   		movl	-4(%rbp), %eax
 978 0867 EB33     		jmp	.L48
 979              	.L47:
 980              	.LBE7:
 257:core.c        **** 	memset(self->data + self->length, value, count);
 981              		.loc 1 257 0 is_stmt 1
 982 0869 8B55E0   		movl	-32(%rbp), %edx
 983 086c 0FB645E4 		movzbl	-28(%rbp), %eax
 984 0870 488B4DE8 		movq	-24(%rbp), %rcx
 985 0874 488B31   		movq	(%rcx), %rsi
 986 0877 488B4DE8 		movq	-24(%rbp), %rcx
 987 087b 8B4908   		movl	8(%rcx), %ecx
 988 087e 89C9     		movl	%ecx, %ecx
 989 0880 4801F1   		addq	%rsi, %rcx
 990 0883 89C6     		movl	%eax, %esi
 991 0885 4889CF   		movq	%rcx, %rdi
 992 0888 E8000000 		call	memset@PLT
 992      00
 258:core.c        **** 	self->length = blockEnd;
 993              		.loc 1 258 0
 994 088d 488B45E8 		movq	-24(%rbp), %rax
 995 0891 8B55F8   		movl	-8(%rbp), %edx
 996 0894 895008   		movl	%edx, 8(%rax)
 259:core.c        **** 	return BUF_SUCCESS;
 997              		.loc 1 259 0
 998 0897 B8000000 		movl	$0, %eax
 998      00
 999              	.L48:
 260:core.c        **** }
 1000              		.loc 1 260 0
 1001 089c C9       		leave
 1002              		.cfi_def_cfa 7, 8
 1003 089d C3       		ret
 1004              		.cfi_endproc
 1005              	.LFE15:
 1007              		.globl	bufAppendBlock
 1009              	bufAppendBlock:
 1010              	.LFB16:
 261:core.c        **** 
 262:core.c        **** // Write the supplied data to the buffer structure.
 263:core.c        **** // Returns BUF_SUCCESS or BUF_NO_MEM.
 264:core.c        **** //
 265:core.c        **** DLLEXPORT(BufferStatus) bufAppendBlock(
 266:core.c        **** 	struct Buffer *self, const uint8 *srcPtr, uint32 count, const char **error)
 267:core.c        **** {
 1011              		.loc 1 267 0
 1012              		.cfi_startproc
 1013 089e 55       		pushq	%rbp
 1014              		.cfi_def_cfa_offset 16
 1015              		.cfi_offset 6, -16
 1016 089f 4889E5   		movq	%rsp, %rbp
 1017              		.cfi_def_cfa_register 6
 1018 08a2 4883EC30 		subq	$48, %rsp
 1019 08a6 48897DE8 		movq	%rdi, -24(%rbp)
 1020 08aa 488975E0 		movq	%rsi, -32(%rbp)
 1021 08ae 8955DC   		movl	%edx, -36(%rbp)
 1022 08b1 48894DD0 		movq	%rcx, -48(%rbp)
 268:core.c        **** 	const uint32 blockEnd = self->length + count;
 1023              		.loc 1 268 0
 1024 08b5 488B45E8 		movq	-24(%rbp), %rax
 1025 08b9 8B5008   		movl	8(%rax), %edx
 1026 08bc 8B45DC   		movl	-36(%rbp), %eax
 1027 08bf 01D0     		addl	%edx, %eax
 1028 08c1 8945F8   		movl	%eax, -8(%rbp)
 269:core.c        **** 	ENSURE_CAPACITY();
 1029              		.loc 1 269 0
 1030 08c4 488B45E8 		movq	-24(%rbp), %rax
 1031 08c8 8B400C   		movl	12(%rax), %eax
 1032 08cb 3B45F8   		cmpl	-8(%rbp), %eax
 1033 08ce 7328     		jnb	.L50
 1034              	.LBB8:
 1035              		.loc 1 269 0 is_stmt 0 discriminator 1
 1036 08d0 488B45E8 		movq	-24(%rbp), %rax
 1037 08d4 8B700C   		movl	12(%rax), %esi
 1038 08d7 488B4DD0 		movq	-48(%rbp), %rcx
 1039 08db 8B55F8   		movl	-8(%rbp), %edx
 1040 08de 488B45E8 		movq	-24(%rbp), %rax
 1041 08e2 4889C7   		movq	%rax, %rdi
 1042 08e5 E82DFAFF 		call	reallocate
 1042      FF
 1043 08ea 8945FC   		movl	%eax, -4(%rbp)
 1044 08ed 837DFC00 		cmpl	$0, -4(%rbp)
 1045 08f1 7405     		je	.L50
 1046              		.loc 1 269 0 discriminator 2
 1047 08f3 8B45FC   		movl	-4(%rbp), %eax
 1048 08f6 EB34     		jmp	.L51
 1049              	.L50:
 1050              	.LBE8:
 270:core.c        **** 	memcpy(self->data + self->length, srcPtr, count);
 1051              		.loc 1 270 0 is_stmt 1
 1052 08f8 8B55DC   		movl	-36(%rbp), %edx
 1053 08fb 488B45E8 		movq	-24(%rbp), %rax
 1054 08ff 488B08   		movq	(%rax), %rcx
 1055 0902 488B45E8 		movq	-24(%rbp), %rax
 1056 0906 8B4008   		movl	8(%rax), %eax
 1057 0909 89C0     		movl	%eax, %eax
 1058 090b 4801C1   		addq	%rax, %rcx
 1059 090e 488B45E0 		movq	-32(%rbp), %rax
 1060 0912 4889C6   		movq	%rax, %rsi
 1061 0915 4889CF   		movq	%rcx, %rdi
 1062 0918 E8000000 		call	memcpy@PLT
 1062      00
 271:core.c        **** 	self->length = blockEnd;
 1063              		.loc 1 271 0
 1064 091d 488B45E8 		movq	-24(%rbp), %rax
 1065 0921 8B55F8   		movl	-8(%rbp), %edx
 1066 0924 895008   		movl	%edx, 8(%rax)
 272:core.c        **** 	return BUF_SUCCESS;
 1067              		.loc 1 272 0
 1068 0927 B8000000 		movl	$0, %eax
 1068      00
 1069              	.L51:
 273:core.c        **** }
 1070              		.loc 1 273 0
 1071 092c C9       		leave
 1072              		.cfi_def_cfa 7, 8
 1073 092d C3       		ret
 1074              		.cfi_endproc
 1075              	.LFE16:
 1078              	maybeReallocate:
 1079              	.LFB17:
 274:core.c        **** 
 275:core.c        **** // Used by bufWriteXXX() to ensure sufficient capacity for the operation.
 276:core.c        **** //
 277:core.c        **** static BufferStatus maybeReallocate(
 278:core.c        **** 	struct Buffer *const self, const uint32 bufAddress, const uint32 count, const char **error)
 279:core.c        **** {
 1080              		.loc 1 279 0
 1081              		.cfi_startproc
 1082 092e 55       		pushq	%rbp
 1083              		.cfi_def_cfa_offset 16
 1084              		.cfi_offset 6, -16
 1085 092f 4889E5   		movq	%rsp, %rbp
 1086              		.cfi_def_cfa_register 6
 1087 0932 4883EC40 		subq	$64, %rsp
 1088 0936 48897DD8 		movq	%rdi, -40(%rbp)
 1089 093a 8975D4   		movl	%esi, -44(%rbp)
 1090 093d 8955D0   		movl	%edx, -48(%rbp)
 1091 0940 48894DC8 		movq	%rcx, -56(%rbp)
 280:core.c        **** 	// There are three possibilities:
 281:core.c        **** 	//   * The block to be written starts after the end of the current buffer
 282:core.c        **** 	//   * The block to be written starts within the current buffer, but ends beyond it
 283:core.c        **** 	//   * The block to be written ends within the current buffer
 284:core.c        **** 	//
 285:core.c        **** 	const uint32 blockEnd = bufAddress + count;
 1092              		.loc 1 285 0
 1093 0944 8B55D4   		movl	-44(%rbp), %edx
 1094 0947 8B45D0   		movl	-48(%rbp), %eax
 1095 094a 01D0     		addl	%edx, %eax
 1096 094c 8945E4   		movl	%eax, -28(%rbp)
 286:core.c        **** 	if ( bufAddress >= self->length ) {
 1097              		.loc 1 286 0
 1098 094f 488B45D8 		movq	-40(%rbp), %rax
 1099 0953 8B4008   		movl	8(%rax), %eax
 1100 0956 3B45D4   		cmpl	-44(%rbp), %eax
 1101 0959 0F878D00 		ja	.L53
 1101      0000
 1102              	.LBB9:
 287:core.c        **** 		// Begins outside - reallocation may be necessary, zeroing definitely necessary
 288:core.c        **** 		//
 289:core.c        **** 		uint8 *ptr, *endPtr;
 290:core.c        **** 		ENSURE_CAPACITY();
 1103              		.loc 1 290 0
 1104 095f 488B45D8 		movq	-40(%rbp), %rax
 1105 0963 8B400C   		movl	12(%rax), %eax
 1106 0966 3B45E4   		cmpl	-28(%rbp), %eax
 1107 0969 732B     		jnb	.L54
 1108              	.LBB10:
 1109              		.loc 1 290 0 is_stmt 0 discriminator 1
 1110 096b 488B45D8 		movq	-40(%rbp), %rax
 1111 096f 8B700C   		movl	12(%rax), %esi
 1112 0972 488B4DC8 		movq	-56(%rbp), %rcx
 1113 0976 8B55E4   		movl	-28(%rbp), %edx
 1114 0979 488B45D8 		movq	-40(%rbp), %rax
 1115 097d 4889C7   		movq	%rax, %rdi
 1116 0980 E892F9FF 		call	reallocate
 1116      FF
 1117 0985 8945E8   		movl	%eax, -24(%rbp)
 1118 0988 837DE800 		cmpl	$0, -24(%rbp)
 1119 098c 7408     		je	.L54
 1120              		.loc 1 290 0 discriminator 2
 1121 098e 8B45E8   		movl	-24(%rbp), %eax
 1122 0991 E9B10000 		jmp	.L55
 1122      00
 1123              	.L54:
 1124              	.LBE10:
 291:core.c        **** 		
 292:core.c        **** 		// Now fill from the end of the old length to the start of the block
 293:core.c        **** 		//
 294:core.c        **** 		ptr = self->data + self->length;
 1125              		.loc 1 294 0 is_stmt 1
 1126 0996 488B45D8 		movq	-40(%rbp), %rax
 1127 099a 488B10   		movq	(%rax), %rdx
 1128 099d 488B45D8 		movq	-40(%rbp), %rax
 1129 09a1 8B4008   		movl	8(%rax), %eax
 1130 09a4 89C0     		movl	%eax, %eax
 1131 09a6 4801D0   		addq	%rdx, %rax
 1132 09a9 488945F0 		movq	%rax, -16(%rbp)
 295:core.c        **** 		endPtr = self->data + bufAddress;
 1133              		.loc 1 295 0
 1134 09ad 488B45D8 		movq	-40(%rbp), %rax
 1135 09b1 488B10   		movq	(%rax), %rdx
 1136 09b4 8B45D4   		movl	-44(%rbp), %eax
 1137 09b7 4801D0   		addq	%rdx, %rax
 1138 09ba 488945F8 		movq	%rax, -8(%rbp)
 296:core.c        **** 		while ( ptr < endPtr ) {
 1139              		.loc 1 296 0
 1140 09be EB16     		jmp	.L56
 1141              	.L57:
 297:core.c        **** 			*ptr++ = self->fill;
 1142              		.loc 1 297 0
 1143 09c0 488B45F0 		movq	-16(%rbp), %rax
 1144 09c4 488D5001 		leaq	1(%rax), %rdx
 1145 09c8 488955F0 		movq	%rdx, -16(%rbp)
 1146 09cc 488B55D8 		movq	-40(%rbp), %rdx
 1147 09d0 0FB65210 		movzbl	16(%rdx), %edx
 1148 09d4 8810     		movb	%dl, (%rax)
 1149              	.L56:
 296:core.c        **** 		while ( ptr < endPtr ) {
 1150              		.loc 1 296 0
 1151 09d6 488B45F0 		movq	-16(%rbp), %rax
 1152 09da 483B45F8 		cmpq	-8(%rbp), %rax
 1153 09de 72E0     		jb	.L57
 298:core.c        **** 		}
 299:core.c        **** 		
 300:core.c        **** 		self->length = blockEnd;
 1154              		.loc 1 300 0
 1155 09e0 488B45D8 		movq	-40(%rbp), %rax
 1156 09e4 8B55E4   		movl	-28(%rbp), %edx
 1157 09e7 895008   		movl	%edx, 8(%rax)
 1158              	.LBE9:
 1159 09ea EB56     		jmp	.L58
 1160              	.L53:
 301:core.c        **** 	} else if ( bufAddress < self->length && blockEnd > self->length ) {
 1161              		.loc 1 301 0
 1162 09ec 488B45D8 		movq	-40(%rbp), %rax
 1163 09f0 8B4008   		movl	8(%rax), %eax
 1164 09f3 3B45D4   		cmpl	-44(%rbp), %eax
 1165 09f6 764A     		jbe	.L58
 1166              		.loc 1 301 0 is_stmt 0 discriminator 1
 1167 09f8 488B45D8 		movq	-40(%rbp), %rax
 1168 09fc 8B4008   		movl	8(%rax), %eax
 1169 09ff 3B45E4   		cmpl	-28(%rbp), %eax
 1170 0a02 733E     		jnb	.L58
 302:core.c        **** 		// Begins inside, ends outside - reallocation and zeroing may be necessary
 303:core.c        **** 		//
 304:core.c        **** 		ENSURE_CAPACITY();
 1171              		.loc 1 304 0 is_stmt 1
 1172 0a04 488B45D8 		movq	-40(%rbp), %rax
 1173 0a08 8B400C   		movl	12(%rax), %eax
 1174 0a0b 3B45E4   		cmpl	-28(%rbp), %eax
 1175 0a0e 7328     		jnb	.L59
 1176              	.LBB11:
 1177              		.loc 1 304 0 is_stmt 0 discriminator 1
 1178 0a10 488B45D8 		movq	-40(%rbp), %rax
 1179 0a14 8B700C   		movl	12(%rax), %esi
 1180 0a17 488B4DC8 		movq	-56(%rbp), %rcx
 1181 0a1b 8B55E4   		movl	-28(%rbp), %edx
 1182 0a1e 488B45D8 		movq	-40(%rbp), %rax
 1183 0a22 4889C7   		movq	%rax, %rdi
 1184 0a25 E8EDF8FF 		call	reallocate
 1184      FF
 1185 0a2a 8945EC   		movl	%eax, -20(%rbp)
 1186 0a2d 837DEC00 		cmpl	$0, -20(%rbp)
 1187 0a31 7405     		je	.L59
 1188              		.loc 1 304 0 discriminator 2
 1189 0a33 8B45EC   		movl	-20(%rbp), %eax
 1190 0a36 EB0F     		jmp	.L55
 1191              	.L59:
 1192              	.LBE11:
 305:core.c        **** 		self->length = blockEnd;
 1193              		.loc 1 305 0 is_stmt 1
 1194 0a38 488B45D8 		movq	-40(%rbp), %rax
 1195 0a3c 8B55E4   		movl	-28(%rbp), %edx
 1196 0a3f 895008   		movl	%edx, 8(%rax)
 1197              	.L58:
 306:core.c        **** 	}
 307:core.c        **** 	return BUF_SUCCESS;
 1198              		.loc 1 307 0
 1199 0a42 B8000000 		movl	$0, %eax
 1199      00
 1200              	.L55:
 308:core.c        **** }
 1201              		.loc 1 308 0
 1202 0a47 C9       		leave
 1203              		.cfi_def_cfa 7, 8
 1204 0a48 C3       		ret
 1205              		.cfi_endproc
 1206              	.LFE17:
 1208              		.section	.rodata
 1209              	.LC2:
 1210 004c 62756657 		.string	"bufWriteByte()"
 1210      72697465 
 1210      42797465 
 1210      282900
 1211              		.text
 1212              		.globl	bufWriteByte
 1214              	bufWriteByte:
 1215              	.LFB18:
 309:core.c        **** 
 310:core.c        **** // Write a single byte into the target buffer. The target offset may be outside the current extent
 311:core.c        **** // (or even capacity) of the target buffer.
 312:core.c        **** //
 313:core.c        **** DLLEXPORT(BufferStatus) bufWriteByte(
 314:core.c        **** 	struct Buffer *self, uint32 offset, uint8 byte, const char **error)
 315:core.c        **** {
 1216              		.loc 1 315 0
 1217              		.cfi_startproc
 1218 0a49 55       		pushq	%rbp
 1219              		.cfi_def_cfa_offset 16
 1220              		.cfi_offset 6, -16
 1221 0a4a 4889E5   		movq	%rsp, %rbp
 1222              		.cfi_def_cfa_register 6
 1223 0a4d 4883EC30 		subq	$48, %rsp
 1224 0a51 48897DE8 		movq	%rdi, -24(%rbp)
 1225 0a55 8975E4   		movl	%esi, -28(%rbp)
 1226 0a58 89D0     		movl	%edx, %eax
 1227 0a5a 48894DD8 		movq	%rcx, -40(%rbp)
 1228 0a5e 8845E0   		movb	%al, -32(%rbp)
 316:core.c        **** 	BufferStatus status, returnCode = BUF_SUCCESS;
 1229              		.loc 1 316 0
 1230 0a61 C745F800 		movl	$0, -8(%rbp)
 1230      000000
 317:core.c        **** 	status = maybeReallocate(self, offset, 1, error);
 1231              		.loc 1 317 0
 1232 0a68 488B55D8 		movq	-40(%rbp), %rdx
 1233 0a6c 8B75E4   		movl	-28(%rbp), %esi
 1234 0a6f 488B45E8 		movq	-24(%rbp), %rax
 1235 0a73 4889D1   		movq	%rdx, %rcx
 1236 0a76 BA010000 		movl	$1, %edx
 1236      00
 1237 0a7b 4889C7   		movq	%rax, %rdi
 1238 0a7e E8ABFEFF 		call	maybeReallocate
 1238      FF
 1239 0a83 8945FC   		movl	%eax, -4(%rbp)
 318:core.c        **** 	CHECK_STATUS(status, "bufWriteByte()", status);
 1240              		.loc 1 318 0
 1241 0a86 837DFC00 		cmpl	$0, -4(%rbp)
 1242 0a8a 741B     		je	.L61
 1243              		.loc 1 318 0 is_stmt 0 discriminator 1
 1244 0a8c 488B45D8 		movq	-40(%rbp), %rax
 1245 0a90 488D3500 		leaq	.LC2(%rip), %rsi
 1245      000000
 1246 0a97 4889C7   		movq	%rax, %rdi
 1247 0a9a E8000000 		call	errPrefix@PLT
 1247      00
 1248 0a9f 8B45FC   		movl	-4(%rbp), %eax
 1249 0aa2 8945F8   		movl	%eax, -8(%rbp)
 1250 0aa5 EB13     		jmp	.L62
 1251              	.L61:
 319:core.c        **** 	self->data[offset] = byte;
 1252              		.loc 1 319 0 is_stmt 1
 1253 0aa7 488B45E8 		movq	-24(%rbp), %rax
 1254 0aab 488B10   		movq	(%rax), %rdx
 1255 0aae 8B45E4   		movl	-28(%rbp), %eax
 1256 0ab1 4801C2   		addq	%rax, %rdx
 1257 0ab4 0FB645E0 		movzbl	-32(%rbp), %eax
 1258 0ab8 8802     		movb	%al, (%rdx)
 1259              	.L62:
 320:core.c        **** cleanup:
 321:core.c        **** 	return returnCode;
 1260              		.loc 1 321 0
 1261 0aba 8B45F8   		movl	-8(%rbp), %eax
 322:core.c        **** }
 1262              		.loc 1 322 0
 1263 0abd C9       		leave
 1264              		.cfi_def_cfa 7, 8
 1265 0abe C3       		ret
 1266              		.cfi_endproc
 1267              	.LFE18:
 1269              		.section	.rodata
 1270              	.LC3:
 1271 005b 62756657 		.string	"bufWriteWordLE()"
 1271      72697465 
 1271      576F7264 
 1271      4C452829 
 1271      00
 1272              		.text
 1273              		.globl	bufWriteWordLE
 1275              	bufWriteWordLE:
 1276              	.LFB19:
 323:core.c        **** 
 324:core.c        **** // Write a uint16 into the target buffer in little-endian format. The target offset may be outside
 325:core.c        **** // the current extent (or even capacity) of the target buffer.
 326:core.c        **** //
 327:core.c        **** DLLEXPORT(BufferStatus) bufWriteWordLE(
 328:core.c        **** 	struct Buffer *self, uint32 offset, uint16 word, const char **error)
 329:core.c        **** {
 1277              		.loc 1 329 0
 1278              		.cfi_startproc
 1279 0abf 55       		pushq	%rbp
 1280              		.cfi_def_cfa_offset 16
 1281              		.cfi_offset 6, -16
 1282 0ac0 4889E5   		movq	%rsp, %rbp
 1283              		.cfi_def_cfa_register 6
 1284 0ac3 4883EC40 		subq	$64, %rsp
 1285 0ac7 48897DD8 		movq	%rdi, -40(%rbp)
 1286 0acb 8975D4   		movl	%esi, -44(%rbp)
 1287 0ace 89D0     		movl	%edx, %eax
 1288 0ad0 48894DC8 		movq	%rcx, -56(%rbp)
 1289 0ad4 668945D0 		movw	%ax, -48(%rbp)
 1290              		.loc 1 329 0
 1291 0ad8 64488B04 		movq	%fs:40, %rax
 1291      25280000 
 1291      00
 1292 0ae1 488945F8 		movq	%rax, -8(%rbp)
 1293 0ae5 31C0     		xorl	%eax, %eax
 330:core.c        **** 	BufferStatus status, returnCode = BUF_SUCCESS;
 1294              		.loc 1 330 0
 1295 0ae7 C745F000 		movl	$0, -16(%rbp)
 1295      000000
 331:core.c        **** 	union {
 332:core.c        **** 		uint16 word;
 333:core.c        **** 		uint8 byte[2];
 334:core.c        **** 	} u;
 335:core.c        **** 	u.word = word;
 1296              		.loc 1 335 0
 1297 0aee 0FB745D0 		movzwl	-48(%rbp), %eax
 1298 0af2 668945E0 		movw	%ax, -32(%rbp)
 336:core.c        **** 	status = maybeReallocate(self, offset, 2, error);
 1299              		.loc 1 336 0
 1300 0af6 488B55C8 		movq	-56(%rbp), %rdx
 1301 0afa 8B75D4   		movl	-44(%rbp), %esi
 1302 0afd 488B45D8 		movq	-40(%rbp), %rax
 1303 0b01 4889D1   		movq	%rdx, %rcx
 1304 0b04 BA020000 		movl	$2, %edx
 1304      00
 1305 0b09 4889C7   		movq	%rax, %rdi
 1306 0b0c E81DFEFF 		call	maybeReallocate
 1306      FF
 1307 0b11 8945F4   		movl	%eax, -12(%rbp)
 337:core.c        **** 	CHECK_STATUS(status, "bufWriteWordLE()", status);
 1308              		.loc 1 337 0
 1309 0b14 837DF400 		cmpl	$0, -12(%rbp)
 1310 0b18 741B     		je	.L65
 1311              		.loc 1 337 0 is_stmt 0 discriminator 1
 1312 0b1a 488B45C8 		movq	-56(%rbp), %rax
 1313 0b1e 488D3500 		leaq	.LC3(%rip), %rsi
 1313      000000
 1314 0b25 4889C7   		movq	%rax, %rdi
 1315 0b28 E8000000 		call	errPrefix@PLT
 1315      00
 1316 0b2d 8B45F4   		movl	-12(%rbp), %eax
 1317 0b30 8945F0   		movl	%eax, -16(%rbp)
 1318 0b33 EB2A     		jmp	.L66
 1319              	.L65:
 338:core.c        **** 	#if BYTE_ORDER == 1234
 339:core.c        **** 		*(self->data + offset) = u.byte[0];
 1320              		.loc 1 339 0 is_stmt 1
 1321 0b35 488B45D8 		movq	-40(%rbp), %rax
 1322 0b39 488B10   		movq	(%rax), %rdx
 1323 0b3c 8B45D4   		movl	-44(%rbp), %eax
 1324 0b3f 4801C2   		addq	%rax, %rdx
 1325 0b42 0FB645E0 		movzbl	-32(%rbp), %eax
 1326 0b46 8802     		movb	%al, (%rdx)
 340:core.c        **** 		*(self->data + offset + 1) = u.byte[1];
 1327              		.loc 1 340 0
 1328 0b48 488B45D8 		movq	-40(%rbp), %rax
 1329 0b4c 488B00   		movq	(%rax), %rax
 1330 0b4f 8B55D4   		movl	-44(%rbp), %edx
 1331 0b52 4883C201 		addq	$1, %rdx
 1332 0b56 4801C2   		addq	%rax, %rdx
 1333 0b59 0FB645E1 		movzbl	-31(%rbp), %eax
 1334 0b5d 8802     		movb	%al, (%rdx)
 1335              	.L66:
 341:core.c        **** 	#else
 342:core.c        **** 		*(self->data + offset) = u.byte[1];
 343:core.c        **** 		*(self->data + offset + 1) = u.byte[0];
 344:core.c        **** 	#endif
 345:core.c        **** cleanup:
 346:core.c        **** 	return returnCode;
 1336              		.loc 1 346 0
 1337 0b5f 8B45F0   		movl	-16(%rbp), %eax
 347:core.c        **** }
 1338              		.loc 1 347 0
 1339 0b62 488B4DF8 		movq	-8(%rbp), %rcx
 1340 0b66 6448330C 		xorq	%fs:40, %rcx
 1340      25280000 
 1340      00
 1341 0b6f 7405     		je	.L68
 1342 0b71 E8000000 		call	__stack_chk_fail@PLT
 1342      00
 1343              	.L68:
 1344 0b76 C9       		leave
 1345              		.cfi_def_cfa 7, 8
 1346 0b77 C3       		ret
 1347              		.cfi_endproc
 1348              	.LFE19:
 1350              		.section	.rodata
 1351              	.LC4:
 1352 006c 62756657 		.string	"bufWriteWordBE()"
 1352      72697465 
 1352      576F7264 
 1352      42452829 
 1352      00
 1353              		.text
 1354              		.globl	bufWriteWordBE
 1356              	bufWriteWordBE:
 1357              	.LFB20:
 348:core.c        **** 
 349:core.c        **** // Write a uint16 into the target buffer in big-endian format. The target offset may be outside
 350:core.c        **** // the current extent (or even capacity) of the target buffer.
 351:core.c        **** //
 352:core.c        **** DLLEXPORT(BufferStatus) bufWriteWordBE(
 353:core.c        **** 	struct Buffer *self, uint32 offset, uint16 word, const char **error)
 354:core.c        **** {
 1358              		.loc 1 354 0
 1359              		.cfi_startproc
 1360 0b78 55       		pushq	%rbp
 1361              		.cfi_def_cfa_offset 16
 1362              		.cfi_offset 6, -16
 1363 0b79 4889E5   		movq	%rsp, %rbp
 1364              		.cfi_def_cfa_register 6
 1365 0b7c 4883EC40 		subq	$64, %rsp
 1366 0b80 48897DD8 		movq	%rdi, -40(%rbp)
 1367 0b84 8975D4   		movl	%esi, -44(%rbp)
 1368 0b87 89D0     		movl	%edx, %eax
 1369 0b89 48894DC8 		movq	%rcx, -56(%rbp)
 1370 0b8d 668945D0 		movw	%ax, -48(%rbp)
 1371              		.loc 1 354 0
 1372 0b91 64488B04 		movq	%fs:40, %rax
 1372      25280000 
 1372      00
 1373 0b9a 488945F8 		movq	%rax, -8(%rbp)
 1374 0b9e 31C0     		xorl	%eax, %eax
 355:core.c        **** 	BufferStatus status, returnCode = BUF_SUCCESS;
 1375              		.loc 1 355 0
 1376 0ba0 C745F000 		movl	$0, -16(%rbp)
 1376      000000
 356:core.c        **** 	union {
 357:core.c        **** 		uint16 word;
 358:core.c        **** 		uint8 byte[2];
 359:core.c        **** 	} u;
 360:core.c        **** 	u.word = word;
 1377              		.loc 1 360 0
 1378 0ba7 0FB745D0 		movzwl	-48(%rbp), %eax
 1379 0bab 668945E0 		movw	%ax, -32(%rbp)
 361:core.c        **** 	status = maybeReallocate(self, offset, 2, error);
 1380              		.loc 1 361 0
 1381 0baf 488B55C8 		movq	-56(%rbp), %rdx
 1382 0bb3 8B75D4   		movl	-44(%rbp), %esi
 1383 0bb6 488B45D8 		movq	-40(%rbp), %rax
 1384 0bba 4889D1   		movq	%rdx, %rcx
 1385 0bbd BA020000 		movl	$2, %edx
 1385      00
 1386 0bc2 4889C7   		movq	%rax, %rdi
 1387 0bc5 E864FDFF 		call	maybeReallocate
 1387      FF
 1388 0bca 8945F4   		movl	%eax, -12(%rbp)
 362:core.c        **** 	CHECK_STATUS(status, "bufWriteWordBE()", status);
 1389              		.loc 1 362 0
 1390 0bcd 837DF400 		cmpl	$0, -12(%rbp)
 1391 0bd1 741B     		je	.L70
 1392              		.loc 1 362 0 is_stmt 0 discriminator 1
 1393 0bd3 488B45C8 		movq	-56(%rbp), %rax
 1394 0bd7 488D3500 		leaq	.LC4(%rip), %rsi
 1394      000000
 1395 0bde 4889C7   		movq	%rax, %rdi
 1396 0be1 E8000000 		call	errPrefix@PLT
 1396      00
 1397 0be6 8B45F4   		movl	-12(%rbp), %eax
 1398 0be9 8945F0   		movl	%eax, -16(%rbp)
 1399 0bec EB2A     		jmp	.L71
 1400              	.L70:
 363:core.c        **** 	#if BYTE_ORDER == 1234
 364:core.c        **** 		*(self->data + offset) = u.byte[1];
 1401              		.loc 1 364 0 is_stmt 1
 1402 0bee 488B45D8 		movq	-40(%rbp), %rax
 1403 0bf2 488B10   		movq	(%rax), %rdx
 1404 0bf5 8B45D4   		movl	-44(%rbp), %eax
 1405 0bf8 4801C2   		addq	%rax, %rdx
 1406 0bfb 0FB645E1 		movzbl	-31(%rbp), %eax
 1407 0bff 8802     		movb	%al, (%rdx)
 365:core.c        **** 		*(self->data + offset + 1) = u.byte[0];
 1408              		.loc 1 365 0
 1409 0c01 488B45D8 		movq	-40(%rbp), %rax
 1410 0c05 488B00   		movq	(%rax), %rax
 1411 0c08 8B55D4   		movl	-44(%rbp), %edx
 1412 0c0b 4883C201 		addq	$1, %rdx
 1413 0c0f 4801C2   		addq	%rax, %rdx
 1414 0c12 0FB645E0 		movzbl	-32(%rbp), %eax
 1415 0c16 8802     		movb	%al, (%rdx)
 1416              	.L71:
 366:core.c        **** 	#else
 367:core.c        **** 		*(self->data + offset) = u.byte[0];
 368:core.c        **** 		*(self->data + offset + 1) = u.byte[1];
 369:core.c        **** 	#endif
 370:core.c        **** cleanup:
 371:core.c        **** 	return returnCode;
 1417              		.loc 1 371 0
 1418 0c18 8B45F0   		movl	-16(%rbp), %eax
 372:core.c        **** }
 1419              		.loc 1 372 0
 1420 0c1b 488B4DF8 		movq	-8(%rbp), %rcx
 1421 0c1f 6448330C 		xorq	%fs:40, %rcx
 1421      25280000 
 1421      00
 1422 0c28 7405     		je	.L73
 1423 0c2a E8000000 		call	__stack_chk_fail@PLT
 1423      00
 1424              	.L73:
 1425 0c2f C9       		leave
 1426              		.cfi_def_cfa 7, 8
 1427 0c30 C3       		ret
 1428              		.cfi_endproc
 1429              	.LFE20:
 1431              		.section	.rodata
 1432              	.LC5:
 1433 007d 62756657 		.string	"bufWriteLongLE()"
 1433      72697465 
 1433      4C6F6E67 
 1433      4C452829 
 1433      00
 1434              		.text
 1435              		.globl	bufWriteLongLE
 1437              	bufWriteLongLE:
 1438              	.LFB21:
 373:core.c        **** 
 374:core.c        **** // Write a uint16 into the target buffer in little-endian format. The target offset may be outside
 375:core.c        **** // the current extent (or even capacity) of the target buffer.
 376:core.c        **** //
 377:core.c        **** DLLEXPORT(BufferStatus) bufWriteLongLE(
 378:core.c        **** 	struct Buffer *self, uint32 offset, uint32 lword, const char **error)
 379:core.c        **** {
 1439              		.loc 1 379 0
 1440              		.cfi_startproc
 1441 0c31 55       		pushq	%rbp
 1442              		.cfi_def_cfa_offset 16
 1443              		.cfi_offset 6, -16
 1444 0c32 4889E5   		movq	%rsp, %rbp
 1445              		.cfi_def_cfa_register 6
 1446 0c35 4883EC40 		subq	$64, %rsp
 1447 0c39 48897DD8 		movq	%rdi, -40(%rbp)
 1448 0c3d 8975D4   		movl	%esi, -44(%rbp)
 1449 0c40 8955D0   		movl	%edx, -48(%rbp)
 1450 0c43 48894DC8 		movq	%rcx, -56(%rbp)
 1451              		.loc 1 379 0
 1452 0c47 64488B04 		movq	%fs:40, %rax
 1452      25280000 
 1452      00
 1453 0c50 488945F8 		movq	%rax, -8(%rbp)
 1454 0c54 31C0     		xorl	%eax, %eax
 380:core.c        **** 	BufferStatus status, returnCode = BUF_SUCCESS;
 1455              		.loc 1 380 0
 1456 0c56 C745F000 		movl	$0, -16(%rbp)
 1456      000000
 381:core.c        **** 	union {
 382:core.c        **** 		uint32 lword;
 383:core.c        **** 		uint8 byte[4];
 384:core.c        **** 	} u;
 385:core.c        **** 	u.lword = lword;
 1457              		.loc 1 385 0
 1458 0c5d 8B45D0   		movl	-48(%rbp), %eax
 1459 0c60 8945E0   		movl	%eax, -32(%rbp)
 386:core.c        **** 	status = maybeReallocate(self, offset, 4, error);
 1460              		.loc 1 386 0
 1461 0c63 488B55C8 		movq	-56(%rbp), %rdx
 1462 0c67 8B75D4   		movl	-44(%rbp), %esi
 1463 0c6a 488B45D8 		movq	-40(%rbp), %rax
 1464 0c6e 4889D1   		movq	%rdx, %rcx
 1465 0c71 BA040000 		movl	$4, %edx
 1465      00
 1466 0c76 4889C7   		movq	%rax, %rdi
 1467 0c79 E8B0FCFF 		call	maybeReallocate
 1467      FF
 1468 0c7e 8945F4   		movl	%eax, -12(%rbp)
 387:core.c        **** 	CHECK_STATUS(status, "bufWriteLongLE()", status);
 1469              		.loc 1 387 0
 1470 0c81 837DF400 		cmpl	$0, -12(%rbp)
 1471 0c85 741B     		je	.L75
 1472              		.loc 1 387 0 is_stmt 0 discriminator 1
 1473 0c87 488B45C8 		movq	-56(%rbp), %rax
 1474 0c8b 488D3500 		leaq	.LC5(%rip), %rsi
 1474      000000
 1475 0c92 4889C7   		movq	%rax, %rdi
 1476 0c95 E8000000 		call	errPrefix@PLT
 1476      00
 1477 0c9a 8B45F4   		movl	-12(%rbp), %eax
 1478 0c9d 8945F0   		movl	%eax, -16(%rbp)
 1479 0ca0 EB58     		jmp	.L76
 1480              	.L75:
 388:core.c        **** 	#if BYTE_ORDER == 1234
 389:core.c        **** 		*(self->data + offset) = u.byte[0];
 1481              		.loc 1 389 0 is_stmt 1
 1482 0ca2 488B45D8 		movq	-40(%rbp), %rax
 1483 0ca6 488B10   		movq	(%rax), %rdx
 1484 0ca9 8B45D4   		movl	-44(%rbp), %eax
 1485 0cac 4801C2   		addq	%rax, %rdx
 1486 0caf 0FB645E0 		movzbl	-32(%rbp), %eax
 1487 0cb3 8802     		movb	%al, (%rdx)
 390:core.c        **** 		*(self->data + offset + 1) = u.byte[1];
 1488              		.loc 1 390 0
 1489 0cb5 488B45D8 		movq	-40(%rbp), %rax
 1490 0cb9 488B00   		movq	(%rax), %rax
 1491 0cbc 8B55D4   		movl	-44(%rbp), %edx
 1492 0cbf 4883C201 		addq	$1, %rdx
 1493 0cc3 4801C2   		addq	%rax, %rdx
 1494 0cc6 0FB645E1 		movzbl	-31(%rbp), %eax
 1495 0cca 8802     		movb	%al, (%rdx)
 391:core.c        **** 		*(self->data + offset + 2) = u.byte[2];
 1496              		.loc 1 391 0
 1497 0ccc 488B45D8 		movq	-40(%rbp), %rax
 1498 0cd0 488B00   		movq	(%rax), %rax
 1499 0cd3 8B55D4   		movl	-44(%rbp), %edx
 1500 0cd6 4883C202 		addq	$2, %rdx
 1501 0cda 4801C2   		addq	%rax, %rdx
 1502 0cdd 0FB645E2 		movzbl	-30(%rbp), %eax
 1503 0ce1 8802     		movb	%al, (%rdx)
 392:core.c        **** 		*(self->data + offset + 3) = u.byte[3];
 1504              		.loc 1 392 0
 1505 0ce3 488B45D8 		movq	-40(%rbp), %rax
 1506 0ce7 488B00   		movq	(%rax), %rax
 1507 0cea 8B55D4   		movl	-44(%rbp), %edx
 1508 0ced 4883C203 		addq	$3, %rdx
 1509 0cf1 4801C2   		addq	%rax, %rdx
 1510 0cf4 0FB645E3 		movzbl	-29(%rbp), %eax
 1511 0cf8 8802     		movb	%al, (%rdx)
 1512              	.L76:
 393:core.c        **** 	#else
 394:core.c        **** 		*(self->data + offset) = u.byte[3];
 395:core.c        **** 		*(self->data + offset + 1) = u.byte[2];
 396:core.c        **** 		*(self->data + offset + 2) = u.byte[1];
 397:core.c        **** 		*(self->data + offset + 3) = u.byte[0];
 398:core.c        **** 	#endif
 399:core.c        **** cleanup:
 400:core.c        **** 	return returnCode;
 1513              		.loc 1 400 0
 1514 0cfa 8B45F0   		movl	-16(%rbp), %eax
 401:core.c        **** }
 1515              		.loc 1 401 0
 1516 0cfd 488B4DF8 		movq	-8(%rbp), %rcx
 1517 0d01 6448330C 		xorq	%fs:40, %rcx
 1517      25280000 
 1517      00
 1518 0d0a 7405     		je	.L78
 1519 0d0c E8000000 		call	__stack_chk_fail@PLT
 1519      00
 1520              	.L78:
 1521 0d11 C9       		leave
 1522              		.cfi_def_cfa 7, 8
 1523 0d12 C3       		ret
 1524              		.cfi_endproc
 1525              	.LFE21:
 1527              		.section	.rodata
 1528              	.LC6:
 1529 008e 62756657 		.string	"bufWriteLongBE()"
 1529      72697465 
 1529      4C6F6E67 
 1529      42452829 
 1529      00
 1530              		.text
 1531              		.globl	bufWriteLongBE
 1533              	bufWriteLongBE:
 1534              	.LFB22:
 402:core.c        **** 
 403:core.c        **** // Write a uint16 into the target buffer in little-endian format. The target offset may be outside
 404:core.c        **** // the current extent (or even capacity) of the target buffer.
 405:core.c        **** //
 406:core.c        **** DLLEXPORT(BufferStatus) bufWriteLongBE(
 407:core.c        **** 	struct Buffer *self, uint32 offset, uint32 lword, const char **error)
 408:core.c        **** {
 1535              		.loc 1 408 0
 1536              		.cfi_startproc
 1537 0d13 55       		pushq	%rbp
 1538              		.cfi_def_cfa_offset 16
 1539              		.cfi_offset 6, -16
 1540 0d14 4889E5   		movq	%rsp, %rbp
 1541              		.cfi_def_cfa_register 6
 1542 0d17 4883EC40 		subq	$64, %rsp
 1543 0d1b 48897DD8 		movq	%rdi, -40(%rbp)
 1544 0d1f 8975D4   		movl	%esi, -44(%rbp)
 1545 0d22 8955D0   		movl	%edx, -48(%rbp)
 1546 0d25 48894DC8 		movq	%rcx, -56(%rbp)
 1547              		.loc 1 408 0
 1548 0d29 64488B04 		movq	%fs:40, %rax
 1548      25280000 
 1548      00
 1549 0d32 488945F8 		movq	%rax, -8(%rbp)
 1550 0d36 31C0     		xorl	%eax, %eax
 409:core.c        **** 	BufferStatus status, returnCode = BUF_SUCCESS;
 1551              		.loc 1 409 0
 1552 0d38 C745F000 		movl	$0, -16(%rbp)
 1552      000000
 410:core.c        **** 	union {
 411:core.c        **** 		uint32 lword;
 412:core.c        **** 		uint8 byte[4];
 413:core.c        **** 	} u;
 414:core.c        **** 	u.lword = lword;
 1553              		.loc 1 414 0
 1554 0d3f 8B45D0   		movl	-48(%rbp), %eax
 1555 0d42 8945E0   		movl	%eax, -32(%rbp)
 415:core.c        **** 	status = maybeReallocate(self, offset, 4, error);
 1556              		.loc 1 415 0
 1557 0d45 488B55C8 		movq	-56(%rbp), %rdx
 1558 0d49 8B75D4   		movl	-44(%rbp), %esi
 1559 0d4c 488B45D8 		movq	-40(%rbp), %rax
 1560 0d50 4889D1   		movq	%rdx, %rcx
 1561 0d53 BA040000 		movl	$4, %edx
 1561      00
 1562 0d58 4889C7   		movq	%rax, %rdi
 1563 0d5b E8CEFBFF 		call	maybeReallocate
 1563      FF
 1564 0d60 8945F4   		movl	%eax, -12(%rbp)
 416:core.c        **** 	CHECK_STATUS(status, "bufWriteLongBE()", status);
 1565              		.loc 1 416 0
 1566 0d63 837DF400 		cmpl	$0, -12(%rbp)
 1567 0d67 741B     		je	.L80
 1568              		.loc 1 416 0 is_stmt 0 discriminator 1
 1569 0d69 488B45C8 		movq	-56(%rbp), %rax
 1570 0d6d 488D3500 		leaq	.LC6(%rip), %rsi
 1570      000000
 1571 0d74 4889C7   		movq	%rax, %rdi
 1572 0d77 E8000000 		call	errPrefix@PLT
 1572      00
 1573 0d7c 8B45F4   		movl	-12(%rbp), %eax
 1574 0d7f 8945F0   		movl	%eax, -16(%rbp)
 1575 0d82 EB58     		jmp	.L81
 1576              	.L80:
 417:core.c        **** 	#if BYTE_ORDER == 1234
 418:core.c        **** 		*(self->data + offset) = u.byte[3];
 1577              		.loc 1 418 0 is_stmt 1
 1578 0d84 488B45D8 		movq	-40(%rbp), %rax
 1579 0d88 488B10   		movq	(%rax), %rdx
 1580 0d8b 8B45D4   		movl	-44(%rbp), %eax
 1581 0d8e 4801C2   		addq	%rax, %rdx
 1582 0d91 0FB645E3 		movzbl	-29(%rbp), %eax
 1583 0d95 8802     		movb	%al, (%rdx)
 419:core.c        **** 		*(self->data + offset + 1) = u.byte[2];
 1584              		.loc 1 419 0
 1585 0d97 488B45D8 		movq	-40(%rbp), %rax
 1586 0d9b 488B00   		movq	(%rax), %rax
 1587 0d9e 8B55D4   		movl	-44(%rbp), %edx
 1588 0da1 4883C201 		addq	$1, %rdx
 1589 0da5 4801C2   		addq	%rax, %rdx
 1590 0da8 0FB645E2 		movzbl	-30(%rbp), %eax
 1591 0dac 8802     		movb	%al, (%rdx)
 420:core.c        **** 		*(self->data + offset + 2) = u.byte[1];
 1592              		.loc 1 420 0
 1593 0dae 488B45D8 		movq	-40(%rbp), %rax
 1594 0db2 488B00   		movq	(%rax), %rax
 1595 0db5 8B55D4   		movl	-44(%rbp), %edx
 1596 0db8 4883C202 		addq	$2, %rdx
 1597 0dbc 4801C2   		addq	%rax, %rdx
 1598 0dbf 0FB645E1 		movzbl	-31(%rbp), %eax
 1599 0dc3 8802     		movb	%al, (%rdx)
 421:core.c        **** 		*(self->data + offset + 3) = u.byte[0];
 1600              		.loc 1 421 0
 1601 0dc5 488B45D8 		movq	-40(%rbp), %rax
 1602 0dc9 488B00   		movq	(%rax), %rax
 1603 0dcc 8B55D4   		movl	-44(%rbp), %edx
 1604 0dcf 4883C203 		addq	$3, %rdx
 1605 0dd3 4801C2   		addq	%rax, %rdx
 1606 0dd6 0FB645E0 		movzbl	-32(%rbp), %eax
 1607 0dda 8802     		movb	%al, (%rdx)
 1608              	.L81:
 422:core.c        **** 	#else
 423:core.c        **** 		*(self->data + offset) = u.byte[0];
 424:core.c        **** 		*(self->data + offset + 1) = u.byte[1];
 425:core.c        **** 		*(self->data + offset + 2) = u.byte[2];
 426:core.c        **** 		*(self->data + offset + 3) = u.byte[3];
 427:core.c        **** 	#endif
 428:core.c        **** cleanup:
 429:core.c        **** 	return returnCode;
 1609              		.loc 1 429 0
 1610 0ddc 8B45F0   		movl	-16(%rbp), %eax
 430:core.c        **** }
 1611              		.loc 1 430 0
 1612 0ddf 488B4DF8 		movq	-8(%rbp), %rcx
 1613 0de3 6448330C 		xorq	%fs:40, %rcx
 1613      25280000 
 1613      00
 1614 0dec 7405     		je	.L83
 1615 0dee E8000000 		call	__stack_chk_fail@PLT
 1615      00
 1616              	.L83:
 1617 0df3 C9       		leave
 1618              		.cfi_def_cfa 7, 8
 1619 0df4 C3       		ret
 1620              		.cfi_endproc
 1621              	.LFE22:
 1623              		.section	.rodata
 1624              	.LC7:
 1625 009f 62756657 		.string	"bufWriteConst()"
 1625      72697465 
 1625      436F6E73 
 1625      74282900 
 1626              		.text
 1627              		.globl	bufWriteConst
 1629              	bufWriteConst:
 1630              	.LFB23:
 431:core.c        **** 
 432:core.c        **** // Set a range of bytes of the target buffer to a given value. The target offset may be outside the
 433:core.c        **** // current extent (or even capacity) of the target buffer.
 434:core.c        **** //
 435:core.c        **** DLLEXPORT(BufferStatus) bufWriteConst(
 436:core.c        **** 	struct Buffer *self, uint32 offset, uint8 value, uint32 count, const char **error)
 437:core.c        **** {
 1631              		.loc 1 437 0
 1632              		.cfi_startproc
 1633 0df5 55       		pushq	%rbp
 1634              		.cfi_def_cfa_offset 16
 1635              		.cfi_offset 6, -16
 1636 0df6 4889E5   		movq	%rsp, %rbp
 1637              		.cfi_def_cfa_register 6
 1638 0df9 4883EC30 		subq	$48, %rsp
 1639 0dfd 48897DE8 		movq	%rdi, -24(%rbp)
 1640 0e01 8975E4   		movl	%esi, -28(%rbp)
 1641 0e04 89D0     		movl	%edx, %eax
 1642 0e06 894DDC   		movl	%ecx, -36(%rbp)
 1643 0e09 4C8945D0 		movq	%r8, -48(%rbp)
 1644 0e0d 8845E0   		movb	%al, -32(%rbp)
 438:core.c        **** 	BufferStatus status, returnCode = BUF_SUCCESS;
 1645              		.loc 1 438 0
 1646 0e10 C745F800 		movl	$0, -8(%rbp)
 1646      000000
 439:core.c        **** 	status = maybeReallocate(self, offset, count, error);
 1647              		.loc 1 439 0
 1648 0e17 488B4DD0 		movq	-48(%rbp), %rcx
 1649 0e1b 8B55DC   		movl	-36(%rbp), %edx
 1650 0e1e 8B75E4   		movl	-28(%rbp), %esi
 1651 0e21 488B45E8 		movq	-24(%rbp), %rax
 1652 0e25 4889C7   		movq	%rax, %rdi
 1653 0e28 E801FBFF 		call	maybeReallocate
 1653      FF
 1654 0e2d 8945FC   		movl	%eax, -4(%rbp)
 440:core.c        **** 	CHECK_STATUS(status, "bufWriteConst()", status);
 1655              		.loc 1 440 0
 1656 0e30 837DFC00 		cmpl	$0, -4(%rbp)
 1657 0e34 741B     		je	.L85
 1658              		.loc 1 440 0 is_stmt 0 discriminator 1
 1659 0e36 488B45D0 		movq	-48(%rbp), %rax
 1660 0e3a 488D3500 		leaq	.LC7(%rip), %rsi
 1660      000000
 1661 0e41 4889C7   		movq	%rax, %rdi
 1662 0e44 E8000000 		call	errPrefix@PLT
 1662      00
 1663 0e49 8B45FC   		movl	-4(%rbp), %eax
 1664 0e4c 8945F8   		movl	%eax, -8(%rbp)
 1665 0e4f EB1E     		jmp	.L86
 1666              	.L85:
 441:core.c        **** 	memset(self->data + offset, value, count);
 1667              		.loc 1 441 0 is_stmt 1
 1668 0e51 8B55DC   		movl	-36(%rbp), %edx
 1669 0e54 0FB645E0 		movzbl	-32(%rbp), %eax
 1670 0e58 488B4DE8 		movq	-24(%rbp), %rcx
 1671 0e5c 488B31   		movq	(%rcx), %rsi
 1672 0e5f 8B4DE4   		movl	-28(%rbp), %ecx
 1673 0e62 4801F1   		addq	%rsi, %rcx
 1674 0e65 89C6     		movl	%eax, %esi
 1675 0e67 4889CF   		movq	%rcx, %rdi
 1676 0e6a E8000000 		call	memset@PLT
 1676      00
 1677              	.L86:
 442:core.c        **** cleanup:
 443:core.c        **** 	return returnCode;
 1678              		.loc 1 443 0
 1679 0e6f 8B45F8   		movl	-8(%rbp), %eax
 444:core.c        **** }
 1680              		.loc 1 444 0
 1681 0e72 C9       		leave
 1682              		.cfi_def_cfa 7, 8
 1683 0e73 C3       		ret
 1684              		.cfi_endproc
 1685              	.LFE23:
 1687              		.globl	bufWriteBlock
 1689              	bufWriteBlock:
 1690              	.LFB24:
 445:core.c        **** 
 446:core.c        **** // Copy a bunch of bytes from a source pointer into the buffer. The target address may be outside
 447:core.c        **** // the current extent (or even capacity) of the target buffer.
 448:core.c        **** //
 449:core.c        **** DLLEXPORT(BufferStatus) bufWriteBlock(
 450:core.c        **** 	struct Buffer *self, uint32 offset, const uint8 *ptr, uint32 count, const char **error)
 451:core.c        **** {
 1691              		.loc 1 451 0
 1692              		.cfi_startproc
 1693 0e74 55       		pushq	%rbp
 1694              		.cfi_def_cfa_offset 16
 1695              		.cfi_offset 6, -16
 1696 0e75 4889E5   		movq	%rsp, %rbp
 1697              		.cfi_def_cfa_register 6
 1698 0e78 4883EC30 		subq	$48, %rsp
 1699 0e7c 48897DE8 		movq	%rdi, -24(%rbp)
 1700 0e80 8975E4   		movl	%esi, -28(%rbp)
 1701 0e83 488955D8 		movq	%rdx, -40(%rbp)
 1702 0e87 894DE0   		movl	%ecx, -32(%rbp)
 1703 0e8a 4C8945D0 		movq	%r8, -48(%rbp)
 452:core.c        **** 	BufferStatus status, returnCode = BUF_SUCCESS;
 1704              		.loc 1 452 0
 1705 0e8e C745F800 		movl	$0, -8(%rbp)
 1705      000000
 453:core.c        **** 	status = maybeReallocate(self, offset, count, error);
 1706              		.loc 1 453 0
 1707 0e95 488B4DD0 		movq	-48(%rbp), %rcx
 1708 0e99 8B55E0   		movl	-32(%rbp), %edx
 1709 0e9c 8B75E4   		movl	-28(%rbp), %esi
 1710 0e9f 488B45E8 		movq	-24(%rbp), %rax
 1711 0ea3 4889C7   		movq	%rax, %rdi
 1712 0ea6 E883FAFF 		call	maybeReallocate
 1712      FF
 1713 0eab 8945FC   		movl	%eax, -4(%rbp)
 454:core.c        **** 	CHECK_STATUS(status, "bufWriteConst()", status);
 1714              		.loc 1 454 0
 1715 0eae 837DFC00 		cmpl	$0, -4(%rbp)
 1716 0eb2 741B     		je	.L89
 1717              		.loc 1 454 0 is_stmt 0 discriminator 1
 1718 0eb4 488B45D0 		movq	-48(%rbp), %rax
 1719 0eb8 488D3500 		leaq	.LC7(%rip), %rsi
 1719      000000
 1720 0ebf 4889C7   		movq	%rax, %rdi
 1721 0ec2 E8000000 		call	errPrefix@PLT
 1721      00
 1722 0ec7 8B45FC   		movl	-4(%rbp), %eax
 1723 0eca 8945F8   		movl	%eax, -8(%rbp)
 1724 0ecd EB1F     		jmp	.L90
 1725              	.L89:
 455:core.c        **** 	memcpy(self->data + offset, ptr, count);
 1726              		.loc 1 455 0 is_stmt 1
 1727 0ecf 8B55E0   		movl	-32(%rbp), %edx
 1728 0ed2 488B45E8 		movq	-24(%rbp), %rax
 1729 0ed6 488B08   		movq	(%rax), %rcx
 1730 0ed9 8B45E4   		movl	-28(%rbp), %eax
 1731 0edc 4801C1   		addq	%rax, %rcx
 1732 0edf 488B45D8 		movq	-40(%rbp), %rax
 1733 0ee3 4889C6   		movq	%rax, %rsi
 1734 0ee6 4889CF   		movq	%rcx, %rdi
 1735 0ee9 E8000000 		call	memcpy@PLT
 1735      00
 1736              	.L90:
 456:core.c        **** cleanup:
 457:core.c        **** 	return returnCode;
 1737              		.loc 1 457 0
 1738 0eee 8B45F8   		movl	-8(%rbp), %eax
 458:core.c        **** }
 1739              		.loc 1 458 0
 1740 0ef1 C9       		leave
 1741              		.cfi_def_cfa 7, 8
 1742 0ef2 C3       		ret
 1743              		.cfi_endproc
 1744              	.LFE24:
 1746              	.Letext0:
 1747              		.file 2 "/home/asoreyh/Dropbox/projects/lago/lago-software/acqua/brc/lago/makestuff/common/makestu
 1748              		.file 3 "libbuffer.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 core.c
     /tmp/ccUbrKZR.s:11     .text:0000000000000000 bufInitialise
     /tmp/ccUbrKZR.s:96     .text:00000000000000ba bufDestroy
     /tmp/ccUbrKZR.s:133    .text:0000000000000100 bufDeepCopy
     /tmp/ccUbrKZR.s:261    .text:0000000000000237 bufSwap
     /tmp/ccUbrKZR.s:333    .text:00000000000002d2 bufZeroLength
     /tmp/ccUbrKZR.s:379    .text:0000000000000317 reallocate
     /tmp/ccUbrKZR.s:468    .text:00000000000003d7 bufAppendByte
     /tmp/ccUbrKZR.s:536    .text:000000000000045e bufAppendWordLE
     /tmp/ccUbrKZR.s:627    .text:000000000000052e bufAppendWordBE
     /tmp/ccUbrKZR.s:718    .text:00000000000005fe bufAppendLongLE
     /tmp/ccUbrKZR.s:828    .text:0000000000000706 bufAppendLongBE
     /tmp/ccUbrKZR.s:938    .text:000000000000080e bufAppendConst
     /tmp/ccUbrKZR.s:1009   .text:000000000000089e bufAppendBlock
     /tmp/ccUbrKZR.s:1078   .text:000000000000092e maybeReallocate
     /tmp/ccUbrKZR.s:1214   .text:0000000000000a49 bufWriteByte
     /tmp/ccUbrKZR.s:1275   .text:0000000000000abf bufWriteWordLE
     /tmp/ccUbrKZR.s:1356   .text:0000000000000b78 bufWriteWordBE
     /tmp/ccUbrKZR.s:1437   .text:0000000000000c31 bufWriteLongLE
     /tmp/ccUbrKZR.s:1533   .text:0000000000000d13 bufWriteLongBE
     /tmp/ccUbrKZR.s:1629   .text:0000000000000df5 bufWriteConst
     /tmp/ccUbrKZR.s:1689   .text:0000000000000e74 bufWriteBlock

UNDEFINED SYMBOLS
_GLOBAL_OFFSET_TABLE_
malloc
errRender
free
memcpy
realloc
__stack_chk_fail
memset
errPrefix
