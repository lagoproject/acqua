   1              		.file	"hexio.c"
   2              		.text
   3              	.Ltext0:
   4              		.section	.rodata
   5              	.LC0:
   6 0000 4A756E6B 		.string	"Junk start code at line %lu"
   6      20737461 
   6      72742063 
   6      6F646520 
   6      6174206C 
   7              	.LC1:
   8 001c 4A756E6B 		.string	"Junk byte count at line %lu"
   8      20627974 
   8      6520636F 
   8      756E7420 
   8      6174206C 
   9              	.LC2:
  10 0038 4A756E6B 		.string	"Junk address MSB at line %lu"
  10      20616464 
  10      72657373 
  10      204D5342 
  10      20617420 
  11              	.LC3:
  12 0055 4A756E6B 		.string	"Junk address LSB at line %lu"
  12      20616464 
  12      72657373 
  12      204C5342 
  12      20617420 
  13              	.LC4:
  14 0072 4A756E6B 		.string	"Junk record type at line %lu"
  14      20726563 
  14      6F726420 
  14      74797065 
  14      20617420 
  15              	.LC5:
  16 008f 4A756E6B 		.string	"Junk data byte %d at line %lu"
  16      20646174 
  16      61206279 
  16      74652025 
  16      64206174 
  17              	.LC6:
  18 00ad 4A756E6B 		.string	"Junk checksum at line %lu"
  18      20636865 
  18      636B7375 
  18      6D206174 
  18      206C696E 
  19 00c7 00       		.align 8
  20              	.LC7:
  21 00c8 52656164 		.string	"Read checksum 0x%02X differs from calculated checksum 0x%02X at line %lu"
  21      20636865 
  21      636B7375 
  21      6D203078 
  21      25303258 
  22              	.LC8:
  23 0111 3A253032 		.string	":%02X%04X%02X"
  23      58253034 
  23      58253032 
  23      5800
  24              	.LC9:
  25 011f 25303258 		.string	"%02X"
  25      00
  26 0124 00000000 		.align 8
  27              	.LC10:
  28 0128 536F6D65 		.string	"Some corruption detected at line %lu - some junk at the end of the line perhaps?"
  28      20636F72 
  28      72757074 
  28      696F6E20 
  28      64657465 
  29 0179 00000000 		.align 8
  29      000000
  30              	.LC11:
  31 0180 466F7220 		.string	"For record type EXT_SEG_RECORD, address must be 0x0000 and byteCount must be 0x02 at line
  31      7265636F 
  31      72642074 
  31      79706520 
  31      4558545F 
  32 01de 0000     		.align 8
  33              	.LC12:
  34 01e0 5265636F 		.string	"Record type START_SEG_RECORD not supported at line %lu"
  34      72642074 
  34      79706520 
  34      53544152 
  34      545F5345 
  35 0217 00       		.align 8
  36              	.LC13:
  37 0218 5265636F 		.string	"Record type EXT_LIN_RECORD not supported at line %lu"
  37      72642074 
  37      79706520 
  37      4558545F 
  37      4C494E5F 
  38 024d 000000   		.align 8
  39              	.LC14:
  40 0250 5265636F 		.string	"Record type START_LIN_RECORD not supported at line %lu"
  40      72642074 
  40      79706520 
  40      53544152 
  40      545F4C49 
  41 0287 00       		.align 8
  42              	.LC15:
  43 0288 5265636F 		.string	"Record type 0x%02X not supported at line %lu"
  43      72642074 
  43      79706520 
  43      30782530 
  43      3258206E 
  44              		.text
  45              		.globl	bufProcessLine
  47              	bufProcessLine:
  48              	.LFB4:
  49              		.file 1 "hexio.c"
   1:hexio.c       **** /*
   2:hexio.c       ****  * Copyright (C) 2009-2012 Chris McClelland
   3:hexio.c       ****  *
   4:hexio.c       ****  * This program is free software: you can redistribute it and/or modify
   5:hexio.c       ****  * it under the terms of the GNU Lesser General Public License as published by
   6:hexio.c       ****  * the Free Software Foundation, either version 3 of the License, or
   7:hexio.c       ****  * (at your option) any later version.
   8:hexio.c       ****  *
   9:hexio.c       ****  * This program is distributed in the hope that it will be useful,
  10:hexio.c       ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:hexio.c       ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:hexio.c       ****  * GNU Lesser General Public License for more details.
  13:hexio.c       ****  *
  14:hexio.c       ****  * You should have received a copy of the GNU Lesser General Public License
  15:hexio.c       ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:hexio.c       ****  */
  17:hexio.c       **** 
  18:hexio.c       **** // Utility functions for reading and writing Intel Hex records. The data is stored in the "data"
  19:hexio.c       **** // buffer, and a bitmap of the runs covered by the Intel Hex file is stored in the "writeMap"
  20:hexio.c       **** // buffer. You would think that the "writeMap" buffer is not necessary (why not just assume blocks
  21:hexio.c       **** // of four or more zeros should not appear in the file?). Unfortunately you cannot always assume
  22:hexio.c       **** // such "holes" will have been properly initialised by the target system. In short, given a binary
  23:hexio.c       **** // file, there's no way to tell which runs of zeros must be zero, and which are "don't care".
  24:hexio.c       **** //
  25:hexio.c       **** #include <stdio.h>
  26:hexio.c       **** #include <string.h>
  27:hexio.c       **** #include <liberror.h>
  28:hexio.c       **** #include "libbuffer.h"
  29:hexio.c       **** #include "conv.h"
  30:hexio.c       **** #include "private.h"
  31:hexio.c       **** 
  32:hexio.c       **** #define LINE_MAX 512
  33:hexio.c       **** 
  34:hexio.c       **** typedef enum {
  35:hexio.c       **** 	DATA_RECORD = 0x00,
  36:hexio.c       **** 	EOF_RECORD,
  37:hexio.c       **** 	EXT_SEG_RECORD,
  38:hexio.c       **** 	START_SEG_RECORD,
  39:hexio.c       **** 	EXT_LIN_RECORD,
  40:hexio.c       **** 	START_LIN_RECORD
  41:hexio.c       **** } RecordType;
  42:hexio.c       **** 
  43:hexio.c       **** // Process a single Intel hex record.
  44:hexio.c       **** //   Data record:   ":CCAAAA00DD..SS"
  45:hexio.c       **** //   EOF record:    ":00000001FF"
  46:hexio.c       **** //   ExtSeg record: ":02000002AAAASS"
  47:hexio.c       **** //
  48:hexio.c       **** BufferStatus bufProcessLine(
  49:hexio.c       **** 	const char *sourceLine, uint32 lineNumber, struct Buffer *destData, struct Buffer *destMask,
  50:hexio.c       **** 	uint32 *segment, uint8 *recordType, const char **error)
  51:hexio.c       **** {
  50              		.loc 1 51 0
  51              		.cfi_startproc
  52 0000 55       		pushq	%rbp
  53              		.cfi_def_cfa_offset 16
  54              		.cfi_offset 6, -16
  55 0001 4889E5   		movq	%rsp, %rbp
  56              		.cfi_def_cfa_register 6
  57 0004 4881EC70 		subq	$880, %rsp
  57      030000
  58 000b 4889BDC8 		movq	%rdi, -824(%rbp)
  58      FCFFFF
  59 0012 89B5C4FC 		movl	%esi, -828(%rbp)
  59      FFFF
  60 0018 488995B8 		movq	%rdx, -840(%rbp)
  60      FCFFFF
  61 001f 48898DB0 		movq	%rcx, -848(%rbp)
  61      FCFFFF
  62 0026 4C8985A8 		movq	%r8, -856(%rbp)
  62      FCFFFF
  63 002d 4C898DA0 		movq	%r9, -864(%rbp)
  63      FCFFFF
  64 0034 488B4510 		movq	16(%rbp), %rax
  65 0038 48898598 		movq	%rax, -872(%rbp)
  65      FCFFFF
  66              		.loc 1 51 0
  67 003f 64488B04 		movq	%fs:40, %rax
  67      25280000 
  67      00
  68 0048 488945F8 		movq	%rax, -8(%rbp)
  69 004c 31C0     		xorl	%eax, %eax
  52:hexio.c       **** 	char reconstructedLine[LINE_MAX];
  53:hexio.c       **** 	uint8 thisByte;
  54:hexio.c       **** 	uint8 i, byteCount;
  55:hexio.c       **** 	uint16 address;
  56:hexio.c       **** 	uint8 dataBytes[LINE_MAX/2];
  57:hexio.c       **** 	uint8 readChecksum;
  58:hexio.c       **** 	uint8 calculatedChecksum;
  59:hexio.c       **** 	const char *p;
  60:hexio.c       **** 	BufferStatus status;
  61:hexio.c       **** 
  62:hexio.c       **** 	p = sourceLine;
  70              		.loc 1 62 0
  71 004e 488B85C8 		movq	-824(%rbp), %rax
  71      FCFFFF
  72 0055 488985E8 		movq	%rax, -792(%rbp)
  72      FCFFFF
  63:hexio.c       **** 	// Read the start code - must be ':'
  64:hexio.c       **** 	//
  65:hexio.c       **** 	if ( *p++ != ':' ) {
  73              		.loc 1 65 0
  74 005c 488B85E8 		movq	-792(%rbp), %rax
  74      FCFFFF
  75 0063 488D5001 		leaq	1(%rax), %rdx
  76 0067 488995E8 		movq	%rdx, -792(%rbp)
  76      FCFFFF
  77 006e 0FB600   		movzbl	(%rax), %eax
  78 0071 3C3A     		cmpb	$58, %al
  79 0073 742B     		je	.L2
  66:hexio.c       **** 		errRender(error, "Junk start code at line %lu", lineNumber);
  80              		.loc 1 66 0
  81 0075 8B95C4FC 		movl	-828(%rbp), %edx
  81      FFFF
  82 007b 488B8598 		movq	-872(%rbp), %rax
  82      FCFFFF
  83 0082 488D3500 		leaq	.LC0(%rip), %rsi
  83      000000
  84 0089 4889C7   		movq	%rax, %rdi
  85 008c B8000000 		movl	$0, %eax
  85      00
  86 0091 E8000000 		call	errRender@PLT
  86      00
  67:hexio.c       **** 		return HEX_JUNK_START_CODE;
  87              		.loc 1 67 0
  88 0096 B8070000 		movl	$7, %eax
  88      00
  89 009b E99F0600 		jmp	.L29
  89      00
  90              	.L2:
  68:hexio.c       **** 	}
  69:hexio.c       **** 	
  70:hexio.c       **** 	// Read the byte count
  71:hexio.c       **** 	//
  72:hexio.c       **** 	if ( getHexByte(p, &byteCount) ) {
  91              		.loc 1 72 0
  92 00a0 488D95DE 		leaq	-802(%rbp), %rdx
  92      FCFFFF
  93 00a7 488B85E8 		movq	-792(%rbp), %rax
  93      FCFFFF
  94 00ae 4889D6   		movq	%rdx, %rsi
  95 00b1 4889C7   		movq	%rax, %rdi
  96 00b4 E8000000 		call	getHexByte@PLT
  96      00
  97 00b9 84C0     		testb	%al, %al
  98 00bb 742B     		je	.L4
  73:hexio.c       **** 		errRender(error, "Junk byte count at line %lu", lineNumber);
  99              		.loc 1 73 0
 100 00bd 8B95C4FC 		movl	-828(%rbp), %edx
 100      FFFF
 101 00c3 488B8598 		movq	-872(%rbp), %rax
 101      FCFFFF
 102 00ca 488D3500 		leaq	.LC1(%rip), %rsi
 102      000000
 103 00d1 4889C7   		movq	%rax, %rdi
 104 00d4 B8000000 		movl	$0, %eax
 104      00
 105 00d9 E8000000 		call	errRender@PLT
 105      00
  74:hexio.c       **** 		return HEX_JUNK_BYTE_COUNT;
 106              		.loc 1 74 0
 107 00de B8080000 		movl	$8, %eax
 107      00
 108 00e3 E9570600 		jmp	.L29
 108      00
 109              	.L4:
  75:hexio.c       **** 	}
  76:hexio.c       **** 	p += 2;
 110              		.loc 1 76 0
 111 00e8 488385E8 		addq	$2, -792(%rbp)
 111      FCFFFF02 
  77:hexio.c       **** 	calculatedChecksum = byteCount;
 112              		.loc 1 77 0
 113 00f0 0FB685DE 		movzbl	-802(%rbp), %eax
 113      FCFFFF
 114 00f7 8885E1FC 		movb	%al, -799(%rbp)
 114      FFFF
  78:hexio.c       **** 	
  79:hexio.c       **** 	// Read the MSB of the address
  80:hexio.c       **** 	//
  81:hexio.c       **** 	if ( getHexByte(p, &thisByte) ) {
 115              		.loc 1 81 0
 116 00fd 488D95DD 		leaq	-803(%rbp), %rdx
 116      FCFFFF
 117 0104 488B85E8 		movq	-792(%rbp), %rax
 117      FCFFFF
 118 010b 4889D6   		movq	%rdx, %rsi
 119 010e 4889C7   		movq	%rax, %rdi
 120 0111 E8000000 		call	getHexByte@PLT
 120      00
 121 0116 84C0     		testb	%al, %al
 122 0118 742B     		je	.L5
  82:hexio.c       **** 		errRender(error, "Junk address MSB at line %lu", lineNumber);
 123              		.loc 1 82 0
 124 011a 8B95C4FC 		movl	-828(%rbp), %edx
 124      FFFF
 125 0120 488B8598 		movq	-872(%rbp), %rax
 125      FCFFFF
 126 0127 488D3500 		leaq	.LC2(%rip), %rsi
 126      000000
 127 012e 4889C7   		movq	%rax, %rdi
 128 0131 B8000000 		movl	$0, %eax
 128      00
 129 0136 E8000000 		call	errRender@PLT
 129      00
  83:hexio.c       **** 		return HEX_JUNK_ADDR_MSB;
 130              		.loc 1 83 0
 131 013b B8090000 		movl	$9, %eax
 131      00
 132 0140 E9FA0500 		jmp	.L29
 132      00
 133              	.L5:
  84:hexio.c       **** 	}
  85:hexio.c       **** 	p += 2;
 134              		.loc 1 85 0
 135 0145 488385E8 		addq	$2, -792(%rbp)
 135      FCFFFF02 
  86:hexio.c       **** 	address = thisByte << 8;
 136              		.loc 1 86 0
 137 014d 0FB685DD 		movzbl	-803(%rbp), %eax
 137      FCFFFF
 138 0154 0FB6C0   		movzbl	%al, %eax
 139 0157 C1E008   		sall	$8, %eax
 140 015a 668985E2 		movw	%ax, -798(%rbp)
 140      FCFFFF
  87:hexio.c       **** 	calculatedChecksum += thisByte;
 141              		.loc 1 87 0
 142 0161 0FB685DD 		movzbl	-803(%rbp), %eax
 142      FCFFFF
 143 0168 0085E1FC 		addb	%al, -799(%rbp)
 143      FFFF
  88:hexio.c       **** 	
  89:hexio.c       **** 	// Read the LSB of the address
  90:hexio.c       **** 	//
  91:hexio.c       **** 	if ( getHexByte(p, &thisByte) ) {
 144              		.loc 1 91 0
 145 016e 488D95DD 		leaq	-803(%rbp), %rdx
 145      FCFFFF
 146 0175 488B85E8 		movq	-792(%rbp), %rax
 146      FCFFFF
 147 017c 4889D6   		movq	%rdx, %rsi
 148 017f 4889C7   		movq	%rax, %rdi
 149 0182 E8000000 		call	getHexByte@PLT
 149      00
 150 0187 84C0     		testb	%al, %al
 151 0189 742B     		je	.L6
  92:hexio.c       **** 		errRender(error, "Junk address LSB at line %lu", lineNumber);
 152              		.loc 1 92 0
 153 018b 8B95C4FC 		movl	-828(%rbp), %edx
 153      FFFF
 154 0191 488B8598 		movq	-872(%rbp), %rax
 154      FCFFFF
 155 0198 488D3500 		leaq	.LC3(%rip), %rsi
 155      000000
 156 019f 4889C7   		movq	%rax, %rdi
 157 01a2 B8000000 		movl	$0, %eax
 157      00
 158 01a7 E8000000 		call	errRender@PLT
 158      00
  93:hexio.c       **** 		return HEX_JUNK_ADDR_LSB;
 159              		.loc 1 93 0
 160 01ac B80A0000 		movl	$10, %eax
 160      00
 161 01b1 E9890500 		jmp	.L29
 161      00
 162              	.L6:
  94:hexio.c       **** 	}
  95:hexio.c       **** 	p += 2;
 163              		.loc 1 95 0
 164 01b6 488385E8 		addq	$2, -792(%rbp)
 164      FCFFFF02 
  96:hexio.c       **** 	address |= thisByte;
 165              		.loc 1 96 0
 166 01be 0FB685DD 		movzbl	-803(%rbp), %eax
 166      FCFFFF
 167 01c5 0FB6C0   		movzbl	%al, %eax
 168 01c8 660985E2 		orw	%ax, -798(%rbp)
 168      FCFFFF
  97:hexio.c       **** 	calculatedChecksum += thisByte;
 169              		.loc 1 97 0
 170 01cf 0FB685DD 		movzbl	-803(%rbp), %eax
 170      FCFFFF
 171 01d6 0085E1FC 		addb	%al, -799(%rbp)
 171      FFFF
  98:hexio.c       **** 	
  99:hexio.c       **** 	// Read the record type
 100:hexio.c       **** 	//
 101:hexio.c       **** 	if ( getHexByte(p, recordType) ) {
 172              		.loc 1 101 0
 173 01dc 488B95A0 		movq	-864(%rbp), %rdx
 173      FCFFFF
 174 01e3 488B85E8 		movq	-792(%rbp), %rax
 174      FCFFFF
 175 01ea 4889D6   		movq	%rdx, %rsi
 176 01ed 4889C7   		movq	%rax, %rdi
 177 01f0 E8000000 		call	getHexByte@PLT
 177      00
 178 01f5 84C0     		testb	%al, %al
 179 01f7 742B     		je	.L7
 102:hexio.c       **** 		errRender(error, "Junk record type at line %lu", lineNumber);
 180              		.loc 1 102 0
 181 01f9 8B95C4FC 		movl	-828(%rbp), %edx
 181      FFFF
 182 01ff 488B8598 		movq	-872(%rbp), %rax
 182      FCFFFF
 183 0206 488D3500 		leaq	.LC4(%rip), %rsi
 183      000000
 184 020d 4889C7   		movq	%rax, %rdi
 185 0210 B8000000 		movl	$0, %eax
 185      00
 186 0215 E8000000 		call	errRender@PLT
 186      00
 103:hexio.c       **** 		return HEX_JUNK_REC_TYPE;
 187              		.loc 1 103 0
 188 021a B80B0000 		movl	$11, %eax
 188      00
 189 021f E91B0500 		jmp	.L29
 189      00
 190              	.L7:
 104:hexio.c       **** 	}
 105:hexio.c       **** 	p += 2;
 191              		.loc 1 105 0
 192 0224 488385E8 		addq	$2, -792(%rbp)
 192      FCFFFF02 
 106:hexio.c       **** 	calculatedChecksum += *recordType;
 193              		.loc 1 106 0
 194 022c 488B85A0 		movq	-864(%rbp), %rax
 194      FCFFFF
 195 0233 0FB600   		movzbl	(%rax), %eax
 196 0236 0085E1FC 		addb	%al, -799(%rbp)
 196      FFFF
 107:hexio.c       **** 	
 108:hexio.c       **** 	// Read the data
 109:hexio.c       **** 	//
 110:hexio.c       **** 	for ( i = 0; i < byteCount; i++ ) {
 197              		.loc 1 110 0
 198 023c C685E0FC 		movb	$0, -800(%rbp)
 198      FFFF00
 199 0243 E98B0000 		jmp	.L8
 199      00
 200              	.L10:
 111:hexio.c       **** 		if ( getHexByte(p, &thisByte) ) {
 201              		.loc 1 111 0
 202 0248 488D95DD 		leaq	-803(%rbp), %rdx
 202      FCFFFF
 203 024f 488B85E8 		movq	-792(%rbp), %rax
 203      FCFFFF
 204 0256 4889D6   		movq	%rdx, %rsi
 205 0259 4889C7   		movq	%rax, %rdi
 206 025c E8000000 		call	getHexByte@PLT
 206      00
 207 0261 84C0     		testb	%al, %al
 208 0263 7432     		je	.L9
 112:hexio.c       **** 			errRender(error, "Junk data byte %d at line %lu", i, lineNumber);
 209              		.loc 1 112 0
 210 0265 0FB695E0 		movzbl	-800(%rbp), %edx
 210      FCFFFF
 211 026c 8B8DC4FC 		movl	-828(%rbp), %ecx
 211      FFFF
 212 0272 488B8598 		movq	-872(%rbp), %rax
 212      FCFFFF
 213 0279 488D3500 		leaq	.LC5(%rip), %rsi
 213      000000
 214 0280 4889C7   		movq	%rax, %rdi
 215 0283 B8000000 		movl	$0, %eax
 215      00
 216 0288 E8000000 		call	errRender@PLT
 216      00
 113:hexio.c       **** 			return HEX_JUNK_DATA_BYTE;
 217              		.loc 1 113 0
 218 028d B80D0000 		movl	$13, %eax
 218      00
 219 0292 E9A80400 		jmp	.L29
 219      00
 220              	.L9:
 114:hexio.c       **** 		}
 115:hexio.c       **** 		p += 2;
 221              		.loc 1 115 0 discriminator 2
 222 0297 488385E8 		addq	$2, -792(%rbp)
 222      FCFFFF02 
 116:hexio.c       **** 		dataBytes[i] = thisByte;
 223              		.loc 1 116 0 discriminator 2
 224 029f 0FB685E0 		movzbl	-800(%rbp), %eax
 224      FCFFFF
 225 02a6 0FB695DD 		movzbl	-803(%rbp), %edx
 225      FCFFFF
 226 02ad 4898     		cltq
 227 02af 889405F0 		movb	%dl, -784(%rbp,%rax)
 227      FCFFFF
 117:hexio.c       **** 		calculatedChecksum += thisByte;
 228              		.loc 1 117 0 discriminator 2
 229 02b6 0FB685DD 		movzbl	-803(%rbp), %eax
 229      FCFFFF
 230 02bd 0085E1FC 		addb	%al, -799(%rbp)
 230      FFFF
 110:hexio.c       **** 		if ( getHexByte(p, &thisByte) ) {
 231              		.loc 1 110 0 discriminator 2
 232 02c3 0FB685E0 		movzbl	-800(%rbp), %eax
 232      FCFFFF
 233 02ca 83C001   		addl	$1, %eax
 234 02cd 8885E0FC 		movb	%al, -800(%rbp)
 234      FFFF
 235              	.L8:
 110:hexio.c       **** 		if ( getHexByte(p, &thisByte) ) {
 236              		.loc 1 110 0 is_stmt 0 discriminator 1
 237 02d3 0FB685DE 		movzbl	-802(%rbp), %eax
 237      FCFFFF
 238 02da 3885E0FC 		cmpb	%al, -800(%rbp)
 238      FFFF
 239 02e0 0F8262FF 		jb	.L10
 239      FFFF
 118:hexio.c       **** 	}
 119:hexio.c       **** 	
 120:hexio.c       **** 	// Read the checksum
 121:hexio.c       **** 	//
 122:hexio.c       **** 	if ( getHexByte(p, &readChecksum) ) {
 240              		.loc 1 122 0 is_stmt 1
 241 02e6 488D95DF 		leaq	-801(%rbp), %rdx
 241      FCFFFF
 242 02ed 488B85E8 		movq	-792(%rbp), %rax
 242      FCFFFF
 243 02f4 4889D6   		movq	%rdx, %rsi
 244 02f7 4889C7   		movq	%rax, %rdi
 245 02fa E8000000 		call	getHexByte@PLT
 245      00
 246 02ff 84C0     		testb	%al, %al
 247 0301 742B     		je	.L11
 123:hexio.c       **** 		errRender(error, "Junk checksum at line %lu", lineNumber);
 248              		.loc 1 123 0
 249 0303 8B95C4FC 		movl	-828(%rbp), %edx
 249      FFFF
 250 0309 488B8598 		movq	-872(%rbp), %rax
 250      FCFFFF
 251 0310 488D3500 		leaq	.LC6(%rip), %rsi
 251      000000
 252 0317 4889C7   		movq	%rax, %rdi
 253 031a B8000000 		movl	$0, %eax
 253      00
 254 031f E8000000 		call	errRender@PLT
 254      00
 124:hexio.c       **** 		return HEX_JUNK_CHECKSUM;
 255              		.loc 1 124 0
 256 0324 B80E0000 		movl	$14, %eax
 256      00
 257 0329 E9110400 		jmp	.L29
 257      00
 258              	.L11:
 125:hexio.c       **** 	}
 126:hexio.c       **** 	
 127:hexio.c       **** 	// Calculate the two's complement of the checksum
 128:hexio.c       **** 	//
 129:hexio.c       **** 	calculatedChecksum = (uint8)(256 - calculatedChecksum);
 259              		.loc 1 129 0
 260 032e F69DE1FC 		negb	-799(%rbp)
 260      FFFF
 130:hexio.c       **** 	if ( readChecksum != calculatedChecksum ) {
 261              		.loc 1 130 0
 262 0334 0FB685DF 		movzbl	-801(%rbp), %eax
 262      FCFFFF
 263 033b 3A85E1FC 		cmpb	-799(%rbp), %al
 263      FFFF
 264 0341 743F     		je	.L12
 131:hexio.c       **** 		errRender(
 265              		.loc 1 131 0
 266 0343 0FB68DE1 		movzbl	-799(%rbp), %ecx
 266      FCFFFF
 267 034a 0FB685DF 		movzbl	-801(%rbp), %eax
 267      FCFFFF
 268 0351 0FB6D0   		movzbl	%al, %edx
 269 0354 8BB5C4FC 		movl	-828(%rbp), %esi
 269      FFFF
 270 035a 488B8598 		movq	-872(%rbp), %rax
 270      FCFFFF
 271 0361 4189F0   		movl	%esi, %r8d
 272 0364 488D3500 		leaq	.LC7(%rip), %rsi
 272      000000
 273 036b 4889C7   		movq	%rax, %rdi
 274 036e B8000000 		movl	$0, %eax
 274      00
 275 0373 E8000000 		call	errRender@PLT
 275      00
 132:hexio.c       **** 			error, "Read checksum 0x%02X differs from calculated checksum 0x%02X at line %lu",
 133:hexio.c       **** 			readChecksum, calculatedChecksum, lineNumber);
 134:hexio.c       **** 		return HEX_BAD_CHECKSUM;
 276              		.loc 1 134 0
 277 0378 B80F0000 		movl	$15, %eax
 277      00
 278 037d E9BD0300 		jmp	.L29
 278      00
 279              	.L12:
 135:hexio.c       **** 	}
 136:hexio.c       **** 	
 137:hexio.c       **** 	// Recreate the input data
 138:hexio.c       **** 	//
 139:hexio.c       **** 	sprintf(reconstructedLine, ":%02X%04X%02X", byteCount, address, *recordType);
 280              		.loc 1 139 0
 281 0382 488B85A0 		movq	-864(%rbp), %rax
 281      FCFFFF
 282 0389 0FB600   		movzbl	(%rax), %eax
 283 038c 0FB6F0   		movzbl	%al, %esi
 284 038f 0FB78DE2 		movzwl	-798(%rbp), %ecx
 284      FCFFFF
 285 0396 0FB685DE 		movzbl	-802(%rbp), %eax
 285      FCFFFF
 286 039d 0FB6D0   		movzbl	%al, %edx
 287 03a0 488D85F0 		leaq	-528(%rbp), %rax
 287      FDFFFF
 288 03a7 4189F0   		movl	%esi, %r8d
 289 03aa 488D3500 		leaq	.LC8(%rip), %rsi
 289      000000
 290 03b1 4889C7   		movq	%rax, %rdi
 291 03b4 B8000000 		movl	$0, %eax
 291      00
 292 03b9 E8000000 		call	sprintf@PLT
 292      00
 140:hexio.c       **** 	for ( i = 0; i < byteCount; i++ ) {
 293              		.loc 1 140 0
 294 03be C685E0FC 		movb	$0, -800(%rbp)
 294      FFFF00
 295 03c5 EB54     		jmp	.L13
 296              	.L14:
 141:hexio.c       **** 		sprintf(reconstructedLine + 9 + 2*i, "%02X", dataBytes[i]);
 297              		.loc 1 141 0 discriminator 3
 298 03c7 0FB685E0 		movzbl	-800(%rbp), %eax
 298      FCFFFF
 299 03ce 4898     		cltq
 300 03d0 0FB68405 		movzbl	-784(%rbp,%rax), %eax
 300      F0FCFFFF 
 301 03d8 0FB6C0   		movzbl	%al, %eax
 302 03db 0FB695E0 		movzbl	-800(%rbp), %edx
 302      FCFFFF
 303 03e2 01D2     		addl	%edx, %edx
 304 03e4 4863D2   		movslq	%edx, %rdx
 305 03e7 488D4A09 		leaq	9(%rdx), %rcx
 306 03eb 488D95F0 		leaq	-528(%rbp), %rdx
 306      FDFFFF
 307 03f2 4801D1   		addq	%rdx, %rcx
 308 03f5 89C2     		movl	%eax, %edx
 309 03f7 488D3500 		leaq	.LC9(%rip), %rsi
 309      000000
 310 03fe 4889CF   		movq	%rcx, %rdi
 311 0401 B8000000 		movl	$0, %eax
 311      00
 312 0406 E8000000 		call	sprintf@PLT
 312      00
 140:hexio.c       **** 	for ( i = 0; i < byteCount; i++ ) {
 313              		.loc 1 140 0 discriminator 3
 314 040b 0FB685E0 		movzbl	-800(%rbp), %eax
 314      FCFFFF
 315 0412 83C001   		addl	$1, %eax
 316 0415 8885E0FC 		movb	%al, -800(%rbp)
 316      FFFF
 317              	.L13:
 140:hexio.c       **** 	for ( i = 0; i < byteCount; i++ ) {
 318              		.loc 1 140 0 is_stmt 0 discriminator 1
 319 041b 0FB685DE 		movzbl	-802(%rbp), %eax
 319      FCFFFF
 320 0422 3885E0FC 		cmpb	%al, -800(%rbp)
 320      FFFF
 321 0428 729D     		jb	.L14
 142:hexio.c       **** 	}
 143:hexio.c       **** 	sprintf(reconstructedLine + 9 + byteCount*2, "%02X", readChecksum);
 322              		.loc 1 143 0 is_stmt 1
 323 042a 0FB685DF 		movzbl	-801(%rbp), %eax
 323      FCFFFF
 324 0431 0FB6C0   		movzbl	%al, %eax
 325 0434 0FB695DE 		movzbl	-802(%rbp), %edx
 325      FCFFFF
 326 043b 0FB6D2   		movzbl	%dl, %edx
 327 043e 01D2     		addl	%edx, %edx
 328 0440 4863D2   		movslq	%edx, %rdx
 329 0443 488D4A09 		leaq	9(%rdx), %rcx
 330 0447 488D95F0 		leaq	-528(%rbp), %rdx
 330      FDFFFF
 331 044e 4801D1   		addq	%rdx, %rcx
 332 0451 89C2     		movl	%eax, %edx
 333 0453 488D3500 		leaq	.LC9(%rip), %rsi
 333      000000
 334 045a 4889CF   		movq	%rcx, %rdi
 335 045d B8000000 		movl	$0, %eax
 335      00
 336 0462 E8000000 		call	sprintf@PLT
 336      00
 144:hexio.c       **** 	while ( *p && *p != 0x0D && *p != 0x0A ) {
 337              		.loc 1 144 0
 338 0467 EB08     		jmp	.L15
 339              	.L17:
 145:hexio.c       **** 		p++;
 340              		.loc 1 145 0
 341 0469 488385E8 		addq	$1, -792(%rbp)
 341      FCFFFF01 
 342              	.L15:
 144:hexio.c       **** 	while ( *p && *p != 0x0D && *p != 0x0A ) {
 343              		.loc 1 144 0
 344 0471 488B85E8 		movq	-792(%rbp), %rax
 344      FCFFFF
 345 0478 0FB600   		movzbl	(%rax), %eax
 346 047b 84C0     		testb	%al, %al
 347 047d 741C     		je	.L16
 144:hexio.c       **** 	while ( *p && *p != 0x0D && *p != 0x0A ) {
 348              		.loc 1 144 0 is_stmt 0 discriminator 1
 349 047f 488B85E8 		movq	-792(%rbp), %rax
 349      FCFFFF
 350 0486 0FB600   		movzbl	(%rax), %eax
 351 0489 3C0D     		cmpb	$13, %al
 352 048b 740E     		je	.L16
 144:hexio.c       **** 	while ( *p && *p != 0x0D && *p != 0x0A ) {
 353              		.loc 1 144 0 discriminator 2
 354 048d 488B85E8 		movq	-792(%rbp), %rax
 354      FCFFFF
 355 0494 0FB600   		movzbl	(%rax), %eax
 356 0497 3C0A     		cmpb	$10, %al
 357 0499 75CE     		jne	.L17
 358              	.L16:
 146:hexio.c       **** 	}
 147:hexio.c       **** 	if ( strncmp(sourceLine, reconstructedLine, p - sourceLine) ) {
 359              		.loc 1 147 0 is_stmt 1
 360 049b 488B95E8 		movq	-792(%rbp), %rdx
 360      FCFFFF
 361 04a2 488B85C8 		movq	-824(%rbp), %rax
 361      FCFFFF
 362 04a9 4829C2   		subq	%rax, %rdx
 363 04ac 4889D0   		movq	%rdx, %rax
 364 04af 4889C2   		movq	%rax, %rdx
 365 04b2 488D8DF0 		leaq	-528(%rbp), %rcx
 365      FDFFFF
 366 04b9 488B85C8 		movq	-824(%rbp), %rax
 366      FCFFFF
 367 04c0 4889CE   		movq	%rcx, %rsi
 368 04c3 4889C7   		movq	%rax, %rdi
 369 04c6 E8000000 		call	strncmp@PLT
 369      00
 370 04cb 85C0     		testl	%eax, %eax
 371 04cd 742B     		je	.L18
 148:hexio.c       **** 		errRender(
 372              		.loc 1 148 0
 373 04cf 8B95C4FC 		movl	-828(%rbp), %edx
 373      FFFF
 374 04d5 488B8598 		movq	-872(%rbp), %rax
 374      FCFFFF
 375 04dc 488D3500 		leaq	.LC10(%rip), %rsi
 375      000000
 376 04e3 4889C7   		movq	%rax, %rdi
 377 04e6 B8000000 		movl	$0, %eax
 377      00
 378 04eb E8000000 		call	errRender@PLT
 378      00
 149:hexio.c       **** 			error, "Some corruption detected at line %lu - some junk at the end of the line perhaps?",
 150:hexio.c       **** 			lineNumber);
 151:hexio.c       **** 		return HEX_CORRUPT_LINE;
 379              		.loc 1 151 0
 380 04f0 B8100000 		movl	$16, %eax
 380      00
 381 04f5 E9450200 		jmp	.L29
 381      00
 382              	.L18:
 152:hexio.c       **** 	}
 153:hexio.c       **** 	
 154:hexio.c       **** 	if ( *recordType == DATA_RECORD ) {
 383              		.loc 1 154 0
 384 04fa 488B85A0 		movq	-864(%rbp), %rax
 384      FCFFFF
 385 0501 0FB600   		movzbl	(%rax), %eax
 386 0504 84C0     		testb	%al, %al
 387 0506 0F85C200 		jne	.L19
 387      0000
 155:hexio.c       **** 		// Write into the binary buffer
 156:hexio.c       **** 		//
 157:hexio.c       **** 		status = bufWriteBlock(destData, *segment + address, dataBytes, byteCount, error);
 388              		.loc 1 157 0
 389 050c 0FB685DE 		movzbl	-802(%rbp), %eax
 389      FCFFFF
 390 0513 0FB6C8   		movzbl	%al, %ecx
 391 0516 488B85A8 		movq	-856(%rbp), %rax
 391      FCFFFF
 392 051d 8B10     		movl	(%rax), %edx
 393 051f 0FB785E2 		movzwl	-798(%rbp), %eax
 393      FCFFFF
 394 0526 8D3402   		leal	(%rdx,%rax), %esi
 395 0529 488BBD98 		movq	-872(%rbp), %rdi
 395      FCFFFF
 396 0530 488D95F0 		leaq	-784(%rbp), %rdx
 396      FCFFFF
 397 0537 488B85B8 		movq	-840(%rbp), %rax
 397      FCFFFF
 398 053e 4989F8   		movq	%rdi, %r8
 399 0541 4889C7   		movq	%rax, %rdi
 400 0544 E8000000 		call	bufWriteBlock@PLT
 400      00
 401 0549 8985E4FC 		movl	%eax, -796(%rbp)
 401      FFFF
 158:hexio.c       **** 		if ( status != BUF_SUCCESS ) {
 402              		.loc 1 158 0
 403 054f 83BDE4FC 		cmpl	$0, -796(%rbp)
 403      FFFF00
 404 0556 740B     		je	.L20
 159:hexio.c       **** 			return status;
 405              		.loc 1 159 0
 406 0558 8B85E4FC 		movl	-796(%rbp), %eax
 406      FFFF
 407 055e E9DC0100 		jmp	.L29
 407      00
 408              	.L20:
 160:hexio.c       **** 		}
 161:hexio.c       **** 		if ( destMask ) {
 409              		.loc 1 161 0
 410 0563 4883BDB0 		cmpq	$0, -848(%rbp)
 410      FCFFFF00 
 411 056b 7457     		je	.L21
 162:hexio.c       **** 			status = bufWriteConst(destMask, *segment + address, 0x01, byteCount, error);
 412              		.loc 1 162 0
 413 056d 0FB685DE 		movzbl	-802(%rbp), %eax
 413      FCFFFF
 414 0574 0FB6D0   		movzbl	%al, %edx
 415 0577 488B85A8 		movq	-856(%rbp), %rax
 415      FCFFFF
 416 057e 8B08     		movl	(%rax), %ecx
 417 0580 0FB785E2 		movzwl	-798(%rbp), %eax
 417      FCFFFF
 418 0587 8D3401   		leal	(%rcx,%rax), %esi
 419 058a 488B8D98 		movq	-872(%rbp), %rcx
 419      FCFFFF
 420 0591 488B85B0 		movq	-848(%rbp), %rax
 420      FCFFFF
 421 0598 4989C8   		movq	%rcx, %r8
 422 059b 89D1     		movl	%edx, %ecx
 423 059d BA010000 		movl	$1, %edx
 423      00
 424 05a2 4889C7   		movq	%rax, %rdi
 425 05a5 E8000000 		call	bufWriteConst@PLT
 425      00
 426 05aa 8985E4FC 		movl	%eax, -796(%rbp)
 426      FFFF
 163:hexio.c       **** 			if ( status != BUF_SUCCESS ) {
 427              		.loc 1 163 0
 428 05b0 83BDE4FC 		cmpl	$0, -796(%rbp)
 428      FFFF00
 429 05b7 740B     		je	.L21
 164:hexio.c       **** 				return status;
 430              		.loc 1 164 0
 431 05b9 8B85E4FC 		movl	-796(%rbp), %eax
 431      FFFF
 432 05bf E97B0100 		jmp	.L29
 432      00
 433              	.L21:
 165:hexio.c       **** 			}
 166:hexio.c       **** 		}
 167:hexio.c       **** 		return BUF_SUCCESS;
 434              		.loc 1 167 0
 435 05c4 B8000000 		movl	$0, %eax
 435      00
 436 05c9 E9710100 		jmp	.L29
 436      00
 437              	.L19:
 168:hexio.c       **** 	} else if ( *recordType == EOF_RECORD ) {
 438              		.loc 1 168 0
 439 05ce 488B85A0 		movq	-864(%rbp), %rax
 439      FCFFFF
 440 05d5 0FB600   		movzbl	(%rax), %eax
 441 05d8 3C01     		cmpb	$1, %al
 442 05da 750A     		jne	.L22
 169:hexio.c       **** 		return BUF_SUCCESS;
 443              		.loc 1 169 0
 444 05dc B8000000 		movl	$0, %eax
 444      00
 445 05e1 E9590100 		jmp	.L29
 445      00
 446              	.L22:
 170:hexio.c       **** 	} else if ( *recordType == EXT_SEG_RECORD ) {
 447              		.loc 1 170 0
 448 05e6 488B85A0 		movq	-864(%rbp), %rax
 448      FCFFFF
 449 05ed 0FB600   		movzbl	(%rax), %eax
 450 05f0 3C02     		cmpb	$2, %al
 451 05f2 7573     		jne	.L23
 171:hexio.c       **** 		if ( address != 0x0000 || byteCount != 2 ) {
 452              		.loc 1 171 0
 453 05f4 6683BDE2 		cmpw	$0, -798(%rbp)
 453      FCFFFF00 
 454 05fc 750B     		jne	.L24
 455              		.loc 1 171 0 is_stmt 0 discriminator 1
 456 05fe 0FB685DE 		movzbl	-802(%rbp), %eax
 456      FCFFFF
 457 0605 3C02     		cmpb	$2, %al
 458 0607 742B     		je	.L25
 459              	.L24:
 172:hexio.c       **** 			errRender(
 460              		.loc 1 172 0 is_stmt 1
 461 0609 8B95C4FC 		movl	-828(%rbp), %edx
 461      FFFF
 462 060f 488B8598 		movq	-872(%rbp), %rax
 462      FCFFFF
 463 0616 488D3500 		leaq	.LC11(%rip), %rsi
 463      000000
 464 061d 4889C7   		movq	%rax, %rdi
 465 0620 B8000000 		movl	$0, %eax
 465      00
 466 0625 E8000000 		call	errRender@PLT
 466      00
 173:hexio.c       **** 				error, "For record type EXT_SEG_RECORD, address must be 0x0000 and byteCount must be 0x02 at li
 174:hexio.c       **** 				lineNumber);
 175:hexio.c       **** 			return HEX_BAD_EXT_SEG;
 467              		.loc 1 175 0
 468 062a B8120000 		movl	$18, %eax
 468      00
 469 062f E90B0100 		jmp	.L29
 469      00
 470              	.L25:
 176:hexio.c       **** 		}
 177:hexio.c       **** 		*segment = ((dataBytes[0] << 8) + dataBytes[1]) << 4;
 471              		.loc 1 177 0
 472 0634 0FB685F0 		movzbl	-784(%rbp), %eax
 472      FCFFFF
 473 063b 0FB6C0   		movzbl	%al, %eax
 474 063e C1E008   		sall	$8, %eax
 475 0641 89C2     		movl	%eax, %edx
 476 0643 0FB685F1 		movzbl	-783(%rbp), %eax
 476      FCFFFF
 477 064a 0FB6C0   		movzbl	%al, %eax
 478 064d 01D0     		addl	%edx, %eax
 479 064f C1E004   		sall	$4, %eax
 480 0652 89C2     		movl	%eax, %edx
 481 0654 488B85A8 		movq	-856(%rbp), %rax
 481      FCFFFF
 482 065b 8910     		movl	%edx, (%rax)
 178:hexio.c       **** 		return BUF_SUCCESS;
 483              		.loc 1 178 0
 484 065d B8000000 		movl	$0, %eax
 484      00
 485 0662 E9D80000 		jmp	.L29
 485      00
 486              	.L23:
 179:hexio.c       **** 	} else if ( *recordType == START_SEG_RECORD ) {
 487              		.loc 1 179 0
 488 0667 488B85A0 		movq	-864(%rbp), %rax
 488      FCFFFF
 489 066e 0FB600   		movzbl	(%rax), %eax
 490 0671 3C03     		cmpb	$3, %al
 491 0673 752B     		jne	.L26
 180:hexio.c       **** 		errRender(error, "Record type START_SEG_RECORD not supported at line %lu", lineNumber);
 492              		.loc 1 180 0
 493 0675 8B95C4FC 		movl	-828(%rbp), %edx
 493      FFFF
 494 067b 488B8598 		movq	-872(%rbp), %rax
 494      FCFFFF
 495 0682 488D3500 		leaq	.LC12(%rip), %rsi
 495      000000
 496 0689 4889C7   		movq	%rax, %rdi
 497 068c B8000000 		movl	$0, %eax
 497      00
 498 0691 E8000000 		call	errRender@PLT
 498      00
 181:hexio.c       **** 		return HEX_BAD_REC_TYPE;
 499              		.loc 1 181 0
 500 0696 B80C0000 		movl	$12, %eax
 500      00
 501 069b E99F0000 		jmp	.L29
 501      00
 502              	.L26:
 182:hexio.c       **** 	} else if ( *recordType == EXT_LIN_RECORD ) {
 503              		.loc 1 182 0
 504 06a0 488B85A0 		movq	-864(%rbp), %rax
 504      FCFFFF
 505 06a7 0FB600   		movzbl	(%rax), %eax
 506 06aa 3C04     		cmpb	$4, %al
 507 06ac 7528     		jne	.L27
 183:hexio.c       **** 		errRender(error, "Record type EXT_LIN_RECORD not supported at line %lu", lineNumber);
 508              		.loc 1 183 0
 509 06ae 8B95C4FC 		movl	-828(%rbp), %edx
 509      FFFF
 510 06b4 488B8598 		movq	-872(%rbp), %rax
 510      FCFFFF
 511 06bb 488D3500 		leaq	.LC13(%rip), %rsi
 511      000000
 512 06c2 4889C7   		movq	%rax, %rdi
 513 06c5 B8000000 		movl	$0, %eax
 513      00
 514 06ca E8000000 		call	errRender@PLT
 514      00
 184:hexio.c       **** 		return HEX_BAD_REC_TYPE;
 515              		.loc 1 184 0
 516 06cf B80C0000 		movl	$12, %eax
 516      00
 517 06d4 EB69     		jmp	.L29
 518              	.L27:
 185:hexio.c       **** 	} else if ( *recordType == START_LIN_RECORD ) {
 519              		.loc 1 185 0
 520 06d6 488B85A0 		movq	-864(%rbp), %rax
 520      FCFFFF
 521 06dd 0FB600   		movzbl	(%rax), %eax
 522 06e0 3C05     		cmpb	$5, %al
 523 06e2 7528     		jne	.L28
 186:hexio.c       **** 		errRender(error, "Record type START_LIN_RECORD not supported at line %lu", lineNumber);
 524              		.loc 1 186 0
 525 06e4 8B95C4FC 		movl	-828(%rbp), %edx
 525      FFFF
 526 06ea 488B8598 		movq	-872(%rbp), %rax
 526      FCFFFF
 527 06f1 488D3500 		leaq	.LC14(%rip), %rsi
 527      000000
 528 06f8 4889C7   		movq	%rax, %rdi
 529 06fb B8000000 		movl	$0, %eax
 529      00
 530 0700 E8000000 		call	errRender@PLT
 530      00
 187:hexio.c       **** 		return HEX_BAD_REC_TYPE;
 531              		.loc 1 187 0
 532 0705 B80C0000 		movl	$12, %eax
 532      00
 533 070a EB33     		jmp	.L29
 534              	.L28:
 188:hexio.c       **** 	} else {
 189:hexio.c       **** 		errRender(error, "Record type 0x%02X not supported at line %lu", *recordType, lineNumber);
 535              		.loc 1 189 0
 536 070c 488B85A0 		movq	-864(%rbp), %rax
 536      FCFFFF
 537 0713 0FB600   		movzbl	(%rax), %eax
 538 0716 0FB6D0   		movzbl	%al, %edx
 539 0719 8B8DC4FC 		movl	-828(%rbp), %ecx
 539      FFFF
 540 071f 488B8598 		movq	-872(%rbp), %rax
 540      FCFFFF
 541 0726 488D3500 		leaq	.LC15(%rip), %rsi
 541      000000
 542 072d 4889C7   		movq	%rax, %rdi
 543 0730 B8000000 		movl	$0, %eax
 543      00
 544 0735 E8000000 		call	errRender@PLT
 544      00
 190:hexio.c       **** 		return HEX_BAD_REC_TYPE;
 545              		.loc 1 190 0
 546 073a B80C0000 		movl	$12, %eax
 546      00
 547              	.L29:
 191:hexio.c       **** 	}
 192:hexio.c       **** }
 548              		.loc 1 192 0 discriminator 1
 549 073f 488B7DF8 		movq	-8(%rbp), %rdi
 550 0743 6448333C 		xorq	%fs:40, %rdi
 550      25280000 
 550      00
 551 074c 7405     		je	.L30
 552              		.loc 1 192 0 is_stmt 0
 553 074e E8000000 		call	__stack_chk_fail@PLT
 553      00
 554              	.L30:
 555 0753 C9       		leave
 556              		.cfi_def_cfa 7, 8
 557 0754 C3       		ret
 558              		.cfi_endproc
 559              	.LFE4:
 561              		.section	.rodata
 562              	.LC16:
 563 02b5 726200   		.string	"rb"
 564              	.LC17:
 565 02b8 456D7074 		.string	"Empty file!"
 565      79206669 
 565      6C652100 
 566 02c4 00000000 		.align 8
 567              	.LC18:
 568 02c8 5072656D 		.string	"Premature end of file - no EOF_RECORD found!"
 568      61747572 
 568      6520656E 
 568      64206F66 
 568      2066696C 
 569              		.text
 570              		.globl	bufReadFromIntelHexFile
 572              	bufReadFromIntelHexFile:
 573              	.LFB5:
 193:hexio.c       **** 
 194:hexio.c       **** // Read Intel Hex records from a file.
 195:hexio.c       **** //
 196:hexio.c       **** DLLEXPORT(BufferStatus) bufReadFromIntelHexFile(
 197:hexio.c       **** 	struct Buffer *destData, struct Buffer *destMask, const char *fileName, const char **error)
 198:hexio.c       **** {
 574              		.loc 1 198 0 is_stmt 1
 575              		.cfi_startproc
 576 0755 55       		pushq	%rbp
 577              		.cfi_def_cfa_offset 16
 578              		.cfi_offset 6, -16
 579 0756 4889E5   		movq	%rsp, %rbp
 580              		.cfi_def_cfa_register 6
 581 0759 4881EC50 		subq	$592, %rsp
 581      020000
 582 0760 4889BDC8 		movq	%rdi, -568(%rbp)
 582      FDFFFF
 583 0767 4889B5C0 		movq	%rsi, -576(%rbp)
 583      FDFFFF
 584 076e 488995B8 		movq	%rdx, -584(%rbp)
 584      FDFFFF
 585 0775 48898DB0 		movq	%rcx, -592(%rbp)
 585      FDFFFF
 586              		.loc 1 198 0
 587 077c 64488B04 		movq	%fs:40, %rax
 587      25280000 
 587      00
 588 0785 488945F8 		movq	%rax, -8(%rbp)
 589 0789 31C0     		xorl	%eax, %eax
 199:hexio.c       **** 	uint32 lineNumber;
 200:hexio.c       **** 	uint32 segment = 0x00000000;
 590              		.loc 1 200 0
 591 078b C785DCFD 		movl	$0, -548(%rbp)
 591      FFFF0000 
 591      0000
 201:hexio.c       **** 	char readLine[LINE_MAX];
 202:hexio.c       **** 	BufferStatus status;
 203:hexio.c       **** 	uint8 recordType;
 204:hexio.c       **** 
 205:hexio.c       **** 	// Open the file...
 206:hexio.c       **** 	//
 207:hexio.c       **** 	FILE *file = fopen(fileName, "rb");
 592              		.loc 1 207 0
 593 0795 488B85B8 		movq	-584(%rbp), %rax
 593      FDFFFF
 594 079c 488D3500 		leaq	.LC16(%rip), %rsi
 594      000000
 595 07a3 4889C7   		movq	%rax, %rdi
 596 07a6 E8000000 		call	fopen@PLT
 596      00
 597 07ab 488985E8 		movq	%rax, -536(%rbp)
 597      FDFFFF
 208:hexio.c       **** 	if ( !file ) {
 598              		.loc 1 208 0
 599 07b2 4883BDE8 		cmpq	$0, -536(%rbp)
 599      FDFFFF00 
 600 07ba 7519     		jne	.L32
 209:hexio.c       **** 		errRenderStd(error);
 601              		.loc 1 209 0
 602 07bc 488B85B0 		movq	-592(%rbp), %rax
 602      FDFFFF
 603 07c3 4889C7   		movq	%rax, %rdi
 604 07c6 E8000000 		call	errRenderStd@PLT
 604      00
 210:hexio.c       **** 		return BUF_FOPEN;
 605              		.loc 1 210 0
 606 07cb B8020000 		movl	$2, %eax
 606      00
 607 07d0 E9850100 		jmp	.L40
 607      00
 608              	.L32:
 211:hexio.c       **** 	}
 212:hexio.c       **** 
 213:hexio.c       **** 	// Clear the existing data in the buffer, if any.
 214:hexio.c       **** 	//
 215:hexio.c       **** 	bufZeroLength(destData);
 609              		.loc 1 215 0
 610 07d5 488B85C8 		movq	-568(%rbp), %rax
 610      FDFFFF
 611 07dc 4889C7   		movq	%rax, %rdi
 612 07df E8000000 		call	bufZeroLength@PLT
 612      00
 216:hexio.c       **** 	if ( destMask ) {
 613              		.loc 1 216 0
 614 07e4 4883BDC0 		cmpq	$0, -576(%rbp)
 614      FDFFFF00 
 615 07ec 740F     		je	.L34
 217:hexio.c       **** 		bufZeroLength(destMask);
 616              		.loc 1 217 0
 617 07ee 488B85C0 		movq	-576(%rbp), %rax
 617      FDFFFF
 618 07f5 4889C7   		movq	%rax, %rdi
 619 07f8 E8000000 		call	bufZeroLength@PLT
 619      00
 620              	.L34:
 218:hexio.c       **** 	}
 219:hexio.c       **** 
 220:hexio.c       **** 	// Iterate over every line
 221:hexio.c       **** 	//
 222:hexio.c       **** 	lineNumber = 1;
 621              		.loc 1 222 0
 622 07fd C785E0FD 		movl	$1, -544(%rbp)
 622      FFFF0100 
 622      0000
 223:hexio.c       **** 	if ( !fgets(readLine, LINE_MAX, file) ) {
 623              		.loc 1 223 0
 624 0807 488B95E8 		movq	-536(%rbp), %rdx
 624      FDFFFF
 625 080e 488D85F0 		leaq	-528(%rbp), %rax
 625      FDFFFF
 626 0815 BE000200 		movl	$512, %esi
 626      00
 627 081a 4889C7   		movq	%rax, %rdi
 628 081d E8000000 		call	fgets@PLT
 628      00
 629 0822 4885C0   		testq	%rax, %rax
 630 0825 7534     		jne	.L35
 224:hexio.c       **** 		errRender(error, "Empty file!");
 631              		.loc 1 224 0
 632 0827 488B85B0 		movq	-592(%rbp), %rax
 632      FDFFFF
 633 082e 488D3500 		leaq	.LC17(%rip), %rsi
 633      000000
 634 0835 4889C7   		movq	%rax, %rdi
 635 0838 B8000000 		movl	$0, %eax
 635      00
 636 083d E8000000 		call	errRender@PLT
 636      00
 225:hexio.c       **** 		fclose(file);
 637              		.loc 1 225 0
 638 0842 488B85E8 		movq	-536(%rbp), %rax
 638      FDFFFF
 639 0849 4889C7   		movq	%rax, %rdi
 640 084c E8000000 		call	fclose@PLT
 640      00
 226:hexio.c       **** 		return HEX_EMPTY_FILE;
 641              		.loc 1 226 0
 642 0851 B8060000 		movl	$6, %eax
 642      00
 643 0856 E9FF0000 		jmp	.L40
 643      00
 644              	.L35:
 227:hexio.c       **** 	}
 228:hexio.c       **** 	do {
 229:hexio.c       **** 		status = bufProcessLine(
 645              		.loc 1 229 0
 646 085b 4883EC08 		subq	$8, %rsp
 647 085f 4C8D85DB 		leaq	-549(%rbp), %r8
 647      FDFFFF
 648 0866 488DBDDC 		leaq	-548(%rbp), %rdi
 648      FDFFFF
 649 086d 488B8DC0 		movq	-576(%rbp), %rcx
 649      FDFFFF
 650 0874 488B95C8 		movq	-568(%rbp), %rdx
 650      FDFFFF
 651 087b 8BB5E0FD 		movl	-544(%rbp), %esi
 651      FFFF
 652 0881 488D85F0 		leaq	-528(%rbp), %rax
 652      FDFFFF
 653 0888 FFB5B0FD 		pushq	-592(%rbp)
 653      FFFF
 654 088e 4D89C1   		movq	%r8, %r9
 655 0891 4989F8   		movq	%rdi, %r8
 656 0894 4889C7   		movq	%rax, %rdi
 657 0897 E8000000 		call	bufProcessLine@PLT
 657      00
 658 089c 4883C410 		addq	$16, %rsp
 659 08a0 8985E4FD 		movl	%eax, -540(%rbp)
 659      FFFF
 230:hexio.c       **** 			readLine, lineNumber, destData, destMask, &segment, &recordType, error);
 231:hexio.c       **** 		if ( status != BUF_SUCCESS ) {
 660              		.loc 1 231 0
 661 08a6 83BDE4FD 		cmpl	$0, -540(%rbp)
 661      FFFF00
 662 08ad 741A     		je	.L36
 232:hexio.c       **** 			fclose(file);
 663              		.loc 1 232 0
 664 08af 488B85E8 		movq	-536(%rbp), %rax
 664      FDFFFF
 665 08b6 4889C7   		movq	%rax, %rdi
 666 08b9 E8000000 		call	fclose@PLT
 666      00
 233:hexio.c       **** 			return status;
 667              		.loc 1 233 0
 668 08be 8B85E4FD 		movl	-540(%rbp), %eax
 668      FFFF
 669 08c4 E9910000 		jmp	.L40
 669      00
 670              	.L36:
 234:hexio.c       **** 		}
 235:hexio.c       **** 		lineNumber++;
 671              		.loc 1 235 0
 672 08c9 8385E0FD 		addl	$1, -544(%rbp)
 672      FFFF01
 236:hexio.c       **** 	} while ( (recordType == DATA_RECORD || recordType == EXT_SEG_RECORD) &&
 673              		.loc 1 236 0
 674 08d0 0FB685DB 		movzbl	-549(%rbp), %eax
 674      FDFFFF
 237:hexio.c       **** 	          fgets(readLine, LINE_MAX, file) );
 675              		.loc 1 237 0
 676 08d7 84C0     		testb	%al, %al
 677 08d9 740B     		je	.L37
 236:hexio.c       **** 	} while ( (recordType == DATA_RECORD || recordType == EXT_SEG_RECORD) &&
 678              		.loc 1 236 0 discriminator 1
 679 08db 0FB685DB 		movzbl	-549(%rbp), %eax
 679      FDFFFF
 680 08e2 3C02     		cmpb	$2, %al
 681 08e4 7524     		jne	.L38
 682              	.L37:
 683              		.loc 1 237 0 discriminator 1
 684 08e6 488B95E8 		movq	-536(%rbp), %rdx
 684      FDFFFF
 685 08ed 488D85F0 		leaq	-528(%rbp), %rax
 685      FDFFFF
 686 08f4 BE000200 		movl	$512, %esi
 686      00
 687 08f9 4889C7   		movq	%rax, %rdi
 688 08fc E8000000 		call	fgets@PLT
 688      00
 236:hexio.c       **** 	} while ( (recordType == DATA_RECORD || recordType == EXT_SEG_RECORD) &&
 689              		.loc 1 236 0 discriminator 1
 690 0901 4885C0   		testq	%rax, %rax
 691 0904 0F8551FF 		jne	.L35
 691      FFFF
 692              	.L38:
 238:hexio.c       **** 
 239:hexio.c       **** 	// Make sure the file terminated correctly
 240:hexio.c       **** 	//
 241:hexio.c       **** 	if ( recordType != EOF_RECORD ) {
 693              		.loc 1 241 0
 694 090a 0FB685DB 		movzbl	-549(%rbp), %eax
 694      FDFFFF
 695 0911 3C01     		cmpb	$1, %al
 696 0913 7431     		je	.L39
 242:hexio.c       **** 		errRender(error, "Premature end of file - no EOF_RECORD found!");
 697              		.loc 1 242 0
 698 0915 488B85B0 		movq	-592(%rbp), %rax
 698      FDFFFF
 699 091c 488D3500 		leaq	.LC18(%rip), %rsi
 699      000000
 700 0923 4889C7   		movq	%rax, %rdi
 701 0926 B8000000 		movl	$0, %eax
 701      00
 702 092b E8000000 		call	errRender@PLT
 702      00
 243:hexio.c       **** 		fclose(file);
 703              		.loc 1 243 0
 704 0930 488B85E8 		movq	-536(%rbp), %rax
 704      FDFFFF
 705 0937 4889C7   		movq	%rax, %rdi
 706 093a E8000000 		call	fclose@PLT
 706      00
 244:hexio.c       **** 		return HEX_MISSING_EOF;
 707              		.loc 1 244 0
 708 093f B8110000 		movl	$17, %eax
 708      00
 709 0944 EB14     		jmp	.L40
 710              	.L39:
 245:hexio.c       **** 	}
 246:hexio.c       **** 
 247:hexio.c       **** 	// Close the file and exit
 248:hexio.c       **** 	//
 249:hexio.c       **** 	fclose(file);
 711              		.loc 1 249 0
 712 0946 488B85E8 		movq	-536(%rbp), %rax
 712      FDFFFF
 713 094d 4889C7   		movq	%rax, %rdi
 714 0950 E8000000 		call	fclose@PLT
 714      00
 250:hexio.c       **** 	return BUF_SUCCESS;
 715              		.loc 1 250 0
 716 0955 B8000000 		movl	$0, %eax
 716      00
 717              	.L40:
 251:hexio.c       **** }
 718              		.loc 1 251 0 discriminator 1
 719 095a 488B4DF8 		movq	-8(%rbp), %rcx
 720 095e 6448330C 		xorq	%fs:40, %rcx
 720      25280000 
 720      00
 721 0967 7405     		je	.L41
 722              		.loc 1 251 0 is_stmt 0
 723 0969 E8000000 		call	__stack_chk_fail@PLT
 723      00
 724              	.L41:
 725 096e C9       		leave
 726              		.cfi_def_cfa 7, 8
 727 096f C3       		ret
 728              		.cfi_endproc
 729              	.LFE5:
 732              	writeHexByte:
 733              	.LFB6:
 252:hexio.c       **** 
 253:hexio.c       **** // Write the supplied byte as two hex digits
 254:hexio.c       **** //
 255:hexio.c       **** static void writeHexByte(uint8 byte, FILE *file) {
 734              		.loc 1 255 0 is_stmt 1
 735              		.cfi_startproc
 736 0970 55       		pushq	%rbp
 737              		.cfi_def_cfa_offset 16
 738              		.cfi_offset 6, -16
 739 0971 4889E5   		movq	%rsp, %rbp
 740              		.cfi_def_cfa_register 6
 741 0974 4883EC10 		subq	$16, %rsp
 742 0978 89F8     		movl	%edi, %eax
 743 097a 488975F0 		movq	%rsi, -16(%rbp)
 744 097e 8845FC   		movb	%al, -4(%rbp)
 256:hexio.c       **** 	fputc(getHexUpperNibble(byte), file);
 745              		.loc 1 256 0
 746 0981 0FB645FC 		movzbl	-4(%rbp), %eax
 747 0985 89C7     		movl	%eax, %edi
 748 0987 E8000000 		call	getHexUpperNibble@PLT
 748      00
 749 098c 0FBEC0   		movsbl	%al, %eax
 750 098f 488B55F0 		movq	-16(%rbp), %rdx
 751 0993 4889D6   		movq	%rdx, %rsi
 752 0996 89C7     		movl	%eax, %edi
 753 0998 E8000000 		call	fputc@PLT
 753      00
 257:hexio.c       **** 	fputc(getHexLowerNibble(byte), file);
 754              		.loc 1 257 0
 755 099d 0FB645FC 		movzbl	-4(%rbp), %eax
 756 09a1 89C7     		movl	%eax, %edi
 757 09a3 E8000000 		call	getHexLowerNibble@PLT
 757      00
 758 09a8 0FBEC0   		movsbl	%al, %eax
 759 09ab 488B55F0 		movq	-16(%rbp), %rdx
 760 09af 4889D6   		movq	%rdx, %rsi
 761 09b2 89C7     		movl	%eax, %edi
 762 09b4 E8000000 		call	fputc@PLT
 762      00
 258:hexio.c       **** }
 763              		.loc 1 258 0
 764 09b9 C9       		leave
 765              		.cfi_def_cfa 7, 8
 766 09ba C3       		ret
 767              		.cfi_endproc
 768              	.LFE6:
 771              	writeHexWordBE:
 772              	.LFB7:
 259:hexio.c       **** 
 260:hexio.c       **** // Write the supplied word as four hex digits, in big-endian format (most significant byte first).
 261:hexio.c       **** //
 262:hexio.c       **** static void writeHexWordBE(uint16 word, FILE *file) {
 773              		.loc 1 262 0
 774              		.cfi_startproc
 775 09bb 55       		pushq	%rbp
 776              		.cfi_def_cfa_offset 16
 777              		.cfi_offset 6, -16
 778 09bc 4889E5   		movq	%rsp, %rbp
 779              		.cfi_def_cfa_register 6
 780 09bf 4883EC10 		subq	$16, %rsp
 781 09c3 89F8     		movl	%edi, %eax
 782 09c5 488975F0 		movq	%rsi, -16(%rbp)
 783 09c9 668945FC 		movw	%ax, -4(%rbp)
 263:hexio.c       **** 	fputc(getHexUpperNibble(word >> 8), file);
 784              		.loc 1 263 0
 785 09cd 0FB745FC 		movzwl	-4(%rbp), %eax
 786 09d1 66C1E808 		shrw	$8, %ax
 787 09d5 0FB6C0   		movzbl	%al, %eax
 788 09d8 89C7     		movl	%eax, %edi
 789 09da E8000000 		call	getHexUpperNibble@PLT
 789      00
 790 09df 0FBEC0   		movsbl	%al, %eax
 791 09e2 488B55F0 		movq	-16(%rbp), %rdx
 792 09e6 4889D6   		movq	%rdx, %rsi
 793 09e9 89C7     		movl	%eax, %edi
 794 09eb E8000000 		call	fputc@PLT
 794      00
 264:hexio.c       **** 	fputc(getHexLowerNibble(word >> 8), file);
 795              		.loc 1 264 0
 796 09f0 0FB745FC 		movzwl	-4(%rbp), %eax
 797 09f4 66C1E808 		shrw	$8, %ax
 798 09f8 0FB6C0   		movzbl	%al, %eax
 799 09fb 89C7     		movl	%eax, %edi
 800 09fd E8000000 		call	getHexLowerNibble@PLT
 800      00
 801 0a02 0FBEC0   		movsbl	%al, %eax
 802 0a05 488B55F0 		movq	-16(%rbp), %rdx
 803 0a09 4889D6   		movq	%rdx, %rsi
 804 0a0c 89C7     		movl	%eax, %edi
 805 0a0e E8000000 		call	fputc@PLT
 805      00
 265:hexio.c       **** 	fputc(getHexUpperNibble(word & 0xFF), file);
 806              		.loc 1 265 0
 807 0a13 0FB745FC 		movzwl	-4(%rbp), %eax
 808 0a17 0FB6C0   		movzbl	%al, %eax
 809 0a1a 89C7     		movl	%eax, %edi
 810 0a1c E8000000 		call	getHexUpperNibble@PLT
 810      00
 811 0a21 0FBEC0   		movsbl	%al, %eax
 812 0a24 488B55F0 		movq	-16(%rbp), %rdx
 813 0a28 4889D6   		movq	%rdx, %rsi
 814 0a2b 89C7     		movl	%eax, %edi
 815 0a2d E8000000 		call	fputc@PLT
 815      00
 266:hexio.c       **** 	fputc(getHexLowerNibble(word & 0xFF), file);
 816              		.loc 1 266 0
 817 0a32 0FB745FC 		movzwl	-4(%rbp), %eax
 818 0a36 0FB6C0   		movzbl	%al, %eax
 819 0a39 89C7     		movl	%eax, %edi
 820 0a3b E8000000 		call	getHexLowerNibble@PLT
 820      00
 821 0a40 0FBEC0   		movsbl	%al, %eax
 822 0a43 488B55F0 		movq	-16(%rbp), %rdx
 823 0a47 4889D6   		movq	%rdx, %rsi
 824 0a4a 89C7     		movl	%eax, %edi
 825 0a4c E8000000 		call	fputc@PLT
 825      00
 267:hexio.c       **** }
 826              		.loc 1 267 0
 827 0a51 C9       		leave
 828              		.cfi_def_cfa 7, 8
 829 0a52 C3       		ret
 830              		.cfi_endproc
 831              	.LFE7:
 833              		.globl	bufDeriveMask
 835              	bufDeriveMask:
 836              	.LFB8:
 268:hexio.c       **** 
 269:hexio.c       **** BufferStatus bufDeriveMask(
 270:hexio.c       **** 	const struct Buffer *sourceData, struct Buffer *destMask, const char **error)
 271:hexio.c       **** {
 837              		.loc 1 271 0
 838              		.cfi_startproc
 839 0a53 55       		pushq	%rbp
 840              		.cfi_def_cfa_offset 16
 841              		.cfi_offset 6, -16
 842 0a54 4889E5   		movq	%rsp, %rbp
 843              		.cfi_def_cfa_register 6
 844 0a57 4883EC30 		subq	$48, %rsp
 845 0a5b 48897DE8 		movq	%rdi, -24(%rbp)
 846 0a5f 488975E0 		movq	%rsi, -32(%rbp)
 847 0a63 488955D8 		movq	%rdx, -40(%rbp)
 272:hexio.c       **** 	uint32 address, count, i;
 273:hexio.c       **** 	BufferStatus bStatus;
 274:hexio.c       **** 	bufZeroLength(destMask);
 848              		.loc 1 274 0
 849 0a67 488B45E0 		movq	-32(%rbp), %rax
 850 0a6b 4889C7   		movq	%rax, %rdi
 851 0a6e E8000000 		call	bufZeroLength@PLT
 851      00
 275:hexio.c       **** 	bStatus = bufAppendConst(destMask, 0x01, sourceData->length, error);
 852              		.loc 1 275 0
 853 0a73 488B45E8 		movq	-24(%rbp), %rax
 854 0a77 8B5008   		movl	8(%rax), %edx
 855 0a7a 488B4DD8 		movq	-40(%rbp), %rcx
 856 0a7e 488B45E0 		movq	-32(%rbp), %rax
 857 0a82 BE010000 		movl	$1, %esi
 857      00
 858 0a87 4889C7   		movq	%rax, %rdi
 859 0a8a E8000000 		call	bufAppendConst@PLT
 859      00
 860 0a8f 8945FC   		movl	%eax, -4(%rbp)
 276:hexio.c       **** 	if ( bStatus != BUF_SUCCESS ) {
 861              		.loc 1 276 0
 862 0a92 837DFC00 		cmpl	$0, -4(%rbp)
 863 0a96 7408     		je	.L45
 277:hexio.c       **** 		return bStatus;
 864              		.loc 1 277 0
 865 0a98 8B45FC   		movl	-4(%rbp), %eax
 866 0a9b E9DB0000 		jmp	.L46
 866      00
 867              	.L45:
 278:hexio.c       **** 	}
 279:hexio.c       **** 	address = 0x00000000;
 868              		.loc 1 279 0
 869 0aa0 C745F000 		movl	$0, -16(%rbp)
 869      000000
 280:hexio.c       **** 	while ( address < destMask->length ) {
 870              		.loc 1 280 0
 871 0aa7 E9BA0000 		jmp	.L47
 871      00
 872              	.L59:
 281:hexio.c       **** 		while ( address < destMask->length && sourceData->data[address] != sourceData->fill ) {
 873              		.loc 1 281 0
 874 0aac EB04     		jmp	.L48
 875              	.L50:
 282:hexio.c       **** 			address++;
 876              		.loc 1 282 0
 877 0aae 8345F001 		addl	$1, -16(%rbp)
 878              	.L48:
 281:hexio.c       **** 		while ( address < destMask->length && sourceData->data[address] != sourceData->fill ) {
 879              		.loc 1 281 0
 880 0ab2 488B45E0 		movq	-32(%rbp), %rax
 881 0ab6 8B4008   		movl	8(%rax), %eax
 882 0ab9 3B45F0   		cmpl	-16(%rbp), %eax
 883 0abc 761C     		jbe	.L49
 281:hexio.c       **** 		while ( address < destMask->length && sourceData->data[address] != sourceData->fill ) {
 884              		.loc 1 281 0 is_stmt 0 discriminator 1
 885 0abe 488B45E8 		movq	-24(%rbp), %rax
 886 0ac2 488B10   		movq	(%rax), %rdx
 887 0ac5 8B45F0   		movl	-16(%rbp), %eax
 888 0ac8 4801D0   		addq	%rdx, %rax
 889 0acb 0FB610   		movzbl	(%rax), %edx
 890 0ace 488B45E8 		movq	-24(%rbp), %rax
 891 0ad2 0FB64010 		movzbl	16(%rax), %eax
 892 0ad6 38C2     		cmpb	%al, %dl
 893 0ad8 75D4     		jne	.L50
 894              	.L49:
 283:hexio.c       **** 		}
 284:hexio.c       **** 		if ( address == destMask->length ) {
 895              		.loc 1 284 0 is_stmt 1
 896 0ada 488B45E0 		movq	-32(%rbp), %rax
 897 0ade 8B4008   		movl	8(%rax), %eax
 898 0ae1 3B45F0   		cmpl	-16(%rbp), %eax
 899 0ae4 7505     		jne	.L51
 285:hexio.c       **** 			break;
 900              		.loc 1 285 0
 901 0ae6 E98B0000 		jmp	.L52
 901      00
 902              	.L51:
 286:hexio.c       **** 		}
 287:hexio.c       **** 		count = 1;
 903              		.loc 1 287 0
 904 0aeb C745F401 		movl	$1, -12(%rbp)
 904      000000
 288:hexio.c       **** 		while ( address + count < destMask->length &&
 905              		.loc 1 288 0
 906 0af2 EB04     		jmp	.L53
 907              	.L55:
 289:hexio.c       **** 		        sourceData->data[address + count] == sourceData->fill )
 290:hexio.c       **** 		{
 291:hexio.c       **** 			count++;
 908              		.loc 1 291 0
 909 0af4 8345F401 		addl	$1, -12(%rbp)
 910              	.L53:
 288:hexio.c       **** 		while ( address + count < destMask->length &&
 911              		.loc 1 288 0
 912 0af8 8B55F0   		movl	-16(%rbp), %edx
 913 0afb 8B45F4   		movl	-12(%rbp), %eax
 914 0afe 01C2     		addl	%eax, %edx
 915 0b00 488B45E0 		movq	-32(%rbp), %rax
 916 0b04 8B4008   		movl	8(%rax), %eax
 917 0b07 39C2     		cmpl	%eax, %edx
 918 0b09 7323     		jnb	.L54
 289:hexio.c       **** 		        sourceData->data[address + count] == sourceData->fill )
 919              		.loc 1 289 0 discriminator 1
 920 0b0b 488B45E8 		movq	-24(%rbp), %rax
 921 0b0f 488B00   		movq	(%rax), %rax
 922 0b12 8B4DF0   		movl	-16(%rbp), %ecx
 923 0b15 8B55F4   		movl	-12(%rbp), %edx
 924 0b18 01CA     		addl	%ecx, %edx
 925 0b1a 89D2     		movl	%edx, %edx
 926 0b1c 4801D0   		addq	%rdx, %rax
 927 0b1f 0FB610   		movzbl	(%rax), %edx
 928 0b22 488B45E8 		movq	-24(%rbp), %rax
 929 0b26 0FB64010 		movzbl	16(%rax), %eax
 288:hexio.c       **** 		while ( address + count < destMask->length &&
 930              		.loc 1 288 0 discriminator 1
 931 0b2a 38C2     		cmpb	%al, %dl
 932 0b2c 74C6     		je	.L55
 933              	.L54:
 292:hexio.c       **** 		}
 293:hexio.c       **** 		if ( count >= 8 ) {
 934              		.loc 1 293 0
 935 0b2e 837DF407 		cmpl	$7, -12(%rbp)
 936 0b32 762C     		jbe	.L56
 294:hexio.c       **** 			for ( i = 0; i < count; i++ ) {
 937              		.loc 1 294 0
 938 0b34 C745F800 		movl	$0, -8(%rbp)
 938      000000
 939 0b3b EB1B     		jmp	.L57
 940              	.L58:
 295:hexio.c       **** 				destMask->data[address + i] = 0x00;
 941              		.loc 1 295 0 discriminator 3
 942 0b3d 488B45E0 		movq	-32(%rbp), %rax
 943 0b41 488B00   		movq	(%rax), %rax
 944 0b44 8B4DF0   		movl	-16(%rbp), %ecx
 945 0b47 8B55F8   		movl	-8(%rbp), %edx
 946 0b4a 01CA     		addl	%ecx, %edx
 947 0b4c 89D2     		movl	%edx, %edx
 948 0b4e 4801D0   		addq	%rdx, %rax
 949 0b51 C60000   		movb	$0, (%rax)
 294:hexio.c       **** 			for ( i = 0; i < count; i++ ) {
 950              		.loc 1 294 0 discriminator 3
 951 0b54 8345F801 		addl	$1, -8(%rbp)
 952              	.L57:
 294:hexio.c       **** 			for ( i = 0; i < count; i++ ) {
 953              		.loc 1 294 0 is_stmt 0 discriminator 1
 954 0b58 8B45F8   		movl	-8(%rbp), %eax
 955 0b5b 3B45F4   		cmpl	-12(%rbp), %eax
 956 0b5e 72DD     		jb	.L58
 957              	.L56:
 296:hexio.c       **** 			}
 297:hexio.c       **** 		}
 298:hexio.c       **** 		address += count;
 958              		.loc 1 298 0 is_stmt 1
 959 0b60 8B45F4   		movl	-12(%rbp), %eax
 960 0b63 0145F0   		addl	%eax, -16(%rbp)
 961              	.L47:
 280:hexio.c       **** 		while ( address < destMask->length && sourceData->data[address] != sourceData->fill ) {
 962              		.loc 1 280 0
 963 0b66 488B45E0 		movq	-32(%rbp), %rax
 964 0b6a 8B4008   		movl	8(%rax), %eax
 965 0b6d 3B45F0   		cmpl	-16(%rbp), %eax
 966 0b70 0F8736FF 		ja	.L59
 966      FFFF
 967              	.L52:
 299:hexio.c       **** 	}
 300:hexio.c       **** 	return BUF_SUCCESS;
 968              		.loc 1 300 0
 969 0b76 B8000000 		movl	$0, %eax
 969      00
 970              	.L46:
 301:hexio.c       **** }
 971              		.loc 1 301 0
 972 0b7b C9       		leave
 973              		.cfi_def_cfa 7, 8
 974 0b7c C3       		ret
 975              		.cfi_endproc
 976              	.LFE8:
 978              		.section	.rodata
 979              	.LC19:
 980 02f5 776200   		.string	"wb"
 981              		.align 8
 982              	.LC20:
 983 02f8 5365676D 		.string	"Segment addresses > 0xFFFF are not supported"
 983      656E7420 
 983      61646472 
 983      65737365 
 983      73203E20 
 984              	.LC21:
 985 0325 3A303230 		.string	":020000"
 985      30303000 
 986              	.LC22:
 987 032d 3A303030 		.string	":00000001FF\n"
 987      30303030 
 987      3146460A 
 987      00
 988              		.text
 989              		.globl	bufWriteToIntelHexFile
 991              	bufWriteToIntelHexFile:
 992              	.LFB9:
 302:hexio.c       **** 
 303:hexio.c       **** // Write the supplied buffer as Intel hex records with the stated line length to a file, using the
 304:hexio.c       **** // supplied mask. If the mask is null, one is derived from the data, either compressed or
 305:hexio.c       **** // uncompressed.
 306:hexio.c       **** //
 307:hexio.c       **** DLLEXPORT(BufferStatus) bufWriteToIntelHexFile(
 308:hexio.c       **** 	const struct Buffer *sourceData, const struct Buffer *sourceMask, const char *fileName,
 309:hexio.c       **** 	uint8 lineLength, bool compress, const char **error)
 310:hexio.c       **** {
 993              		.loc 1 310 0
 994              		.cfi_startproc
 995 0b7d 55       		pushq	%rbp
 996              		.cfi_def_cfa_offset 16
 997              		.cfi_offset 6, -16
 998 0b7e 4889E5   		movq	%rsp, %rbp
 999              		.cfi_def_cfa_register 6
 1000 0b81 4883C480 		addq	$-128, %rsp
 1001 0b85 48897DA8 		movq	%rdi, -88(%rbp)
 1002 0b89 488975A0 		movq	%rsi, -96(%rbp)
 1003 0b8d 48895598 		movq	%rdx, -104(%rbp)
 1004 0b91 89C8     		movl	%ecx, %eax
 1005 0b93 4489C2   		movl	%r8d, %edx
 1006 0b96 4C894D88 		movq	%r9, -120(%rbp)
 1007 0b9a 884594   		movb	%al, -108(%rbp)
 1008 0b9d 885590   		movb	%dl, -112(%rbp)
 1009              		.loc 1 310 0
 1010 0ba0 64488B04 		movq	%fs:40, %rax
 1010      25280000 
 1010      00
 1011 0ba9 488945F8 		movq	%rax, -8(%rbp)
 1012 0bad 31C0     		xorl	%eax, %eax
 311:hexio.c       **** 	BufferStatus status, returnCode = BUF_SUCCESS;
 1013              		.loc 1 311 0
 1014 0baf C745C400 		movl	$0, -60(%rbp)
 1014      000000
 312:hexio.c       **** 	struct Buffer tmpSourceMask;
 313:hexio.c       **** 	bool usedTmpSourceMask = false;
 1015              		.loc 1 313 0
 1016 0bb6 C645BF00 		movb	$0, -65(%rbp)
 314:hexio.c       **** 	uint32 address = 0x00000000;
 1017              		.loc 1 314 0
 1018 0bba C745C800 		movl	$0, -56(%rbp)
 1018      000000
 315:hexio.c       **** 	uint32 ceiling = 0x00000000;
 1019              		.loc 1 315 0
 1020 0bc1 C745CC00 		movl	$0, -52(%rbp)
 1020      000000
 316:hexio.c       **** 	uint32 segment;
 317:hexio.c       **** 	uint8 i, calculatedChecksum, maxBytesToWrite, bytesToWrite;
 318:hexio.c       **** 	FILE *file = fopen(fileName, "wb");
 1021              		.loc 1 318 0
 1022 0bc8 488B4598 		movq	-104(%rbp), %rax
 1023 0bcc 488D3500 		leaq	.LC19(%rip), %rsi
 1023      000000
 1024 0bd3 4889C7   		movq	%rax, %rdi
 1025 0bd6 E8000000 		call	fopen@PLT
 1025      00
 1026 0bdb 488945D8 		movq	%rax, -40(%rbp)
 319:hexio.c       **** 	if ( !file ) {
 1027              		.loc 1 319 0
 1028 0bdf 48837DD8 		cmpq	$0, -40(%rbp)
 1028      00
 1029 0be4 7516     		jne	.L61
 320:hexio.c       **** 		errRenderStd(error);
 1030              		.loc 1 320 0
 1031 0be6 488B4588 		movq	-120(%rbp), %rax
 1032 0bea 4889C7   		movq	%rax, %rdi
 1033 0bed E8000000 		call	errRenderStd@PLT
 1033      00
 321:hexio.c       **** 		return BUF_FOPEN;
 1034              		.loc 1 321 0
 1035 0bf2 B8020000 		movl	$2, %eax
 1035      00
 1036 0bf7 E9590300 		jmp	.L85
 1036      00
 1037              	.L61:
 322:hexio.c       **** 	}
 323:hexio.c       **** 	if ( !sourceMask ) {
 1038              		.loc 1 323 0
 1039 0bfc 48837DA0 		cmpq	$0, -96(%rbp)
 1039      00
 1040 0c01 0F859E00 		jne	.L63
 1040      0000
 324:hexio.c       **** 		// No sourceMask was supplied; we can either assume we need to write everything,
 325:hexio.c       **** 		// or we can try to compress the data, assuming holes where there exist ranges
 326:hexio.c       **** 		// of the sourceData's fill byte.
 327:hexio.c       **** 		//
 328:hexio.c       **** 		status = bufInitialise(&tmpSourceMask, 1024, 0x00, error);
 1041              		.loc 1 328 0
 1042 0c07 488B5588 		movq	-120(%rbp), %rdx
 1043 0c0b 488D45E0 		leaq	-32(%rbp), %rax
 1044 0c0f 4889D1   		movq	%rdx, %rcx
 1045 0c12 BA000000 		movl	$0, %edx
 1045      00
 1046 0c17 BE000400 		movl	$1024, %esi
 1046      00
 1047 0c1c 4889C7   		movq	%rax, %rdi
 1048 0c1f E8000000 		call	bufInitialise@PLT
 1048      00
 1049 0c24 8945D0   		movl	%eax, -48(%rbp)
 329:hexio.c       **** 		if ( status != BUF_SUCCESS ) {
 1050              		.loc 1 329 0
 1051 0c27 837DD000 		cmpl	$0, -48(%rbp)
 1052 0c2b 740B     		je	.L64
 330:hexio.c       **** 			returnCode = status;
 1053              		.loc 1 330 0
 1054 0c2d 8B45D0   		movl	-48(%rbp), %eax
 1055 0c30 8945C4   		movl	%eax, -60(%rbp)
 331:hexio.c       **** 			goto cleanupFile;
 1056              		.loc 1 331 0
 1057 0c33 E90E0300 		jmp	.L65
 1057      00
 1058              	.L64:
 332:hexio.c       **** 		}
 333:hexio.c       **** 		sourceMask = &tmpSourceMask;
 1059              		.loc 1 333 0
 1060 0c38 488D45E0 		leaq	-32(%rbp), %rax
 1061 0c3c 488945A0 		movq	%rax, -96(%rbp)
 334:hexio.c       **** 		usedTmpSourceMask = true;
 1062              		.loc 1 334 0
 1063 0c40 C645BF01 		movb	$1, -65(%rbp)
 335:hexio.c       **** 		if ( compress ) {
 1064              		.loc 1 335 0
 1065 0c44 807D9000 		cmpb	$0, -112(%rbp)
 1066 0c48 742B     		je	.L66
 336:hexio.c       **** 			status = bufDeriveMask(sourceData, &tmpSourceMask, error);
 1067              		.loc 1 336 0
 1068 0c4a 488B5588 		movq	-120(%rbp), %rdx
 1069 0c4e 488D4DE0 		leaq	-32(%rbp), %rcx
 1070 0c52 488B45A8 		movq	-88(%rbp), %rax
 1071 0c56 4889CE   		movq	%rcx, %rsi
 1072 0c59 4889C7   		movq	%rax, %rdi
 1073 0c5c E8000000 		call	bufDeriveMask@PLT
 1073      00
 1074 0c61 8945D0   		movl	%eax, -48(%rbp)
 337:hexio.c       **** 			if ( status != BUF_SUCCESS ) {
 1075              		.loc 1 337 0
 1076 0c64 837DD000 		cmpl	$0, -48(%rbp)
 1077 0c68 743B     		je	.L63
 338:hexio.c       **** 				returnCode = status;
 1078              		.loc 1 338 0
 1079 0c6a 8B45D0   		movl	-48(%rbp), %eax
 1080 0c6d 8945C4   		movl	%eax, -60(%rbp)
 339:hexio.c       **** 				goto cleanupBuffer;
 1081              		.loc 1 339 0
 1082 0c70 E9BF0200 		jmp	.L67
 1082      00
 1083              	.L66:
 340:hexio.c       **** 			}
 341:hexio.c       **** 		} else {
 342:hexio.c       **** 			status = bufAppendConst(&tmpSourceMask, 0x01, sourceData->length, error);
 1084              		.loc 1 342 0
 1085 0c75 488B45A8 		movq	-88(%rbp), %rax
 1086 0c79 8B5008   		movl	8(%rax), %edx
 1087 0c7c 488B4D88 		movq	-120(%rbp), %rcx
 1088 0c80 488D45E0 		leaq	-32(%rbp), %rax
 1089 0c84 BE010000 		movl	$1, %esi
 1089      00
 1090 0c89 4889C7   		movq	%rax, %rdi
 1091 0c8c E8000000 		call	bufAppendConst@PLT
 1091      00
 1092 0c91 8945D0   		movl	%eax, -48(%rbp)
 343:hexio.c       **** 			if ( status != BUF_SUCCESS ) {
 1093              		.loc 1 343 0
 1094 0c94 837DD000 		cmpl	$0, -48(%rbp)
 1095 0c98 740B     		je	.L63
 344:hexio.c       **** 				returnCode = status;
 1096              		.loc 1 344 0
 1097 0c9a 8B45D0   		movl	-48(%rbp), %eax
 1098 0c9d 8945C4   		movl	%eax, -60(%rbp)
 345:hexio.c       **** 				goto cleanupBuffer;
 1099              		.loc 1 345 0
 1100 0ca0 E98F0200 		jmp	.L67
 1100      00
 1101              	.L63:
 346:hexio.c       **** 			}
 347:hexio.c       **** 		}
 348:hexio.c       **** 	}
 349:hexio.c       **** 
 350:hexio.c       **** 	do {
 351:hexio.c       **** 		ceiling += 0x10000;
 1102              		.loc 1 351 0
 1103 0ca5 8145CC00 		addl	$65536, -52(%rbp)
 1103      000100
 352:hexio.c       **** 		if ( ceiling > sourceMask->length ) {
 1104              		.loc 1 352 0
 1105 0cac 488B45A0 		movq	-96(%rbp), %rax
 1106 0cb0 8B4008   		movl	8(%rax), %eax
 1107 0cb3 3B45CC   		cmpl	-52(%rbp), %eax
 1108 0cb6 730A     		jnb	.L68
 353:hexio.c       **** 			ceiling = sourceMask->length;
 1109              		.loc 1 353 0
 1110 0cb8 488B45A0 		movq	-96(%rbp), %rax
 1111 0cbc 8B4008   		movl	8(%rax), %eax
 1112 0cbf 8945CC   		movl	%eax, -52(%rbp)
 1113              	.L68:
 354:hexio.c       **** 		}
 355:hexio.c       **** 		while ( address < ceiling ) {
 1114              		.loc 1 355 0
 1115 0cc2 E9720100 		jmp	.L69
 1115      00
 1116              	.L82:
 356:hexio.c       **** 			// Find the next run in the sourceMask
 357:hexio.c       **** 			while ( address < ceiling && !sourceMask->data[address] ) {
 1117              		.loc 1 357 0
 1118 0cc7 EB04     		jmp	.L70
 1119              	.L72:
 358:hexio.c       **** 				address++;
 1120              		.loc 1 358 0
 1121 0cc9 8345C801 		addl	$1, -56(%rbp)
 1122              	.L70:
 357:hexio.c       **** 				address++;
 1123              		.loc 1 357 0
 1124 0ccd 8B45C8   		movl	-56(%rbp), %eax
 1125 0cd0 3B45CC   		cmpl	-52(%rbp), %eax
 1126 0cd3 7314     		jnb	.L71
 357:hexio.c       **** 				address++;
 1127              		.loc 1 357 0 is_stmt 0 discriminator 1
 1128 0cd5 488B45A0 		movq	-96(%rbp), %rax
 1129 0cd9 488B10   		movq	(%rax), %rdx
 1130 0cdc 8B45C8   		movl	-56(%rbp), %eax
 1131 0cdf 4801D0   		addq	%rdx, %rax
 1132 0ce2 0FB600   		movzbl	(%rax), %eax
 1133 0ce5 84C0     		testb	%al, %al
 1134 0ce7 74E0     		je	.L72
 1135              	.L71:
 359:hexio.c       **** 			}
 360:hexio.c       **** 			// If we hit the end of the sourceMask, break out of this while loop
 361:hexio.c       **** 			if ( address == ceiling ) {
 1136              		.loc 1 361 0 is_stmt 1
 1137 0ce9 8B45C8   		movl	-56(%rbp), %eax
 1138 0cec 3B45CC   		cmpl	-52(%rbp), %eax
 1139 0cef 7505     		jne	.L73
 362:hexio.c       **** 				break;
 1140              		.loc 1 362 0
 1141 0cf1 E94F0100 		jmp	.L74
 1141      00
 1142              	.L73:
 363:hexio.c       **** 			}
 364:hexio.c       **** 			if ( address + lineLength > ceiling ) {
 1143              		.loc 1 364 0
 1144 0cf6 0FB65594 		movzbl	-108(%rbp), %edx
 1145 0cfa 8B45C8   		movl	-56(%rbp), %eax
 1146 0cfd 01D0     		addl	%edx, %eax
 1147 0cff 3B45CC   		cmpl	-52(%rbp), %eax
 1148 0d02 7611     		jbe	.L75
 365:hexio.c       **** 				// there are fewer than lineLength bytes remaining
 366:hexio.c       **** 				maxBytesToWrite = (uint8)(ceiling - address);
 1149              		.loc 1 366 0
 1150 0d04 8B45CC   		movl	-52(%rbp), %eax
 1151 0d07 89C2     		movl	%eax, %edx
 1152 0d09 8B45C8   		movl	-56(%rbp), %eax
 1153 0d0c 29C2     		subl	%eax, %edx
 1154 0d0e 89D0     		movl	%edx, %eax
 1155 0d10 8845C2   		movb	%al, -62(%rbp)
 1156 0d13 EB07     		jmp	.L76
 1157              	.L75:
 367:hexio.c       **** 			} else {
 368:hexio.c       **** 				// there are lineLength or more bytes remaining
 369:hexio.c       **** 				maxBytesToWrite = lineLength;
 1158              		.loc 1 369 0
 1159 0d15 0FB64594 		movzbl	-108(%rbp), %eax
 1160 0d19 8845C2   		movb	%al, -62(%rbp)
 1161              	.L76:
 370:hexio.c       **** 			}
 371:hexio.c       **** 			// find out how many bytes are in this run
 372:hexio.c       **** 			bytesToWrite = 0;
 1162              		.loc 1 372 0
 1163 0d1c C645C300 		movb	$0, -61(%rbp)
 373:hexio.c       **** 			while ( bytesToWrite < maxBytesToWrite && sourceMask->data[address + bytesToWrite] ) {
 1164              		.loc 1 373 0
 1165 0d20 EB0A     		jmp	.L77
 1166              	.L79:
 374:hexio.c       **** 				bytesToWrite++;
 1167              		.loc 1 374 0
 1168 0d22 0FB645C3 		movzbl	-61(%rbp), %eax
 1169 0d26 83C001   		addl	$1, %eax
 1170 0d29 8845C3   		movb	%al, -61(%rbp)
 1171              	.L77:
 373:hexio.c       **** 			while ( bytesToWrite < maxBytesToWrite && sourceMask->data[address + bytesToWrite] ) {
 1172              		.loc 1 373 0
 1173 0d2c 0FB645C3 		movzbl	-61(%rbp), %eax
 1174 0d30 3A45C2   		cmpb	-62(%rbp), %al
 1175 0d33 731C     		jnb	.L78
 373:hexio.c       **** 			while ( bytesToWrite < maxBytesToWrite && sourceMask->data[address + bytesToWrite] ) {
 1176              		.loc 1 373 0 is_stmt 0 discriminator 1
 1177 0d35 488B45A0 		movq	-96(%rbp), %rax
 1178 0d39 488B00   		movq	(%rax), %rax
 1179 0d3c 0FB64DC3 		movzbl	-61(%rbp), %ecx
 1180 0d40 8B55C8   		movl	-56(%rbp), %edx
 1181 0d43 01CA     		addl	%ecx, %edx
 1182 0d45 89D2     		movl	%edx, %edx
 1183 0d47 4801D0   		addq	%rdx, %rax
 1184 0d4a 0FB600   		movzbl	(%rax), %eax
 1185 0d4d 84C0     		testb	%al, %al
 1186 0d4f 75D1     		jne	.L79
 1187              	.L78:
 375:hexio.c       **** 			}
 376:hexio.c       **** 			fputc(':', file);
 1188              		.loc 1 376 0 is_stmt 1
 1189 0d51 488B45D8 		movq	-40(%rbp), %rax
 1190 0d55 4889C6   		movq	%rax, %rsi
 1191 0d58 BF3A0000 		movl	$58, %edi
 1191      00
 1192 0d5d E8000000 		call	fputc@PLT
 1192      00
 377:hexio.c       **** 			writeHexByte(bytesToWrite, file);
 1193              		.loc 1 377 0
 1194 0d62 0FB645C3 		movzbl	-61(%rbp), %eax
 1195 0d66 488B55D8 		movq	-40(%rbp), %rdx
 1196 0d6a 4889D6   		movq	%rdx, %rsi
 1197 0d6d 89C7     		movl	%eax, %edi
 1198 0d6f E8FCFBFF 		call	writeHexByte
 1198      FF
 378:hexio.c       **** 			writeHexWordBE(address & 0xFFFF, file);
 1199              		.loc 1 378 0
 1200 0d74 8B45C8   		movl	-56(%rbp), %eax
 1201 0d77 0FB7C0   		movzwl	%ax, %eax
 1202 0d7a 488B55D8 		movq	-40(%rbp), %rdx
 1203 0d7e 4889D6   		movq	%rdx, %rsi
 1204 0d81 89C7     		movl	%eax, %edi
 1205 0d83 E833FCFF 		call	writeHexWordBE
 1205      FF
 379:hexio.c       **** 			writeHexByte(DATA_RECORD, file);
 1206              		.loc 1 379 0
 1207 0d88 488B45D8 		movq	-40(%rbp), %rax
 1208 0d8c 4889C6   		movq	%rax, %rsi
 1209 0d8f BF000000 		movl	$0, %edi
 1209      00
 1210 0d94 E8D7FBFF 		call	writeHexByte
 1210      FF
 380:hexio.c       **** 			calculatedChecksum = bytesToWrite;
 1211              		.loc 1 380 0
 1212 0d99 0FB645C3 		movzbl	-61(%rbp), %eax
 1213 0d9d 8845C1   		movb	%al, -63(%rbp)
 381:hexio.c       **** 			calculatedChecksum += (uint8)(address >> 8);
 1214              		.loc 1 381 0
 1215 0da0 8B45C8   		movl	-56(%rbp), %eax
 1216 0da3 C1E808   		shrl	$8, %eax
 1217 0da6 0045C1   		addb	%al, -63(%rbp)
 382:hexio.c       **** 			calculatedChecksum += address & 0xFF;
 1218              		.loc 1 382 0
 1219 0da9 8B45C8   		movl	-56(%rbp), %eax
 1220 0dac 0045C1   		addb	%al, -63(%rbp)
 383:hexio.c       **** 			for ( i = 0; i < bytesToWrite; i++ ) {
 1221              		.loc 1 383 0
 1222 0daf C645C000 		movb	$0, -64(%rbp)
 1223 0db3 EB4E     		jmp	.L80
 1224              	.L81:
 384:hexio.c       **** 				writeHexByte(sourceData->data[address + i], file);
 1225              		.loc 1 384 0 discriminator 3
 1226 0db5 488B45A8 		movq	-88(%rbp), %rax
 1227 0db9 488B00   		movq	(%rax), %rax
 1228 0dbc 0FB64DC0 		movzbl	-64(%rbp), %ecx
 1229 0dc0 8B55C8   		movl	-56(%rbp), %edx
 1230 0dc3 01CA     		addl	%ecx, %edx
 1231 0dc5 89D2     		movl	%edx, %edx
 1232 0dc7 4801D0   		addq	%rdx, %rax
 1233 0dca 0FB600   		movzbl	(%rax), %eax
 1234 0dcd 0FB6C0   		movzbl	%al, %eax
 1235 0dd0 488B55D8 		movq	-40(%rbp), %rdx
 1236 0dd4 4889D6   		movq	%rdx, %rsi
 1237 0dd7 89C7     		movl	%eax, %edi
 1238 0dd9 E892FBFF 		call	writeHexByte
 1238      FF
 385:hexio.c       **** 				calculatedChecksum += sourceData->data[address + i];
 1239              		.loc 1 385 0 discriminator 3
 1240 0dde 488B45A8 		movq	-88(%rbp), %rax
 1241 0de2 488B00   		movq	(%rax), %rax
 1242 0de5 0FB64DC0 		movzbl	-64(%rbp), %ecx
 1243 0de9 8B55C8   		movl	-56(%rbp), %edx
 1244 0dec 01CA     		addl	%ecx, %edx
 1245 0dee 89D2     		movl	%edx, %edx
 1246 0df0 4801D0   		addq	%rdx, %rax
 1247 0df3 0FB600   		movzbl	(%rax), %eax
 1248 0df6 0045C1   		addb	%al, -63(%rbp)
 383:hexio.c       **** 			for ( i = 0; i < bytesToWrite; i++ ) {
 1249              		.loc 1 383 0 discriminator 3
 1250 0df9 0FB645C0 		movzbl	-64(%rbp), %eax
 1251 0dfd 83C001   		addl	$1, %eax
 1252 0e00 8845C0   		movb	%al, -64(%rbp)
 1253              	.L80:
 383:hexio.c       **** 			for ( i = 0; i < bytesToWrite; i++ ) {
 1254              		.loc 1 383 0 is_stmt 0 discriminator 1
 1255 0e03 0FB645C0 		movzbl	-64(%rbp), %eax
 1256 0e07 3A45C3   		cmpb	-61(%rbp), %al
 1257 0e0a 72A9     		jb	.L81
 386:hexio.c       **** 			}
 387:hexio.c       **** 			calculatedChecksum = (uint8)(256 - calculatedChecksum);
 1258              		.loc 1 387 0 is_stmt 1
 1259 0e0c F65DC1   		negb	-63(%rbp)
 388:hexio.c       **** 			writeHexByte(calculatedChecksum, file);
 1260              		.loc 1 388 0
 1261 0e0f 0FB645C1 		movzbl	-63(%rbp), %eax
 1262 0e13 488B55D8 		movq	-40(%rbp), %rdx
 1263 0e17 4889D6   		movq	%rdx, %rsi
 1264 0e1a 89C7     		movl	%eax, %edi
 1265 0e1c E84FFBFF 		call	writeHexByte
 1265      FF
 389:hexio.c       **** 			fputc('\n', file);
 1266              		.loc 1 389 0
 1267 0e21 488B45D8 		movq	-40(%rbp), %rax
 1268 0e25 4889C6   		movq	%rax, %rsi
 1269 0e28 BF0A0000 		movl	$10, %edi
 1269      00
 1270 0e2d E8000000 		call	fputc@PLT
 1270      00
 390:hexio.c       **** 			address += bytesToWrite;
 1271              		.loc 1 390 0
 1272 0e32 0FB645C3 		movzbl	-61(%rbp), %eax
 1273 0e36 0145C8   		addl	%eax, -56(%rbp)
 1274              	.L69:
 355:hexio.c       **** 			// Find the next run in the sourceMask
 1275              		.loc 1 355 0
 1276 0e39 8B45C8   		movl	-56(%rbp), %eax
 1277 0e3c 3B45CC   		cmpl	-52(%rbp), %eax
 1278 0e3f 0F8282FE 		jb	.L82
 1278      FFFF
 1279              	.L74:
 391:hexio.c       **** 		}
 392:hexio.c       **** 		if ( address < sourceMask->length ) {
 1280              		.loc 1 392 0
 1281 0e45 488B45A0 		movq	-96(%rbp), %rax
 1282 0e49 8B4008   		movl	8(%rax), %eax
 1283 0e4c 3B45C8   		cmpl	-56(%rbp), %eax
 1284 0e4f 0F86B200 		jbe	.L83
 1284      0000
 393:hexio.c       **** 			segment = address >> 4;
 1285              		.loc 1 393 0
 1286 0e55 8B45C8   		movl	-56(%rbp), %eax
 1287 0e58 C1E804   		shrl	$4, %eax
 1288 0e5b 8945D4   		movl	%eax, -44(%rbp)
 394:hexio.c       **** 			if ( segment > 0xFFFF ) {
 1289              		.loc 1 394 0
 1290 0e5e 817DD4FF 		cmpl	$65535, -44(%rbp)
 1290      FF0000
 1291 0e65 7624     		jbe	.L84
 395:hexio.c       **** 				errRender(error, "Segment addresses > 0xFFFF are not supported");
 1292              		.loc 1 395 0
 1293 0e67 488B4588 		movq	-120(%rbp), %rax
 1294 0e6b 488D3500 		leaq	.LC20(%rip), %rsi
 1294      000000
 1295 0e72 4889C7   		movq	%rax, %rdi
 1296 0e75 B8000000 		movl	$0, %eax
 1296      00
 1297 0e7a E8000000 		call	errRender@PLT
 1297      00
 396:hexio.c       **** 				returnCode = HEX_BAD_EXT_SEG;
 1298              		.loc 1 396 0
 1299 0e7f C745C412 		movl	$18, -60(%rbp)
 1299      000000
 397:hexio.c       **** 				goto cleanupBuffer;
 1300              		.loc 1 397 0
 1301 0e86 E9A90000 		jmp	.L67
 1301      00
 1302              	.L84:
 398:hexio.c       **** 			}
 399:hexio.c       **** 			calculatedChecksum =
 400:hexio.c       **** 				(uint8)(256 - 2 - EXT_SEG_RECORD - (uint8)(segment >> 8) - (segment & 0xFF));
 1303              		.loc 1 400 0
 1304 0e8b 8B45D4   		movl	-44(%rbp), %eax
 1305 0e8e C1E808   		shrl	$8, %eax
 1306 0e91 F7D8     		negl	%eax
 1307 0e93 89C2     		movl	%eax, %edx
 1308 0e95 8B45D4   		movl	-44(%rbp), %eax
 1309 0e98 29C2     		subl	%eax, %edx
 1310 0e9a 89D0     		movl	%edx, %eax
 399:hexio.c       **** 				(uint8)(256 - 2 - EXT_SEG_RECORD - (uint8)(segment >> 8) - (segment & 0xFF));
 1311              		.loc 1 399 0
 1312 0e9c 83E804   		subl	$4, %eax
 1313 0e9f 8845C1   		movb	%al, -63(%rbp)
 401:hexio.c       **** 			fwrite(":020000", 1, 7, file);
 1314              		.loc 1 401 0
 1315 0ea2 488B45D8 		movq	-40(%rbp), %rax
 1316 0ea6 4889C1   		movq	%rax, %rcx
 1317 0ea9 BA070000 		movl	$7, %edx
 1317      00
 1318 0eae BE010000 		movl	$1, %esi
 1318      00
 1319 0eb3 488D3D00 		leaq	.LC21(%rip), %rdi
 1319      000000
 1320 0eba E8000000 		call	fwrite@PLT
 1320      00
 402:hexio.c       **** 			writeHexByte(EXT_SEG_RECORD, file);
 1321              		.loc 1 402 0
 1322 0ebf 488B45D8 		movq	-40(%rbp), %rax
 1323 0ec3 4889C6   		movq	%rax, %rsi
 1324 0ec6 BF020000 		movl	$2, %edi
 1324      00
 1325 0ecb E8A0FAFF 		call	writeHexByte
 1325      FF
 403:hexio.c       **** 			writeHexWordBE((uint16)segment, file);
 1326              		.loc 1 403 0
 1327 0ed0 8B45D4   		movl	-44(%rbp), %eax
 1328 0ed3 0FB7C0   		movzwl	%ax, %eax
 1329 0ed6 488B55D8 		movq	-40(%rbp), %rdx
 1330 0eda 4889D6   		movq	%rdx, %rsi
 1331 0edd 89C7     		movl	%eax, %edi
 1332 0edf E8D7FAFF 		call	writeHexWordBE
 1332      FF
 404:hexio.c       **** 			writeHexByte(calculatedChecksum, file);
 1333              		.loc 1 404 0
 1334 0ee4 0FB645C1 		movzbl	-63(%rbp), %eax
 1335 0ee8 488B55D8 		movq	-40(%rbp), %rdx
 1336 0eec 4889D6   		movq	%rdx, %rsi
 1337 0eef 89C7     		movl	%eax, %edi
 1338 0ef1 E87AFAFF 		call	writeHexByte
 1338      FF
 405:hexio.c       **** 			fputc('\n', file);
 1339              		.loc 1 405 0
 1340 0ef6 488B45D8 		movq	-40(%rbp), %rax
 1341 0efa 4889C6   		movq	%rax, %rsi
 1342 0efd BF0A0000 		movl	$10, %edi
 1342      00
 1343 0f02 E8000000 		call	fputc@PLT
 1343      00
 1344              	.L83:
 406:hexio.c       **** 		}
 407:hexio.c       **** 	} while ( address < sourceMask->length );
 1345              		.loc 1 407 0
 1346 0f07 488B45A0 		movq	-96(%rbp), %rax
 1347 0f0b 8B4008   		movl	8(%rax), %eax
 1348 0f0e 3B45C8   		cmpl	-56(%rbp), %eax
 1349 0f11 0F878EFD 		ja	.L63
 1349      FFFF
 408:hexio.c       **** 	fwrite(":00000001FF\n", 1, 12, file);
 1350              		.loc 1 408 0
 1351 0f17 488B45D8 		movq	-40(%rbp), %rax
 1352 0f1b 4889C1   		movq	%rax, %rcx
 1353 0f1e BA0C0000 		movl	$12, %edx
 1353      00
 1354 0f23 BE010000 		movl	$1, %esi
 1354      00
 1355 0f28 488D3D00 		leaq	.LC22(%rip), %rdi
 1355      000000
 1356 0f2f E8000000 		call	fwrite@PLT
 1356      00
 1357              	.L67:
 409:hexio.c       **** cleanupBuffer:
 410:hexio.c       **** 	if ( usedTmpSourceMask ) {
 1358              		.loc 1 410 0
 1359 0f34 807DBF00 		cmpb	$0, -65(%rbp)
 1360 0f38 740C     		je	.L65
 411:hexio.c       **** 		bufDestroy(&tmpSourceMask);
 1361              		.loc 1 411 0
 1362 0f3a 488D45E0 		leaq	-32(%rbp), %rax
 1363 0f3e 4889C7   		movq	%rax, %rdi
 1364 0f41 E8000000 		call	bufDestroy@PLT
 1364      00
 1365              	.L65:
 412:hexio.c       **** 	}
 413:hexio.c       **** cleanupFile:
 414:hexio.c       **** 	fclose(file);	
 1366              		.loc 1 414 0
 1367 0f46 488B45D8 		movq	-40(%rbp), %rax
 1368 0f4a 4889C7   		movq	%rax, %rdi
 1369 0f4d E8000000 		call	fclose@PLT
 1369      00
 415:hexio.c       **** 	return returnCode;
 1370              		.loc 1 415 0
 1371 0f52 8B45C4   		movl	-60(%rbp), %eax
 1372              	.L85:
 416:hexio.c       **** }
 1373              		.loc 1 416 0 discriminator 1
 1374 0f55 488B4DF8 		movq	-8(%rbp), %rcx
 1375 0f59 6448330C 		xorq	%fs:40, %rcx
 1375      25280000 
 1375      00
 1376 0f62 7405     		je	.L86
 1377              		.loc 1 416 0 is_stmt 0
 1378 0f64 E8000000 		call	__stack_chk_fail@PLT
 1378      00
 1379              	.L86:
 1380 0f69 C9       		leave
 1381              		.cfi_def_cfa 7, 8
 1382 0f6a C3       		ret
 1383              		.cfi_endproc
 1384              	.LFE9:
 1386              	.Letext0:
 1387              		.file 2 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
 1388              		.file 3 "/usr/include/x86_64-linux-gnu/bits/types.h"
 1389              		.file 4 "/usr/include/stdio.h"
 1390              		.file 5 "/usr/include/libio.h"
 1391              		.file 6 "/home/asoreyh/Dropbox/projects/lago/lago-software/acqua/brc/lago/makestuff/common/makestu
 1392              		.file 7 "libbuffer.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 hexio.c
     /tmp/ccpjiPwQ.s:47     .text:0000000000000000 bufProcessLine
     /tmp/ccpjiPwQ.s:572    .text:0000000000000755 bufReadFromIntelHexFile
     /tmp/ccpjiPwQ.s:732    .text:0000000000000970 writeHexByte
     /tmp/ccpjiPwQ.s:771    .text:00000000000009bb writeHexWordBE
     /tmp/ccpjiPwQ.s:835    .text:0000000000000a53 bufDeriveMask
     /tmp/ccpjiPwQ.s:991    .text:0000000000000b7d bufWriteToIntelHexFile

UNDEFINED SYMBOLS
_GLOBAL_OFFSET_TABLE_
errRender
getHexByte
sprintf
strncmp
bufWriteBlock
bufWriteConst
__stack_chk_fail
fopen
errRenderStd
bufZeroLength
fgets
fclose
getHexUpperNibble
fputc
getHexLowerNibble
bufAppendConst
bufInitialise
fwrite
bufDestroy
